diff --git a/arch/arm64/boot/dts/allwinner/Makefile b/arch/arm64/boot/dts/allwinner/Makefile
index 30a51b913..60fba6bd9 100644
--- a/arch/arm64/boot/dts/allwinner/Makefile
+++ b/arch/arm64/boot/dts/allwinner/Makefile
@@ -50,5 +50,6 @@ dtb-$(CONFIG_ARCH_SUNXI) += sun50i-h6-tanix-tx6.dtb
 dtb-$(CONFIG_ARCH_SUNXI) += sun50i-h6-tanix-tx6-mini.dtb
 dtb-$(CONFIG_ARCH_SUNXI) += sun50i-h616-orangepi-zero2.dtb
 dtb-$(CONFIG_ARCH_SUNXI) += sun50i-h616-x96-mate.dtb
+dtb-$(CONFIG_ARCH_SUNXI) += sun50i-h616-mangopi-mcore.dtb
 
 subdir-y	:= $(dts-dirs) overlay
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h616-cpu-opp.dtsi b/arch/arm64/boot/dts/allwinner/sun50i-h616-cpu-opp.dtsi
new file mode 100644
index 000000000..495d79740
--- /dev/null
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h616-cpu-opp.dtsi
@@ -0,0 +1,108 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+// Copyright (C) 2021 Piotr Oniszczuk <piotr.oniszczuk@gmail.com>
+/*
+  Opi Zero2:bin0  bin1 Tx6s:bin0  bin1
+ 480000000  820mV  880mV  / 820mV  880mV
+ 600000000  820mV  880mV  / 820mV  880mV
+ 792000000  860mV  940mV  / 860mV  940mV
+ 1008000000 900mV  1020mV / 900mV  1020mV
+ 1200000000 960mV  1100mV / 960mV  1100mV
+ 1296000000 1100mV 1100mV / 1100mV 1100mV
+ 1344000000 1120mV 1120mV / 1120mV 1120mV
+ 1512000000 1120mV 1120mV / 1120mV 1120mV
+*/
+
+ /{
+	cpu_opp_table: cpu-opp-table {
+		compatible = "operating-points-v2";
+		opp-shared;
+		opp-480000000 {
+			clock-latency-ns = <244144>; /* 8 32k periods */
+			opp-hz = /bits/ 64 <480000000>;
+		        opp-microvolt = <820000 820000 1200000>;
+		};
+
+		opp-600000000 {
+			clock-latency-ns = <244144>; /* 8 32k periods */
+			opp-hz = /bits/ 64 <600000000>;
+			opp-microvolt = <820000 820000 1200000>;
+		};
+
+       	opp-792000000 {
+			clock-latency-ns = <244144>; /* 8 32k periods */
+		        opp-hz = /bits/ 64 <792000000>;
+			opp-microvolt = <860000 860000 1200000>;
+		};
+
+		opp-1008000000 {
+			clock-latency-ns = <244144>; /* 8 32k periods */
+			opp-hz = /bits/ 64 <1008000000>;
+			opp-microvolt = <900000 900000 1200000>;
+		};
+
+		opp-1200000000 {
+			clock-latency-ns = <244144>; /* 8 32k periods */
+			opp-hz = /bits/ 64 <1200000000>;
+		        opp-microvolt = <960000 960000 1200000>;
+		};
+
+		opp-1296000000 {
+			clock-latency-ns = <244144>; /* 8 32k periods */
+			opp-hz = /bits/ 64 <1296000000>;
+		        opp-microvolt = <1120000 1120000 1200000>;
+		};
+	
+		opp-1344000000 {
+			clock-latency-ns = <244144>; /* 8 32k periods */
+			opp-hz = /bits/ 64 <1344000000>;
+		        opp-microvolt = <1120000 1120000 1200000>;
+		};
+	
+		opp-1416000000 {
+			clock-latency-ns = <244144>; /* 8 32k periods */
+			opp-hz = /bits/ 64 <1416000000>;
+		         opp-microvolt = <1120000 1120000 1200000>;
+		};
+
+		opp-1512000000 {
+			clock-latency-ns = <244144>; /* 8 32k periods */
+			opp-hz = /bits/ 64 <1512000000>;
+		        opp-microvolt = <1120000 1120000 1200000>;
+		};
+		
+		opp-1608000000 {
+			clock-latency-ns = <244144>; /* 8 32k periods */
+			opp-hz = /bits/ 64 <1608000000>;
+			opp-microvolt = <1160000 1160000 1200000>;
+		};
+
+		opp-1704000000 {
+			clock-latency-ns = <244144>; /* 8 32k periods */
+			opp-hz = /bits/ 64 <1704000000>;
+			opp-microvolt = <1180000 1180000 1200000>;
+		};
+
+		opp-1800000000 {
+			clock-latency-ns = <244144>; /* 8 32k periods */
+			opp-hz = /bits/ 64 <1800000000>;
+			opp-microvolt = <1200000 1200000 1200000>;
+		};
+												
+	};
+};
+
+&cpu0 {
+	operating-points-v2 = <&cpu_opp_table>;
+};
+
+&cpu1 {
+	operating-points-v2 = <&cpu_opp_table>;
+};
+
+&cpu2 {
+	operating-points-v2 = <&cpu_opp_table>;
+};
+
+&cpu3 {
+	operating-points-v2 = <&cpu_opp_table>;
+};
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h616-mangopi-mcore.dts b/arch/arm64/boot/dts/allwinner/sun50i-h616-mangopi-mcore.dts
new file mode 100644
index 000000000..8140417fb
--- /dev/null
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h616-mangopi-mcore.dts
@@ -0,0 +1,358 @@
+// SPDX-License-Identifier: (GPL-2.0+ or MIT)
+/*
+ * Copyright (C) 2020 Arm Ltd.
+ */
+
+/dts-v1/;
+
+#include "sun50i-h616.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include "sun50i-h616-cpu-opp.dtsi"
+
+/ {
+	model = "MangoPi Mcore";
+	compatible = "mgcc,mangopi-mcore", "allwinner,sun50i-h616";
+
+	aliases {
+		ethernet0 = &emac0;
+		ethernet1 = &emac1;
+		serial0 = &uart0;
+		serial1 = &uart2;
+		mmc0 =&mmc0;
+		mmc1 =&mmc1;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+	
+	connector {
+		compatible = "hdmi-connector";
+		type = "d";
+
+		port {
+			hdmi_con_in: endpoint {
+				remote-endpoint = <&hdmi_out_con>;
+			};
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+
+		status {
+			label = "led_red";
+			linux,default-trigger = "heartbeat";
+			gpios = <&pio 2 13 GPIO_ACTIVE_HIGH>; /* PC13 */
+			default-state = "on";
+			
+		};
+	};
+	
+
+	reg_vcc5v: vcc5v {
+		/* board wide 5V supply directly from the USB-C socket */
+		compatible = "regulator-fixed";
+		regulator-name = "vcc-5v";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-always-on;
+	};
+
+	reg_usb1_vbus: usb1-vbus {
+		compatible = "regulator-fixed";
+		regulator-name = "usb1-vbus";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&pio 2 8 GPIO_ACTIVE_HIGH>; /* PC8 */
+		status = "okay";
+	};
+};
+
+&cpu0 {
+	cpu-supply = <&reg_dcdca>;
+	status = "okay";
+};
+
+&gpu {
+	mali-supply = <&reg_dcdcc>;
+	status = "okay";
+};
+
+&ehci0 {
+	status = "okay";
+};
+
+&ehci1 {
+	status = "okay";
+};
+
+&ehci2 {
+	status = "okay";
+};
+
+&ehci3 {
+	status = "okay";
+};
+
+/* USB 2 & 3 are on headers only. */
+
+&emac0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ext_rgmii_pins>;
+	phy-mode = "rgmii";
+	phy-handle = <&ext_rgmii_phy>;
+	phy-supply = <&reg_aldo1>;
+	allwinner,rx-delay-ps = <3100>;
+	allwinner,tx-delay-ps = <700>;
+	status = "disabled";
+};
+
+&mdio0 {
+	ext_rgmii_phy: ethernet-phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <1>;
+	};
+};
+
+&emac1{
+	pinctrl-names = "default";
+	pinctrl-0 = <&rmii_pins>;
+	phy-mode = "rmii";
+	phy-handle = <&emd_rgmii_phy>;
+	phy-supply = <&reg_aldo1>;
+	allwinner,rx-delay-ps = <3100>;
+	allwinner,tx-delay-ps = <700>;
+	status = "okay";
+};
+
+&mdio1 {
+	emd_rgmii_phy: ethernet-phy@0 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <0>;
+	};
+};
+
+
+&mmc0 {
+	vmmc-supply = <&reg_aldo1>;
+	cd-gpios = <&pio 5 6 GPIO_ACTIVE_LOW>;	/* PF6 */
+	bus-width = <4>;
+	status = "okay";
+};
+
+&mmc2 {
+	vmmc-supply = <&reg_aldo1>;
+	vqmmc-supply = <&reg_bldo1>;
+	bus-width = <8>;
+	non-removable;
+	cap-mmc-hw-reset;
+	mmc-hs200-1_8v;
+	status = "disabled";
+};
+
+&mmc1 {
+	vmmc-supply = <&reg_aldo1>;
+	vqmmc-supply = <&reg_aldo1>;
+	bus-width = <4>;
+	non-removable;
+	status = "okay";
+};
+
+&spi0  {
+	status = "okay";
+
+	flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <40000000>;
+	};
+};
+
+&spi1 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi1_pins>,<&spi1_cs_pin>;
+	spidev@0 {
+		compatible = "rohm,dh2228fv";
+		status = "okay";
+		reg = <0>;
+		spi-max-frequency = <2000000>;
+	};
+};
+
+&ohci0 {
+	status = "okay";
+};
+
+&ohci1 {
+	status = "okay";
+};
+&ohci2 {
+	status = "okay";
+};
+
+&ohci3 {
+	status = "okay";
+};
+
+&de {
+	status = "okay";
+};
+
+&hdmi {
+	hvcc-supply = <&reg_bldo1>;
+	status = "okay";
+};
+
+&hdmi_out {
+	hdmi_out_con: endpoint {
+		remote-endpoint = <&hdmi_con_in>;
+	};
+};
+
+&r_i2c {
+	status = "okay";
+
+	axp305: pmic@36  {
+		compatible = "x-powers,axp1530";
+		reg = <0x36>;
+
+		/* dummy interrupt to appease the driver for now */
+		interrupt-controller;
+		#interrupt-cells = <1>;
+
+		vin1-supply = <&reg_vcc5v>;
+		vin2-supply = <&reg_vcc5v>;
+		vin3-supply = <&reg_vcc5v>;
+		ldo1in-supply = <&reg_vcc5v>;
+		ldo2in-supply = <&reg_vcc5v>;
+
+		regulators {
+			reg_aldo1: ldo2 {
+				regulator-always-on;
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vcc-sys";
+			};
+
+			reg_bldo1: ldo1 {
+				regulator-always-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcc1v8";
+			};
+
+			reg_dcdca: dcdc2 {
+				regulator-always-on;
+				regulator-min-microvolt = <810000>;
+				regulator-max-microvolt = <1200000>;
+				regulator-name = "vdd-cpu";
+			};
+
+			reg_dcdcc: dcdc1 {
+				regulator-always-on;
+				regulator-min-microvolt = <810000>;
+				regulator-max-microvolt = <1160000>;
+				regulator-name = "vdd-gpu-sys";
+			};
+
+			reg_dcdcd: dcdc3 {
+				regulator-always-on;
+				regulator-min-microvolt = <1500000>;
+				regulator-max-microvolt = <1500000>;
+				regulator-name = "vdd-dram";
+			};
+
+		};
+	};
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_ph_pins>;
+	status = "okay";
+};
+
+&uart1 {
+ uart-has-rtscts;
+ pinctrl-0 = <&uart1_pins>, <&uart1_rts_cts_pins>;
+ pinctrl-names = "default";
+ status = "okay";
+
+   bluetooth {
+              compatible = "realtek,rtl8723ds-bt";
+              device-wake-gpios = <&pio 6 17 GPIO_ACTIVE_HIGH>; /* PG17 */
+              enable-gpios = <&pio 6 19 GPIO_ACTIVE_HIGH>; /* PG19 */
+              host-wake-gpios = <&pio 6 16 GPIO_ACTIVE_HIGH>; /* PG16 */
+ };
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart2_pins>;
+	status = "okay";
+};
+
+&usbotg {
+	dr_mode = "host";	/* USB A type receptable */
+        status = "okay";
+};
+
+&usbphy {
+	status = "okay";
+};
+
+&i2c1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c1_pins>;
+	status = "okay";
+};
+
+&i2c2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c2_pins>;
+	status = "okay";
+};
+
+&codec {
+	allwinner,audio-routing =
+		"Line Out", "LINEOUT";
+	status = "okay";
+};
+
+&ahub_codec {
+	status = "okay";
+};
+
+&ahub_cpudai0 {
+	status = "okay";
+};
+
+&ahub_cpudai1 {
+	status = "okay";
+};
+
+&ahub_cpudai2 {
+	status = "okay";
+};
+
+&sndahub {
+	status = "okay";
+};
+
+&ahub_i2s1 {
+	status = "okay";
+};
+
+&hdmi_audio {
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h616.dtsi b/arch/arm64/boot/dts/allwinner/sun50i-h616.dtsi
index e4f5a085f..b15bcdd31 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-h616.dtsi
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h616.dtsi
@@ -8,6 +8,9 @@
 #include <dt-bindings/clock/sun50i-h6-r-ccu.h>
 #include <dt-bindings/reset/sun50i-h616-ccu.h>
 #include <dt-bindings/reset/sun50i-h6-r-ccu.h>
+#include <dt-bindings/clock/sun8i-de2.h>
+#include <dt-bindings/clock/sun8i-tcon-top.h>
+#include <dt-bindings/reset/sun8i-de2.h>
 #include <dt-bindings/thermal/thermal.h>
 
 / {
@@ -26,7 +29,6 @@ cpu0: cpu@0 {
 			enable-method = "psci";
 			clocks = <&ccu CLK_CPUX>;
 			clock-latency-ns = <244144>; /* 8 32k periods */
-			#cooling-cells = <2>;
 		};
 
 		cpu1: cpu@1 {
@@ -36,7 +38,6 @@ cpu1: cpu@1 {
 			enable-method = "psci";
 			clocks = <&ccu CLK_CPUX>;
 			clock-latency-ns = <244144>; /* 8 32k periods */
-			#cooling-cells = <2>;
 		};
 
 		cpu2: cpu@2 {
@@ -46,7 +47,6 @@ cpu2: cpu@2 {
 			enable-method = "psci";
 			clocks = <&ccu CLK_CPUX>;
 			clock-latency-ns = <244144>; /* 8 32k periods */
-			#cooling-cells = <2>;
 		};
 
 		cpu3: cpu@3 {
@@ -56,10 +56,15 @@ cpu3: cpu@3 {
 			enable-method = "psci";
 			clocks = <&ccu CLK_CPUX>;
 			clock-latency-ns = <244144>; /* 8 32k periods */
-			#cooling-cells = <2>;
 		};
 	};
 
+	de: display-engine {
+		compatible = "allwinner,sun50i-h6-display-engine";
+		allwinner,pipelines = <&mixer0>;
+		status = "disabled";
+	};
+	
 	reserved-memory {
 		#address-cells = <2>;
 		#size-cells = <2>;
@@ -111,7 +116,51 @@ soc {
 		#address-cells = <1>;
 		#size-cells = <1>;
 		ranges = <0x0 0x0 0x0 0x40000000>;
+		
+		bus@1000000 {
+			compatible = "allwinner,sun50i-h616-de33",
+				     "allwinner,sun50i-a64-de2";
+			reg = <0x1000000 0x400000>;
+			allwinner,sram = <&de3_sram 1>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0 0x1000000 0x400000>;
+
+			display_clocks: clock@8000 {
+				compatible = "allwinner,sun50i-h616-de33-clk";
+				reg = <0x8000 0x100>;
+				clocks = <&ccu CLK_DE>, <&ccu CLK_BUS_DE>;
+				clock-names = "mod", "bus";
+				resets = <&ccu RST_BUS_DE>;
+				#clock-cells = <1>;
+				#reset-cells = <1>;
+			};
 
+			mixer0: mixer@100000 {
+				compatible = "allwinner,sun50i-h616-de33-mixer-0";
+				reg = <0x100000 0x100000>,
+				      <0x8100 0x40>,
+				      <0x280000 0x20000>;
+				clocks = <&display_clocks CLK_BUS_MIXER0>,
+					 <&display_clocks CLK_MIXER0>;
+				clock-names = "bus", "mod";
+				resets = <&display_clocks RST_MIXER0>;
+
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					mixer0_out: port@1 {
+						reg = <1>;
+
+						mixer0_out_tcon_top_mixer0: endpoint {
+							remote-endpoint = <&tcon_top_mixer0_in_mixer0>;
+						};
+					};
+				};
+			};
+		};
+		
 		gpu: gpu@1800000 {
 			compatible = "allwinner,sun50i-h616-mali",
 				     "arm,mali-bifrost";
@@ -150,6 +199,12 @@ sram_c: sram@28000 {
 				#address-cells = <1>;
 				#size-cells = <1>;
 				ranges = <0 0x00028000 0x30000>;
+				
+			        de3_sram: sram-section@0 {
+					compatible = "allwinner,sun50i-h616-sram-c",
+						     "allwinner,sun50i-a64-sram-c";
+					reg = <0x0000 0x1e000>;
+				};
 			};
 
 			sram_c1: sram@1a00000 {
@@ -217,6 +272,18 @@ pio: pinctrl@300b000 {
 			interrupt-controller;
 			#interrupt-cells = <3>;
 
+                       ext_rmii_pins:rmii_pins {
+				pins = "PI2", "PI3","PI5", "PI6", "PI9", "PI10",
+				       "PI11", "PI12", "PI14", "PI15";
+				function = "emac0";
+				drive-strength = <40>;
+			};
+			
+			pwm1_pin: pwm-pin {
+				pins = "PA12";
+				function = "pwm5";
+			};
+			
 			ext_rgmii_pins: rgmii-pins {
 				pins = "PI0", "PI1", "PI2", "PI3", "PI4",
 				       "PI5", "PI7", "PI8", "PI9", "PI10",
@@ -231,10 +298,25 @@ i2c0_pins: i2c0-pins {
 				function = "i2c0";
 			};
 
+			i2c1_pins: i2c1-pins {
+				pins = "PI7", "PI8";
+				function = "i2c1";
+			};
+			
+			i2c2_pins: i2c2-pins {
+				pins = "PI9", "PI10";
+				function = "i2c2";
+			};
+						
 			i2c3_ph_pins: i2c3-ph-pins {
 				pins = "PH4", "PH5";
 				function = "i2c3";
 			};
+			
+			i2s3_pins: i2s3-pins {
+				pins = "PH5", "PH6", "PH7", "PH8", "PH9";
+				function = "i2s3";
+			};
 
 			ir_rx_pin: ir-rx-pin {
 				pins = "PH10";
@@ -288,6 +370,11 @@ spi1_cs_pin: spi1-cs-pin {
 				function = "spi1";
 			};
 
+			spi1_cs1_pin: spi1-cs1-pin {
+				pins = "PH9";
+				function = "spi1";
+			};
+
 			uart0_ph_pins: uart0-ph-pins {
 				pins = "PH0", "PH1";
 				function = "uart0";
@@ -297,7 +384,12 @@ uart1_pins: uart1-pins {
 				pins = "PG6", "PG7";
 				function = "uart1";
 			};
-
+			
+			uart2_pins: uart2-pins {
+				pins = "PI5", "PI6";
+				function = "uart2";
+			};
+			
 			uart1_rts_cts_pins: uart1-rts-cts-pins {
 				pins = "PG8", "PG9";
 				function = "uart1";
@@ -380,6 +472,127 @@ mmc2: mmc@4022000 {
 			#address-cells = <1>;
 			#size-cells = <0>;
 		};
+		
+		dma: dma-controller@3002000 {
+			compatible = "allwinner,sun50i-h616-dma";
+			reg = <0x03002000 0x1000>;
+			interrupts = <GIC_SPI 42 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_DMA>, <&ccu CLK_MBUS_DMA>;
+			clock-names = "bus", "mbus";
+			dma-channels = <16>;
+			dma-requests = <49>;
+			resets = <&ccu RST_BUS_DMA>;
+			#dma-cells = <1>;
+		};
+
+		codec: codec@0x05096000 {
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sun50i-h616-codec";
+			reg = <0x05096000 0x31c>;
+			interrupts = <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_AUDIO_CODEC>,
+				 <&ccu CLK_AUDIO_CODEC_1X>,
+				 <&ccu CLK_AUDIO_CODEC_4X>;
+			clock-names = "apb", "audio-codec-1x", "audio-codec-4x";
+			resets = <&ccu RST_BUS_AUDIO_CODEC>;
+			dmas = <&dma 6>;
+			dma-names = "tx";
+			status = "disabled";
+		};
+
+		ahub_codec: ahub_codec@0x05097000 {
+			compatible = "allwinner,sunxi-ahub";
+			reg = <0x5097000 0xadf>;
+			clocks = <&ccu CLK_BUS_AUDIO_HUB>,
+				 <&ccu CLK_AUDIO_CODEC_1X>,
+				 <&ccu CLK_AUDIO_CODEC_4X>,
+				 <&ccu CLK_AUDIO_HUB>;
+			clock-names = "apb", "audio-codec-1x", "audio-codec-4x", "audio-hub";
+			resets = <&ccu RST_BUS_AUDIO_HUB>;
+			status = "disabled";
+		};
+
+		ahub_cpudai0: cpudai0-controller@0x05097000 {
+			compatible = "allwinner,sunxi-ahub-cpudai";
+			reg = <0x05097000 0xADF>;
+			id = <0x0>;
+			dmas = <&dma 3>, <&dma 3>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		ahub_cpudai1: cpudai1-controller@0x05097000 {
+			compatible = "allwinner,sunxi-ahub-cpudai";
+			reg = <0x05097000 0xADF>;
+			id = <0x1>;
+			dmas = <&dma 4>, <&dma 4>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		ahub_cpudai2: cpudai2-controller@0x05097000 {
+			compatible = "allwinner,sunxi-ahub-cpudai";
+			reg = <0x05097000 0xADF>;
+			id = <0x2>;
+			dmas = <&dma 5>, <&dma 5>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		sndahub: sound@0{
+			compatible = "allwinner,sunxi-ahub-machine";
+			sunxi,cpudai-controller0 = <&ahub_cpudai0>;
+			sunxi,cpudai-controller1 = <&ahub_cpudai1>;
+			sunxi,cpudai-controller2 = <&ahub_cpudai2>;
+			sunxi,audio-codec = <&ahub_codec>;
+			status = "disabled";
+		};
+
+		ahub_i2s1: ahub-i2s1@0x05097000 {
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sunxi-ahub-daudio";
+			reg = <0x5097000 0xadf>;
+			clocks = <&ccu CLK_BUS_AUDIO_HUB>,
+				 <&ccu CLK_AUDIO_CODEC_1X>,
+				 <&ccu CLK_AUDIO_CODEC_4X>,
+				 <&ccu CLK_AUDIO_HUB>;
+			clock-names = "apb", "audio-codec-1x", "audio-codec-4x", "audio-hub";
+			tdm_num = <0x1>;
+			pinconfig = <0x0>;
+			frametype = <0x0>;
+			pcm_lrck_period = <0x20>;
+			slot_width_select = <0x20>;
+			daudio_master = <0x4>;
+			audio_format = <0x1>;
+			signal_inversion = <0x1>;
+			tdm_config = <0x1>;
+			mclk_div = <0x1>;
+			status = "disabled";
+		};
+
+		ahub_i2s3: ahub-i2s3@0x05097000 {
+			//#sound-dai-cells = <0>;
+			compatible = "allwinner,sunxi-ahub-daudio";
+			reg = <0x5097000 0xadf>;
+			clocks = <&ccu CLK_BUS_AUDIO_HUB>,
+				 <&ccu CLK_AUDIO_CODEC_1X>,
+				 <&ccu CLK_AUDIO_CODEC_4X>,
+				 <&ccu CLK_AUDIO_HUB>;
+			clock-names = "apb", "audio-codec-1x", "audio-codec-4x", "audio-hub";
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2s3_pins>;
+			tdm_num = <0x3>;
+			pinconfig = <0x1>;
+			frametype = <0x0>;
+			pcm_lrck_period = <0x20>;
+			slot_width_select = <0x20>;
+			daudio_master = <0x4>;
+			audio_format = <0x1>;
+			signal_inversion = <0x1>;
+			tdm_config = <0x1>;
+			mclk_div = <0x4>;
+			status = "disabled";
+		};
 
 		uart0: serial@5000000 {
 			compatible = "snps,dw-apb-uart";
@@ -749,6 +962,154 @@ ohci3: usb@5311400 {
 			phy-names = "usb";
 			status = "disabled";
 		};
+		
+              hdmi_audio: hdmi-audio@1 {
+			compatible = "allwinner,sunxi-hdmi-machine";
+			sunxi,cpudai-controller = <&ahub_i2s1>;
+			sunxi,snddaudio-codec = "hdmi-audio-codec.4.auto";
+			status = "disabled";
+		};
+		
+	      hdmi: hdmi@6000000 {
+			compatible = "allwinner,sun50i-h616-dw-hdmi",
+				     "allwinner,sun50i-h6-dw-hdmi";
+			reg = <0x06000000 0x10000>;
+			reg-io-width = <1>;
+			interrupts = <GIC_SPI 63 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_HDMI>, <&ccu CLK_HDMI_SLOW>,
+				 <&ccu CLK_HDMI>, <&ccu CLK_HDMI_CEC>,
+				 <&ccu CLK_HDCP>, <&ccu CLK_BUS_HDCP>;
+			clock-names = "iahb", "isfr", "tmds", "cec", "hdcp",
+				      "hdcp-bus";
+			resets = <&ccu RST_BUS_HDMI>, <&ccu RST_BUS_HDCP>;
+			reset-names = "ctrl", "hdcp";
+			phys = <&hdmi_phy>;
+			phy-names = "phy";
+			status = "disabled";
+			aw-hdmi-codec-quirk;
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				hdmi_in: port@0 {
+					reg = <0>;
+
+					hdmi_in_tcon_top: endpoint {
+						remote-endpoint = <&tcon_top_hdmi_out_hdmi>;
+					};
+				};
+
+				hdmi_out: port@1 {
+					reg = <1>;
+				};
+			};
+		};
+
+		hdmi_phy: hdmi-phy@6010000 {
+			compatible = "allwinner,sun50i-h616-hdmi-phy";
+			reg = <0x06010000 0x10000>;
+			clocks = <&ccu CLK_BUS_HDMI>, <&ccu CLK_HDMI_SLOW>;
+			clock-names = "bus", "mod";
+			resets = <&ccu RST_BUS_HDMI_SUB>;
+			reset-names = "phy";
+			#phy-cells = <0>;
+		};
+
+		tcon_top: tcon-top@6510000 {
+			compatible = "allwinner,sun50i-h6-tcon-top";
+			reg = <0x06510000 0x1000>;
+			clocks = <&ccu CLK_BUS_TCON_TOP>,
+				 <&ccu CLK_TCON_TV0>;
+			clock-names = "bus",
+				      "tcon-tv0";
+			clock-output-names = "tcon-top-tv0";
+			resets = <&ccu RST_BUS_TCON_TOP>;
+			#clock-cells = <1>;
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				tcon_top_mixer0_in: port@0 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0>;
+
+					tcon_top_mixer0_in_mixer0: endpoint@0 {
+						reg = <0>;
+						remote-endpoint = <&mixer0_out_tcon_top_mixer0>;
+					};
+				};
+
+				tcon_top_mixer0_out: port@1 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <1>;
+
+					tcon_top_mixer0_out_tcon_tv: endpoint@2 {
+						reg = <2>;
+						remote-endpoint = <&tcon_tv_in_tcon_top_mixer0>;
+					};
+				};
+
+				tcon_top_hdmi_in: port@4 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <4>;
+
+					tcon_top_hdmi_in_tcon_tv: endpoint@0 {
+						reg = <0>;
+						remote-endpoint = <&tcon_tv_out_tcon_top>;
+					};
+				};
+
+				tcon_top_hdmi_out: port@5 {
+					reg = <5>;
+
+					tcon_top_hdmi_out_hdmi: endpoint {
+						remote-endpoint = <&hdmi_in_tcon_top>;
+					};
+				};
+			};
+		};
+
+		tcon_tv: lcd-controller@6515000 {
+			compatible = "allwinner,sun50i-h6-tcon-tv",
+				     "allwinner,sun8i-r40-tcon-tv";
+			reg = <0x06515000 0x1000>;
+			interrupts = <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_TCON_TV0>,
+				 <&tcon_top CLK_TCON_TOP_TV0>;
+			clock-names = "ahb",
+				      "tcon-ch1";
+			resets = <&ccu RST_BUS_TCON_TV0>;
+			reset-names = "lcd";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				tcon_tv_in: port@0 {
+					reg = <0>;
+
+					tcon_tv_in_tcon_top_mixer0: endpoint {
+						remote-endpoint = <&tcon_top_mixer0_out_tcon_tv>;
+					};
+				};
+
+				tcon_tv_out: port@1 {
+				#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <1>;
+
+					tcon_tv_out_tcon_top: endpoint@1 {
+						reg = <1>;
+						remote-endpoint = <&tcon_top_hdmi_in_tcon_tv>;
+					};
+				};
+			};
+		};
 
 		rtc: rtc@7000000 {
 			compatible = "allwinner,sun50i-h616-rtc";
@@ -854,35 +1215,12 @@ cpu-thermal {
 			k_pu = <40>;
 			k_i = <0>;
 
-			trips {
-				cpu_threshold: trip-point@0 {
-					temperature = <60000>;
-					type = "passive";
-					hysteresis = <0>;
-				};
-				cpu_target: trip-point@1 {
-					temperature = <70000>;
-					type = "passive";
-					hysteresis = <0>;
-				};
-			};
-
-			cooling-maps {
-				map0 {
-					trip = <&cpu_target>;
-					cooling-device = <&cpu0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
-							 <&cpu1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
-							 <&cpu2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
-							 <&cpu3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
-				};
-			};
 		};
 
 		gpu-thermal {
-			polling-delay-passive = <500>;
-			polling-delay = <1000>;
+			polling-delay-passive = <0>;
+			polling-delay = <0>;
 			thermal-sensors = <&ths 0>;
-			sustainable-power = <1100>;
 		};
 
 		ve-thermal {
diff --git a/drivers/clk/sunxi-ng/Makefile b/drivers/clk/sunxi-ng/Makefile
index 6b3ae2b62..8ad73eba5 100644
--- a/drivers/clk/sunxi-ng/Makefile
+++ b/drivers/clk/sunxi-ng/Makefile
@@ -43,7 +43,7 @@ obj-$(CONFIG_SUN8I_A83T_CCU)	+= sun8i-a83t-ccu.o
 obj-$(CONFIG_SUN8I_H3_CCU)	+= sun8i-h3-ccu.o
 obj-$(CONFIG_SUN8I_R40_CCU)	+= sun8i-r40-ccu.o
 obj-$(CONFIG_SUN8I_V3S_CCU)	+= sun8i-v3s-ccu.o
-obj-$(CONFIG_SUN8I_DE2_CCU)	+= sun8i-de2-ccu.o
+obj-$(CONFIG_SUN8I_DE2_CCU)	+= sun8i-de2-ccu.o sun8i-de33.o
 obj-$(CONFIG_SUN8I_R_CCU)	+= sun8i-r-ccu.o
 obj-$(CONFIG_SUN9I_A80_CCU)	+= sun9i-a80-ccu.o
 obj-$(CONFIG_SUN9I_A80_CCU)	+= sun9i-a80-de-ccu.o
diff --git a/drivers/clk/sunxi-ng/ccu-sun50i-h616.c b/drivers/clk/sunxi-ng/ccu-sun50i-h616.c
index 21e918582..d0c9f4f17 100644
--- a/drivers/clk/sunxi-ng/ccu-sun50i-h616.c
+++ b/drivers/clk/sunxi-ng/ccu-sun50i-h616.c
@@ -35,6 +35,12 @@
  * testing", so it's not modelled and then force to 0.
  */
 #define SUN50I_H616_PLL_CPUX_REG	0x000
+
+static struct ccu_sdm_setting pll_audio_sdm_table[] = {
+	{ .rate = 90316800, .pattern = 0xc001288d, .m = 3, .n = 22 },
+	{ .rate = 98304000, .pattern = 0xc001eb85, .m = 5, .n = 40 },
+};
+
 static struct ccu_mult pll_cpux_clk = {
 	.enable		= BIT(31),
 	.lock		= BIT(28),
@@ -227,8 +233,11 @@ static struct ccu_nm pll_audio_hs_clk = {
 	.enable		= BIT(31),
 	.lock		= BIT(28),
 	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
-	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.m		= _SUNXI_CCU_DIV(16, 6),
+	.sdm		= _SUNXI_CCU_SDM(pll_audio_sdm_table,
+					 BIT(24), 0x178, BIT(31)),
 	.common		= {
+	        .features	= CCU_FEATURE_SIGMA_DELTA_MOD,
 		.reg		= 0x078,
 		.hw.init	= CLK_HW_INIT("pll-audio-hs", "osc24M",
 					      &ccu_nm_ops,
@@ -361,7 +370,7 @@ static SUNXI_CCU_GATE(bus_dbg_clk, "bus-dbg", "psi-ahb1-ahb2",
 static SUNXI_CCU_GATE(bus_psi_clk, "bus-psi", "psi-ahb1-ahb2",
 		      0x79c, BIT(0), 0);
 
-static SUNXI_CCU_GATE(bus_pwm_clk, "bus-pwm", "apb1", 0x7ac, BIT(0), 0);
+//static SUNXI_CCU_GATE(bus_pwm_clk, "bus-pwm", "apb1", 0x7ac, BIT(0), 0);
 
 static SUNXI_CCU_GATE(bus_iommu_clk, "bus-iommu", "apb1", 0x7bc, BIT(0), 0);
 
@@ -688,13 +697,13 @@ static const struct clk_hw *clk_parent_pll_audio[] = {
  */
 static CLK_FIXED_FACTOR_HWS(pll_audio_1x_clk, "pll-audio-1x",
 			    clk_parent_pll_audio,
-			    96, 1, CLK_SET_RATE_PARENT);
+			    4, 1, CLK_SET_RATE_PARENT);
 static CLK_FIXED_FACTOR_HWS(pll_audio_2x_clk, "pll-audio-2x",
 			    clk_parent_pll_audio,
-			    48, 1, CLK_SET_RATE_PARENT);
+			    2, 1, CLK_SET_RATE_PARENT);
 static CLK_FIXED_FACTOR_HWS(pll_audio_4x_clk, "pll-audio-4x",
 			    clk_parent_pll_audio,
-			    24, 1, CLK_SET_RATE_PARENT);
+			    1, 1, CLK_SET_RATE_PARENT);
 
 static const struct clk_hw *pll_periph0_parents[] = {
 	&pll_periph0_clk.common.hw
@@ -768,7 +777,7 @@ static struct ccu_common *sun50i_h616_ccu_clks[] = {
 	&avs_clk.common,
 	&bus_dbg_clk.common,
 	&bus_psi_clk.common,
-	&bus_pwm_clk.common,
+//	&bus_pwm_clk.common,
 	&bus_iommu_clk.common,
 	&dram_clk.common,
 	&mbus_dma_clk.common,
@@ -901,7 +910,7 @@ static struct clk_hw_onecell_data sun50i_h616_hw_clks = {
 		[CLK_AVS]		= &avs_clk.common.hw,
 		[CLK_BUS_DBG]		= &bus_dbg_clk.common.hw,
 		[CLK_BUS_PSI]		= &bus_psi_clk.common.hw,
-		[CLK_BUS_PWM]		= &bus_pwm_clk.common.hw,
+//		[CLK_BUS_PWM]		= &bus_pwm_clk.common.hw,
 		[CLK_BUS_IOMMU]		= &bus_iommu_clk.common.hw,
 		[CLK_DRAM]		= &dram_clk.common.hw,
 		[CLK_MBUS_DMA]		= &mbus_dma_clk.common.hw,
@@ -1130,13 +1139,10 @@ static int sun50i_h616_ccu_probe(struct platform_device *pdev)
 		writel(val, reg + usb2_clk_regs[i]);
 	}
 
-	/*
-	 * Force the post-divider of pll-audio to 12 and the output divider
-	 * of it to 2, so 24576000 and 22579200 rates can be set exactly.
-	 */
 	val = readl(reg + SUN50I_H616_PLL_AUDIO_REG);
-	val &= ~(GENMASK(21, 16) | BIT(0));
-	writel(val | (11 << 16) | BIT(0), reg + SUN50I_H616_PLL_AUDIO_REG);
+	val &= ~BIT(1);
+	val |= BIT(0);
+	writel(val, reg + SUN50I_H616_PLL_AUDIO_REG); 
 
 	/*
 	 * First clock parent (osc32K) is unusable for CEC. But since there
diff --git a/drivers/clk/sunxi-ng/sun8i-de33.c b/drivers/clk/sunxi-ng/sun8i-de33.c
new file mode 100644
index 000000000..d574a7ef7
--- /dev/null
+++ b/drivers/clk/sunxi-ng/sun8i-de33.c
@@ -0,0 +1,181 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2017 Icenowy Zheng <icenowy@aosc.io>
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/reset.h>
+
+#include "ccu_common.h"
+#include "ccu_div.h"
+#include "ccu_gate.h"
+#include "ccu_reset.h"
+
+#include "sun8i-de33.h"
+
+static SUNXI_CCU_GATE(bus_mixer0_clk,	"bus-mixer0",	"bus-de",
+		      0x04, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_mixer1_clk,	"bus-mixer1",	"bus-de",
+		      0x04, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_wb_clk,	"bus-wb",	"bus-de",
+		      0x04, BIT(2), 0);
+
+static SUNXI_CCU_GATE(mixer0_clk,	"mixer0",	"mixer0-div",
+		      0x00, BIT(0), CLK_SET_RATE_PARENT);
+static SUNXI_CCU_GATE(mixer1_clk,	"mixer1",	"mixer1-div",
+		      0x00, BIT(1), CLK_SET_RATE_PARENT);
+static SUNXI_CCU_GATE(wb_clk,		"wb",		"wb-div",
+		      0x00, BIT(2), CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_M(mixer0_div_clk, "mixer0-div", "de", 0x0c, 0, 4,
+		   CLK_SET_RATE_PARENT);
+static SUNXI_CCU_M(mixer1_div_clk, "mixer1-div", "de", 0x0c, 4, 4,
+		   CLK_SET_RATE_PARENT);
+static SUNXI_CCU_M(wb_div_clk, "wb-div", "de", 0x0c, 8, 4,
+		   CLK_SET_RATE_PARENT);
+
+static struct ccu_common *sun50i_h616_de33_clks[] = {
+	&mixer0_clk.common,
+	&mixer1_clk.common,
+	&wb_clk.common,
+
+	&bus_mixer0_clk.common,
+	&bus_mixer1_clk.common,
+	&bus_wb_clk.common,
+
+	&mixer0_div_clk.common,
+	&mixer1_div_clk.common,
+	&wb_div_clk.common,
+};
+
+static struct clk_hw_onecell_data sun50i_h616_de33_hw_clks = {
+	.hws	= {
+		[CLK_MIXER0]		= &mixer0_clk.common.hw,
+		[CLK_MIXER1]		= &mixer1_clk.common.hw,
+		[CLK_WB]		= &wb_clk.common.hw,
+
+		[CLK_BUS_MIXER0]	= &bus_mixer0_clk.common.hw,
+		[CLK_BUS_MIXER1]	= &bus_mixer1_clk.common.hw,
+		[CLK_BUS_WB]		= &bus_wb_clk.common.hw,
+
+		[CLK_MIXER0_DIV]	= &mixer0_div_clk.common.hw,
+		[CLK_MIXER1_DIV]	= &mixer1_div_clk.common.hw,
+		[CLK_WB_DIV]		= &wb_div_clk.common.hw,
+	},
+	.num	= CLK_NUMBER,
+};
+
+static struct ccu_reset_map sun50i_h616_de33_resets[] = {
+	[RST_MIXER0]	= { 0x08, BIT(0) },
+	[RST_MIXER1]	= { 0x08, BIT(1) },
+	[RST_WB]	= { 0x08, BIT(2) },
+};
+
+static const struct sunxi_ccu_desc sun50i_h616_de33_clk_desc = {
+	.ccu_clks	= sun50i_h616_de33_clks,
+	.num_ccu_clks	= ARRAY_SIZE(sun50i_h616_de33_clks),
+
+	.hw_clks	= &sun50i_h616_de33_hw_clks,
+
+	.resets		= sun50i_h616_de33_resets,
+	.num_resets	= ARRAY_SIZE(sun50i_h616_de33_resets),
+};
+
+static int sunxi_de33_clk_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct clk *bus_clk, *mod_clk;
+	struct reset_control *rstc;
+	void __iomem *reg;
+	const struct sunxi_ccu_desc *ccu_desc;
+	int ret;
+
+	ccu_desc = of_device_get_match_data(&pdev->dev);
+	if (!ccu_desc)
+		return -EINVAL;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	reg = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(reg))
+		return PTR_ERR(reg);
+
+	bus_clk = devm_clk_get(&pdev->dev, "bus");
+	if (IS_ERR(bus_clk)) {
+		ret = PTR_ERR(bus_clk);
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Couldn't get bus clk: %d\n", ret);
+		return ret;
+	}
+
+	mod_clk = devm_clk_get(&pdev->dev, "mod");
+	if (IS_ERR(mod_clk)) {
+		ret = PTR_ERR(mod_clk);
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Couldn't get mod clk: %d\n", ret);
+		return ret;
+	}
+
+	rstc = devm_reset_control_get_exclusive(&pdev->dev, NULL);
+	if (IS_ERR(rstc)) {
+		ret = PTR_ERR(rstc);
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev,
+				"Couldn't get reset control: %d\n", ret);
+		return ret;
+	}
+
+	/* The clocks need to be enabled for us to access the registers */
+	ret = clk_prepare_enable(bus_clk);
+	if (ret) {
+		dev_err(&pdev->dev, "Couldn't enable bus clk: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(mod_clk);
+	if (ret) {
+		dev_err(&pdev->dev, "Couldn't enable mod clk: %d\n", ret);
+		goto err_disable_bus_clk;
+	}
+
+	/* The reset control needs to be asserted for the controls to work */
+	ret = reset_control_deassert(rstc);
+	if (ret) {
+		dev_err(&pdev->dev,
+			"Couldn't deassert reset control: %d\n", ret);
+		goto err_disable_mod_clk;
+	}
+
+	writel(0, reg + 0x24);
+	writel(0x0000A980, reg + 0x28);
+
+	of_sunxi_ccu_probe(pdev->dev.of_node, reg, ccu_desc);
+
+	return 0;
+
+err_disable_mod_clk:
+	clk_disable_unprepare(mod_clk);
+err_disable_bus_clk:
+	clk_disable_unprepare(bus_clk);
+	return ret;
+}
+
+static const struct of_device_id sunxi_de33_clk_ids[] = {
+	{
+		.compatible = "allwinner,sun50i-h616-de33-clk",
+		.data = &sun50i_h616_de33_clk_desc,
+	},
+	{ }
+};
+
+static struct platform_driver sunxi_de33_clk_driver = {
+	.probe	= sunxi_de33_clk_probe,
+	.driver	= {
+		.name	= "sunxi-de33-clks",
+		.of_match_table	= sunxi_de33_clk_ids,
+	},
+};
+builtin_platform_driver(sunxi_de33_clk_driver);
diff --git a/drivers/clk/sunxi-ng/sun8i-de33.h b/drivers/clk/sunxi-ng/sun8i-de33.h
new file mode 100644
index 000000000..1df6f3508
--- /dev/null
+++ b/drivers/clk/sunxi-ng/sun8i-de33.h
@@ -0,0 +1,19 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright 2016 Icenowy Zheng <icenowy@aosc.io>
+ */
+
+#ifndef _CCU_SUN8I_DE2_H_
+#define _CCU_SUN8I_DE2_H_
+
+#include <dt-bindings/clock/sun8i-de2.h>
+#include <dt-bindings/reset/sun8i-de2.h>
+
+/* Intermediary clock dividers are not exported */
+#define CLK_MIXER0_DIV	3
+#define CLK_MIXER1_DIV	4
+#define CLK_WB_DIV	5
+
+#define CLK_NUMBER	(CLK_WB + 1)
+
+#endif /* _CCU_SUN8I_DE2_H_ */ 		
diff --git a/drivers/cpufreq/sun50i-cpufreq-nvmem.c b/drivers/cpufreq/sun50i-cpufreq-nvmem.c
index d079e5569..880a8cb35 100644
--- a/drivers/cpufreq/sun50i-cpufreq-nvmem.c
+++ b/drivers/cpufreq/sun50i-cpufreq-nvmem.c
@@ -47,9 +47,9 @@ static int sun50i_cpufreq_get_efuse(u32 *versions)
 	if (!np)
 		return -ENOENT;
 
-	ret = of_device_is_compatible(np,
-				      "allwinner,sun50i-h6-operating-points");
-	if (!ret) {
+	if      (of_device_is_compatible(np, "allwinner,sun50i-h6-operating-points")) {}
+	else if (of_device_is_compatible(np, "allwinner,sun50i-h616-operating-points")) {}
+	else {
 		of_node_put(np);
 		return -ENOENT;
 	}
@@ -168,6 +168,7 @@ static struct platform_driver sun50i_cpufreq_driver = {
 
 static const struct of_device_id sun50i_cpufreq_match_list[] = {
 	{ .compatible = "allwinner,sun50i-h6" },
+	{ .compatible = "allwinner,sun50i-h616" },
 	{}
 };
 MODULE_DEVICE_TABLE(of, sun50i_cpufreq_match_list);
diff --git a/drivers/dma/sun6i-dma.c b/drivers/dma/sun6i-dma.c
index b7557f437..db0929317 100644
--- a/drivers/dma/sun6i-dma.c
+++ b/drivers/dma/sun6i-dma.c
@@ -1242,6 +1242,28 @@ static struct sun6i_dma_config sun50i_h6_dma_cfg = {
 	.has_mbus_clk = true,
 };
 
+/*
+ * The H616 binding uses the number of dma channels from the
+ * device tree node.
+ */
+static struct sun6i_dma_config sun50i_h616_dma_cfg = {
+        .clock_autogate_enable = sun6i_enable_clock_autogate_h3,
+        .set_burst_length = sun6i_set_burst_length_h3,
+        .set_drq          = sun6i_set_drq_h6,
+        .set_mode         = sun6i_set_mode_h6,
+        .src_burst_lengths = BIT(1) | BIT(4) | BIT(8) | BIT(16),
+        .dst_burst_lengths = BIT(1) | BIT(4) | BIT(8) | BIT(16),
+        .src_addr_widths   = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |
+                             BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |
+                             BIT(DMA_SLAVE_BUSWIDTH_4_BYTES) |
+                             BIT(DMA_SLAVE_BUSWIDTH_8_BYTES),
+        .dst_addr_widths   = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |
+                             BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |
+                             BIT(DMA_SLAVE_BUSWIDTH_4_BYTES) |
+                             BIT(DMA_SLAVE_BUSWIDTH_8_BYTES),
+        .has_mbus_clk = true,
+};
+
 /*
  * The V3s have only 8 physical channels, a maximum DRQ port id of 23,
  * and a total of 24 usable source and destination endpoints.
@@ -1275,6 +1297,7 @@ static const struct of_device_id sun6i_dma_match[] = {
 	{ .compatible = "allwinner,sun50i-a64-dma", .data = &sun50i_a64_dma_cfg },
 	{ .compatible = "allwinner,sun50i-a100-dma", .data = &sun50i_a100_dma_cfg },
 	{ .compatible = "allwinner,sun50i-h6-dma", .data = &sun50i_h6_dma_cfg },
+	{ .compatible = "allwinner,sun50i-h616-dma", .data = &sun50i_h616_dma_cfg },
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, sun6i_dma_match);
diff --git a/drivers/gpu/drm/sun4i/Kconfig b/drivers/gpu/drm/sun4i/Kconfig
index 6412b891b..3a43c436c 100644
--- a/drivers/gpu/drm/sun4i/Kconfig
+++ b/drivers/gpu/drm/sun4i/Kconfig
@@ -22,17 +22,6 @@ config DRM_SUN4I_HDMI
 	  Choose this option if you have an Allwinner SoC with an HDMI
 	  controller.
 
-config DRM_SUN4I_HDMI_AUDIO
-	bool "Allwinner A10 HDMI Audio Support"
-	default y
-	depends on DRM_SUN4I_HDMI
-	depends on SND_SOC=y || SND_SOC=DRM_SUN4I_HDMI
-	select SND_PCM_ELD
-	select SND_SOC_GENERIC_DMAENGINE_PCM
-	help
-	  Choose this option if you have an Allwinner SoC with an HDMI
-	  controller and want to use audio.
-
 config DRM_SUN4I_HDMI_CEC
 	bool "Allwinner A10 HDMI CEC Support"
 	depends on DRM_SUN4I_HDMI
diff --git a/drivers/gpu/drm/sun4i/Makefile b/drivers/gpu/drm/sun4i/Makefile
index 492bfd28a..0d04f2447 100644
--- a/drivers/gpu/drm/sun4i/Makefile
+++ b/drivers/gpu/drm/sun4i/Makefile
@@ -5,9 +5,6 @@ sun4i-frontend-y		+= sun4i_frontend.o
 sun4i-drm-y			+= sun4i_drv.o
 sun4i-drm-y			+= sun4i_framebuffer.o
 
-ifdef CONFIG_DRM_SUN4I_HDMI_AUDIO
-sun4i-drm-hdmi-y		+= sun4i_hdmi_audio.o
-endif
 sun4i-drm-hdmi-y		+= sun4i_hdmi_ddc_clk.o
 sun4i-drm-hdmi-y		+= sun4i_hdmi_enc.o
 sun4i-drm-hdmi-y		+= sun4i_hdmi_i2c.o
diff --git a/drivers/gpu/drm/sun4i/sun4i_backend.c b/drivers/gpu/drm/sun4i/sun4i_backend.c
index decd95ad5..f52ff4e6c 100644
--- a/drivers/gpu/drm/sun4i/sun4i_backend.c
+++ b/drivers/gpu/drm/sun4i/sun4i_backend.c
@@ -172,6 +172,14 @@ int sun4i_backend_update_layer_coord(struct sun4i_backend *backend,
 
 	DRM_DEBUG_DRIVER("Updating layer %d\n", layer);
 
+	if (plane->type == DRM_PLANE_TYPE_PRIMARY) {
+		DRM_DEBUG_DRIVER("Primary layer, updating global size W: %u H: %u\n",
+				 state->crtc_w, state->crtc_h);
+		regmap_write(backend->engine.regs, SUN4I_BACKEND_DISSIZE_REG,
+			     SUN4I_BACKEND_DISSIZE(state->crtc_w,
+						   state->crtc_h));
+	}
+
 	/* Set height and width */
 	DRM_DEBUG_DRIVER("Layer size W: %u H: %u\n",
 			 state->crtc_w, state->crtc_h);
@@ -251,6 +259,7 @@ int sun4i_backend_update_layer_formats(struct sun4i_backend *backend,
 {
 	struct drm_plane_state *state = plane->state;
 	struct drm_framebuffer *fb = state->fb;
+	bool interlaced = false;
 	u32 val;
 	int ret;
 
@@ -258,6 +267,17 @@ int sun4i_backend_update_layer_formats(struct sun4i_backend *backend,
 	regmap_update_bits(backend->engine.regs, SUN4I_BACKEND_ATTCTL_REG0(layer),
 			   SUN4I_BACKEND_ATTCTL_REG0_LAY_YUVEN, 0);
 
+	if (plane->state->crtc)
+		interlaced = plane->state->crtc->state->adjusted_mode.flags
+			& DRM_MODE_FLAG_INTERLACE;
+
+	regmap_update_bits(backend->engine.regs, SUN4I_BACKEND_MODCTL_REG,
+			   SUN4I_BACKEND_MODCTL_ITLMOD_EN,
+			   interlaced ? SUN4I_BACKEND_MODCTL_ITLMOD_EN : 0);
+
+	DRM_DEBUG_DRIVER("Switching display backend interlaced mode %s\n",
+			 interlaced ? "on" : "off");
+
 	val = SUN4I_BACKEND_ATTCTL_REG0_LAY_GLBALPHA(state->alpha >> 8);
 	if (state->alpha != DRM_BLEND_ALPHA_OPAQUE)
 		val |= SUN4I_BACKEND_ATTCTL_REG0_LAY_GLBALPHA_EN;
@@ -634,25 +654,6 @@ static void sun4i_backend_vblank_quirk(struct sunxi_engine *engine)
 	spin_unlock(&backend->frontend_lock);
 };
 
-static void sun4i_backend_mode_set(struct sunxi_engine *engine,
-				   const struct drm_display_mode *mode)
-{
-	bool interlaced = !!(mode->flags & DRM_MODE_FLAG_INTERLACE);
-
-	DRM_DEBUG_DRIVER("Updating global size W: %u H: %u\n",
-			 mode->hdisplay, mode->vdisplay);
-
-	regmap_write(engine->regs, SUN4I_BACKEND_DISSIZE_REG,
-		     SUN4I_BACKEND_DISSIZE(mode->hdisplay, mode->vdisplay));
-
-	regmap_update_bits(engine->regs, SUN4I_BACKEND_MODCTL_REG,
-			   SUN4I_BACKEND_MODCTL_ITLMOD_EN,
-			   interlaced ? SUN4I_BACKEND_MODCTL_ITLMOD_EN : 0);
-
-	DRM_DEBUG_DRIVER("Switching display backend interlaced mode %s\n",
-			 interlaced ? "on" : "off");
-}
-
 static int sun4i_backend_init_sat(struct device *dev) {
 	struct sun4i_backend *backend = dev_get_drvdata(dev);
 	int ret;
@@ -764,7 +765,6 @@ static const struct sunxi_engine_ops sun4i_backend_engine_ops = {
 	.apply_color_correction		= sun4i_backend_apply_color_correction,
 	.disable_color_correction	= sun4i_backend_disable_color_correction,
 	.vblank_quirk			= sun4i_backend_vblank_quirk,
-	.mode_set			= sun4i_backend_mode_set,
 };
 
 static const struct regmap_config sun4i_backend_regmap_config = {
diff --git a/drivers/gpu/drm/sun4i/sun4i_crtc.c b/drivers/gpu/drm/sun4i/sun4i_crtc.c
index c30dc95ba..45d9eb552 100644
--- a/drivers/gpu/drm/sun4i/sun4i_crtc.c
+++ b/drivers/gpu/drm/sun4i/sun4i_crtc.c
@@ -103,20 +103,6 @@ static void sun4i_crtc_atomic_flush(struct drm_crtc *crtc,
 			drm_crtc_send_vblank_event(crtc, event);
 		spin_unlock_irq(&crtc->dev->event_lock);
 	}
-
-	if (crtc->state->color_mgmt_changed) {
-		if (crtc->state->gamma_lut) {
-			/* LUT can be only updated when gamma correction is
-			 * disabled
-			 */
-			sun4i_tcon_enable_gamma(scrtc->tcon, false);
-			sun4i_tcon_load_gamma_lut(scrtc->tcon,
-						  crtc->state->gamma_lut->data);
-			sun4i_tcon_enable_gamma(scrtc->tcon, true);
-		} else
-			sun4i_tcon_enable_gamma(scrtc->tcon, false);
-	}
-
 }
 
 static void sun4i_crtc_atomic_disable(struct drm_crtc *crtc,
@@ -160,7 +146,6 @@ static void sun4i_crtc_mode_set_nofb(struct drm_crtc *crtc)
 	struct sun4i_crtc *scrtc = drm_crtc_to_sun4i_crtc(crtc);
 
 	sun4i_tcon_mode_set(scrtc->tcon, encoder, mode);
-	sunxi_engine_mode_set(scrtc->engine, mode);
 }
 
 static const struct drm_crtc_helper_funcs sun4i_crtc_helper_funcs = {
diff --git a/drivers/gpu/drm/sun4i/sun4i_drv.c b/drivers/gpu/drm/sun4i/sun4i_drv.c
index bf373cbfd..6eb1aabdb 100644
--- a/drivers/gpu/drm/sun4i/sun4i_drv.c
+++ b/drivers/gpu/drm/sun4i/sun4i_drv.c
@@ -25,8 +25,6 @@
 #include <drm/drm_probe_helper.h>
 #include <drm/drm_vblank.h>
 
-#include <uapi/drm/sun4i_drm.h>
-
 #include "sun4i_drv.h"
 #include "sun4i_frontend.h"
 #include "sun4i_framebuffer.h"
@@ -45,27 +43,6 @@ static int drm_sun4i_gem_dumb_create(struct drm_file *file_priv,
 
 DEFINE_DRM_GEM_CMA_FOPS(sun4i_drv_fops);
 
-static int sun4i_gem_create_ioctl(struct drm_device *drm, void *data,
-				  struct drm_file *file_priv)
-{
-	struct drm_sun4i_gem_create *args = data;
-	struct drm_gem_cma_object *cma_obj;
-	size_t size;
-
-	/* The Mali requires a 64 bytes alignment */
-	size = ALIGN(args->size, 64);
-
-	cma_obj = drm_gem_cma_create_with_handle(file_priv, drm, size,
-						 &args->handle);
-
-	return PTR_ERR_OR_ZERO(cma_obj);
-}
-
-static const struct drm_ioctl_desc sun4i_drv_ioctls[] = {
-	DRM_IOCTL_DEF_DRV(SUN4I_GEM_CREATE, sun4i_gem_create_ioctl,
-			  DRM_UNLOCKED | DRM_AUTH),
-};
-
 static const struct drm_driver sun4i_drv_driver = {
 	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
 
@@ -77,10 +54,6 @@ static const struct drm_driver sun4i_drv_driver = {
 	.major			= 1,
 	.minor			= 0,
 
-	/* Custom ioctls */
-	.ioctls			= sun4i_drv_ioctls,
-	.num_ioctls		= ARRAY_SIZE(sun4i_drv_ioctls),
-
 	/* GEM Operations */
 	DRM_GEM_CMA_DRIVER_OPS_WITH_DUMB_CREATE(drm_sun4i_gem_dumb_create),
 };
diff --git a/drivers/gpu/drm/sun4i/sun4i_hdmi.h b/drivers/gpu/drm/sun4i/sun4i_hdmi.h
index 2edced4eb..00ca35f07 100644
--- a/drivers/gpu/drm/sun4i/sun4i_hdmi.h
+++ b/drivers/gpu/drm/sun4i/sun4i_hdmi.h
@@ -42,32 +42,7 @@
 #define SUN4I_HDMI_VID_TIMING_POL_VSYNC		BIT(1)
 #define SUN4I_HDMI_VID_TIMING_POL_HSYNC		BIT(0)
 
-#define SUN4I_HDMI_AUDIO_CTRL_REG	0x040
-#define SUN4I_HDMI_AUDIO_CTRL_ENABLE		BIT(31)
-#define SUN4I_HDMI_AUDIO_CTRL_RESET		BIT(30)
-
-#define SUN4I_HDMI_AUDIO_FMT_REG	0x048
-#define SUN4I_HDMI_AUDIO_FMT_SRC		BIT(31)
-#define SUN4I_HDMI_AUDIO_FMT_LAYOUT		BIT(3)
-#define SUN4I_HDMI_AUDIO_FMT_CH_CFG(n)		((n) - 1)
-#define SUN4I_HDMI_AUDIO_FMT_CH_CFG_MASK	GENMASK(2, 0)
-
-#define SUN4I_HDMI_AUDIO_PCM_REG	0x4c
-#define SUN4I_HDMI_AUDIO_PCM_CH_MAP(n, m)	(((m) - 1) << ((n) * 4))
-#define SUN4I_HDMI_AUDIO_PCM_CH_MAP_MASK(n)	(GENMASK(2, 0) << ((n) * 4))
-
-#define SUN4I_HDMI_AUDIO_CTS_REG	0x050
-#define SUN4I_HDMI_AUDIO_CTS(n)			((n) & GENMASK(19, 0))
-
-#define SUN4I_HDMI_AUDIO_N_REG		0x054
-#define SUN4I_HDMI_AUDIO_N(n)			((n) & GENMASK(19, 0))
-
-#define SUN4I_HDMI_AUDIO_STAT0_REG	0x58
-#define SUN4I_HDMI_AUDIO_STAT0_FREQ(n)		((n) << 24)
-#define SUN4I_HDMI_AUDIO_STAT0_FREQ_MASK	GENMASK(27, 24)
-
 #define SUN4I_HDMI_AVI_INFOFRAME_REG(n)	(0x080 + (n))
-#define SUN4I_HDMI_AUDIO_INFOFRAME_REG(n)	(0x0a0 + (n))
 
 #define SUN4I_HDMI_PAD_CTRL0_REG	0x200
 #define SUN4I_HDMI_PAD_CTRL0_BIASEN		BIT(31)
@@ -267,11 +242,6 @@ struct sun4i_hdmi_variant {
 	bool			ddc_fifo_has_dir;
 };
 
-struct sun4i_hdmi_audio {
-	struct snd_soc_card		*card;
-	u8				channels;
-};
-
 struct sun4i_hdmi {
 	struct drm_connector	connector;
 	struct drm_encoder	encoder;
@@ -315,10 +285,7 @@ struct sun4i_hdmi {
 
 	struct sun4i_drv	*drv;
 
-	bool			hdmi_audio;
-
-	struct sun4i_hdmi_audio audio;
-
+	bool			hdmi_monitor;
 	struct cec_adapter	*cec_adap;
 
 	const struct sun4i_hdmi_variant	*variant;
@@ -327,7 +294,5 @@ struct sun4i_hdmi {
 int sun4i_ddc_create(struct sun4i_hdmi *hdmi, struct clk *clk);
 int sun4i_tmds_create(struct sun4i_hdmi *hdmi);
 int sun4i_hdmi_i2c_create(struct device *dev, struct sun4i_hdmi *hdmi);
-int sun4i_hdmi_audio_create(struct sun4i_hdmi *hdmi);
-void sun4i_hdmi_audio_destroy(struct sun4i_hdmi *hdmi);
 
 #endif /* _SUN4I_HDMI_H_ */
diff --git a/drivers/gpu/drm/sun4i/sun4i_hdmi_audio.c b/drivers/gpu/drm/sun4i/sun4i_hdmi_audio.c
deleted file mode 100644
index 2ac967bfd..000000000
--- a/drivers/gpu/drm/sun4i/sun4i_hdmi_audio.c
+++ /dev/null
@@ -1,450 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * Copyright (C) 2020 Olimex Ltd.
- *   Author: Stefan Mavrodiev <stefan@olimex.com>
- */
-#include <linux/dma-mapping.h>
-#include <linux/dmaengine.h>
-#include <linux/module.h>
-#include <linux/of_dma.h>
-#include <linux/regmap.h>
-
-#include <drm/drm_print.h>
-
-#include <sound/dmaengine_pcm.h>
-#include <sound/pcm_drm_eld.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-
-#include "sun4i_hdmi.h"
-
-static int sun4i_hdmi_audio_ctl_eld_info(struct snd_kcontrol *kcontrol,
-					 struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
-	uinfo->count = MAX_ELD_BYTES;
-	return 0;
-}
-
-static int sun4i_hdmi_audio_ctl_eld_get(struct snd_kcontrol *kcontrol,
-					struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct snd_soc_card *card = snd_soc_component_get_drvdata(component);
-	struct sun4i_hdmi *hdmi = snd_soc_card_get_drvdata(card);
-
-	memcpy(ucontrol->value.bytes.data,
-	       hdmi->connector.eld,
-	       MAX_ELD_BYTES);
-
-	return 0;
-}
-
-static const struct snd_kcontrol_new sun4i_hdmi_audio_controls[] = {
-	{
-		.access = SNDRV_CTL_ELEM_ACCESS_READ |
-			  SNDRV_CTL_ELEM_ACCESS_VOLATILE,
-		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
-		.name = "ELD",
-		.info = sun4i_hdmi_audio_ctl_eld_info,
-		.get = sun4i_hdmi_audio_ctl_eld_get,
-	},
-};
-
-static const struct snd_soc_dapm_widget sun4i_hdmi_audio_widgets[] = {
-	SND_SOC_DAPM_OUTPUT("TX"),
-};
-
-static const struct snd_soc_dapm_route sun4i_hdmi_audio_routes[] = {
-	{ "TX", NULL, "Playback" },
-};
-
-static const struct snd_soc_component_driver sun4i_hdmi_audio_component = {
-	.controls               = sun4i_hdmi_audio_controls,
-	.num_controls           = ARRAY_SIZE(sun4i_hdmi_audio_controls),
-	.dapm_widgets		= sun4i_hdmi_audio_widgets,
-	.num_dapm_widgets	= ARRAY_SIZE(sun4i_hdmi_audio_widgets),
-	.dapm_routes		= sun4i_hdmi_audio_routes,
-	.num_dapm_routes	= ARRAY_SIZE(sun4i_hdmi_audio_routes),
-};
-
-static int sun4i_hdmi_audio_startup(struct snd_pcm_substream *substream,
-				    struct snd_soc_dai *dai)
-{
-	struct snd_soc_card *card = snd_soc_dai_get_drvdata(dai);
-	struct sun4i_hdmi *hdmi = snd_soc_card_get_drvdata(card);
-	u32 reg;
-	int ret;
-
-	regmap_write(hdmi->regmap, SUN4I_HDMI_AUDIO_CTRL_REG, 0);
-	regmap_write(hdmi->regmap,
-		     SUN4I_HDMI_AUDIO_CTRL_REG,
-		     SUN4I_HDMI_AUDIO_CTRL_RESET);
-	ret = regmap_read_poll_timeout(hdmi->regmap,
-				       SUN4I_HDMI_AUDIO_CTRL_REG,
-				       reg, !reg, 100, 50000);
-	if (ret < 0) {
-		DRM_ERROR("Failed to reset HDMI Audio\n");
-		return ret;
-	}
-
-	regmap_write(hdmi->regmap,
-		     SUN4I_HDMI_AUDIO_CTRL_REG,
-		     SUN4I_HDMI_AUDIO_CTRL_ENABLE);
-
-	return snd_pcm_hw_constraint_eld(substream->runtime,
-					hdmi->connector.eld);
-}
-
-static void sun4i_hdmi_audio_shutdown(struct snd_pcm_substream *substream,
-				      struct snd_soc_dai *dai)
-{
-	struct snd_soc_card *card = snd_soc_dai_get_drvdata(dai);
-	struct sun4i_hdmi *hdmi = snd_soc_card_get_drvdata(card);
-
-	regmap_write(hdmi->regmap, SUN4I_HDMI_AUDIO_CTRL_REG, 0);
-}
-
-static int sun4i_hdmi_setup_audio_infoframes(struct sun4i_hdmi *hdmi)
-{
-	union hdmi_infoframe frame;
-	u8 buffer[14];
-	int i, ret;
-
-	ret = hdmi_audio_infoframe_init(&frame.audio);
-	if (ret < 0) {
-		DRM_ERROR("Failed to init HDMI audio infoframe\n");
-		return ret;
-	}
-
-	frame.audio.coding_type = HDMI_AUDIO_CODING_TYPE_STREAM;
-	frame.audio.sample_frequency = HDMI_AUDIO_SAMPLE_FREQUENCY_STREAM;
-	frame.audio.sample_size = HDMI_AUDIO_SAMPLE_SIZE_STREAM;
-	frame.audio.channels = hdmi->audio.channels;
-
-	ret = hdmi_infoframe_pack(&frame, buffer, sizeof(buffer));
-	if (ret < 0) {
-		DRM_ERROR("Failed to pack HDMI audio infoframe\n");
-		return ret;
-	}
-
-	for (i = 0; i < sizeof(buffer); i++)
-		writeb(buffer[i],
-		       hdmi->base + SUN4I_HDMI_AUDIO_INFOFRAME_REG(i));
-
-	return 0;
-}
-
-static void sun4i_hdmi_audio_set_cts_n(struct sun4i_hdmi *hdmi,
-				       struct snd_pcm_hw_params *params)
-{
-	struct drm_encoder *encoder = &hdmi->encoder;
-	struct drm_crtc *crtc = encoder->crtc;
-	const struct drm_display_mode *mode = &crtc->state->adjusted_mode;
-	u32 rate = params_rate(params);
-	u32 n, cts;
-	u64 tmp;
-
-	/**
-	 * Calculate Cycle Time Stamp (CTS) and Numerator (N):
-	 *
-	 * N = 128 * Samplerate / 1000
-	 * CTS = (Ftdms * N) / (128 * Samplerate)
-	 */
-
-	n = 128 * rate / 1000;
-	tmp = (u64)(mode->clock * 1000) * n;
-	do_div(tmp, 128 * rate);
-	cts = tmp;
-
-	regmap_write(hdmi->regmap,
-		     SUN4I_HDMI_AUDIO_CTS_REG,
-		     SUN4I_HDMI_AUDIO_CTS(cts));
-
-	regmap_write(hdmi->regmap,
-		     SUN4I_HDMI_AUDIO_N_REG,
-		     SUN4I_HDMI_AUDIO_N(n));
-}
-
-static int sun4i_hdmi_audio_set_hw_rate(struct sun4i_hdmi *hdmi,
-					struct snd_pcm_hw_params *params)
-{
-	u32 rate = params_rate(params);
-	u32 val;
-
-	switch (rate) {
-	case 44100:
-		val = 0x0;
-		break;
-	case 48000:
-		val = 0x2;
-		break;
-	case 32000:
-		val = 0x3;
-		break;
-	case 88200:
-		val = 0x8;
-		break;
-	case 96000:
-		val = 0x9;
-		break;
-	case 176400:
-		val = 0xc;
-		break;
-	case 192000:
-		val = 0xe;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	regmap_update_bits(hdmi->regmap,
-			   SUN4I_HDMI_AUDIO_STAT0_REG,
-			   SUN4I_HDMI_AUDIO_STAT0_FREQ_MASK,
-			   SUN4I_HDMI_AUDIO_STAT0_FREQ(val));
-
-	return 0;
-}
-
-static int sun4i_hdmi_audio_set_hw_channels(struct sun4i_hdmi *hdmi,
-					    struct snd_pcm_hw_params *params)
-{
-	u32 channels = params_channels(params);
-
-	if (channels > 8)
-		return -EINVAL;
-
-	hdmi->audio.channels = channels;
-
-	regmap_update_bits(hdmi->regmap,
-			   SUN4I_HDMI_AUDIO_FMT_REG,
-			   SUN4I_HDMI_AUDIO_FMT_LAYOUT,
-			   (channels > 2) ? SUN4I_HDMI_AUDIO_FMT_LAYOUT : 0);
-
-	regmap_update_bits(hdmi->regmap,
-			   SUN4I_HDMI_AUDIO_FMT_REG,
-			   SUN4I_HDMI_AUDIO_FMT_CH_CFG_MASK,
-			   SUN4I_HDMI_AUDIO_FMT_CH_CFG(channels));
-
-	regmap_write(hdmi->regmap, SUN4I_HDMI_AUDIO_PCM_REG, 0x76543210);
-
-	/**
-	 * If only one channel is required, send the same sample
-	 * to the sink device as a left and right channel.
-	 */
-	if (channels == 1)
-		regmap_update_bits(hdmi->regmap,
-				   SUN4I_HDMI_AUDIO_PCM_REG,
-				   SUN4I_HDMI_AUDIO_PCM_CH_MAP_MASK(1),
-				   SUN4I_HDMI_AUDIO_PCM_CH_MAP(1, 1));
-
-	return 0;
-}
-
-static int sun4i_hdmi_audio_hw_params(struct snd_pcm_substream *substream,
-				      struct snd_pcm_hw_params *params,
-				      struct snd_soc_dai *dai)
-{
-	struct snd_soc_card *card = snd_soc_dai_get_drvdata(dai);
-	struct sun4i_hdmi *hdmi = snd_soc_card_get_drvdata(card);
-	int ret;
-
-	ret = sun4i_hdmi_audio_set_hw_rate(hdmi, params);
-	if (ret < 0)
-		return ret;
-
-	ret = sun4i_hdmi_audio_set_hw_channels(hdmi, params);
-	if (ret < 0)
-		return ret;
-
-	sun4i_hdmi_audio_set_cts_n(hdmi, params);
-
-	return 0;
-}
-
-static int sun4i_hdmi_audio_trigger(struct snd_pcm_substream *substream,
-				    int cmd,
-				    struct snd_soc_dai *dai)
-{
-	struct snd_soc_card *card = snd_soc_dai_get_drvdata(dai);
-	struct sun4i_hdmi *hdmi = snd_soc_card_get_drvdata(card);
-	int ret = 0;
-
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-		ret = sun4i_hdmi_setup_audio_infoframes(hdmi);
-		break;
-	default:
-		break;
-	}
-
-	return ret;
-}
-
-static const struct snd_soc_dai_ops sun4i_hdmi_audio_dai_ops = {
-	.startup = sun4i_hdmi_audio_startup,
-	.shutdown = sun4i_hdmi_audio_shutdown,
-	.hw_params = sun4i_hdmi_audio_hw_params,
-	.trigger = sun4i_hdmi_audio_trigger,
-};
-
-static int sun4i_hdmi_audio_dai_probe(struct snd_soc_dai *dai)
-{
-	struct snd_dmaengine_dai_dma_data *dma_data;
-
-	dma_data = devm_kzalloc(dai->dev, sizeof(*dma_data), GFP_KERNEL);
-	if (!dma_data)
-		return -ENOMEM;
-
-	dma_data->addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-	dma_data->maxburst = 8;
-
-	snd_soc_dai_init_dma_data(dai, dma_data, NULL);
-
-	return 0;
-}
-
-static struct snd_soc_dai_driver sun4i_hdmi_audio_dai = {
-	.name = "HDMI",
-	.ops = &sun4i_hdmi_audio_dai_ops,
-	.probe = sun4i_hdmi_audio_dai_probe,
-	.playback = {
-		.stream_name	= "Playback",
-		.channels_min	= 1,
-		.channels_max	= 8,
-		.formats	= SNDRV_PCM_FMTBIT_S16_LE,
-		.rates		= SNDRV_PCM_RATE_8000_192000,
-	},
-};
-
-static const struct snd_pcm_hardware sun4i_hdmi_audio_pcm_hardware = {
-	.info			= SNDRV_PCM_INFO_INTERLEAVED |
-				  SNDRV_PCM_INFO_BLOCK_TRANSFER |
-				  SNDRV_PCM_INFO_MMAP |
-				  SNDRV_PCM_INFO_MMAP_VALID |
-				  SNDRV_PCM_INFO_PAUSE |
-				  SNDRV_PCM_INFO_RESUME,
-	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
-	.rates                  = SNDRV_PCM_RATE_8000_192000,
-	.rate_min               = 8000,
-	.rate_max               = 192000,
-	.channels_min           = 1,
-	.channels_max           = 8,
-	.buffer_bytes_max	= 128 * 1024,
-	.period_bytes_min	= 4 * 1024,
-	.period_bytes_max	= 32 * 1024,
-	.periods_min		= 2,
-	.periods_max		= 8,
-	.fifo_size		= 128,
-};
-
-static const struct snd_dmaengine_pcm_config sun4i_hdmi_audio_pcm_config = {
-	.chan_names[SNDRV_PCM_STREAM_PLAYBACK] = "audio-tx",
-	.pcm_hardware = &sun4i_hdmi_audio_pcm_hardware,
-	.prealloc_buffer_size = 128 * 1024,
-	.prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config,
-};
-
-struct snd_soc_card sun4i_hdmi_audio_card = {
-	.name = "sun4i-hdmi",
-};
-
-int sun4i_hdmi_audio_create(struct sun4i_hdmi *hdmi)
-{
-	struct snd_soc_card *card = &sun4i_hdmi_audio_card;
-	struct snd_soc_dai_link_component *comp;
-	struct snd_soc_dai_link *link;
-	int ret;
-
-	ret = snd_dmaengine_pcm_register(hdmi->dev,
-					 &sun4i_hdmi_audio_pcm_config, 0);
-	if (ret < 0) {
-		DRM_ERROR("Could not register PCM\n");
-		return ret;
-	}
-
-	ret = snd_soc_register_component(hdmi->dev,
-					 &sun4i_hdmi_audio_component,
-					 &sun4i_hdmi_audio_dai, 1);
-	if (ret < 0) {
-		DRM_ERROR("Could not register DAI\n");
-		goto unregister_pcm;
-	}
-
-	link = devm_kzalloc(hdmi->dev, sizeof(*link), GFP_KERNEL);
-	if (!link) {
-		ret = -ENOMEM;
-		goto unregister_component;
-	}
-
-	comp = devm_kzalloc(hdmi->dev, sizeof(*comp) * 3, GFP_KERNEL);
-	if (!comp) {
-		ret = -ENOMEM;
-		goto unregister_component;
-	}
-
-	link->cpus = &comp[0];
-	link->codecs = &comp[1];
-	link->platforms = &comp[2];
-
-	link->num_cpus = 1;
-	link->num_codecs = 1;
-	link->num_platforms = 1;
-
-	link->playback_only = 1;
-
-	link->name = "SUN4I-HDMI";
-	link->stream_name = "SUN4I-HDMI PCM";
-
-	link->codecs->name = dev_name(hdmi->dev);
-	link->codecs->dai_name	= sun4i_hdmi_audio_dai.name;
-
-	link->cpus->dai_name = dev_name(hdmi->dev);
-
-	link->platforms->name = dev_name(hdmi->dev);
-
-	link->dai_fmt = SND_SOC_DAIFMT_I2S;
-
-	card->dai_link = link;
-	card->num_links = 1;
-	card->dev = hdmi->dev;
-
-	hdmi->audio.card = card;
-
-	/**
-	 * snd_soc_register_card() will overwrite the driver_data pointer.
-	 * So before registering the card, store the original pointer in
-	 * card->drvdata.
-	 */
-	snd_soc_card_set_drvdata(card, hdmi);
-	ret = snd_soc_register_card(card);
-	if (ret)
-		goto unregister_component;
-
-	return 0;
-
-unregister_component:
-	snd_soc_unregister_component(hdmi->dev);
-unregister_pcm:
-	snd_dmaengine_pcm_unregister(hdmi->dev);
-	return ret;
-}
-
-void sun4i_hdmi_audio_destroy(struct sun4i_hdmi *hdmi)
-{
-	struct snd_soc_card *card = hdmi->audio.card;
-	void *data;
-
-	/**
-	 * Before removing the card, restore the previously stored driver_data.
-	 * This will ensure proper removal of the sun4i-hdmi module, since it
-	 * uses dev_get_drvdata() in the unbind function.
-	 */
-	data = snd_soc_card_get_drvdata(card);
-
-	snd_soc_unregister_card(card);
-	snd_soc_unregister_component(hdmi->dev);
-	snd_dmaengine_pcm_unregister(hdmi->dev);
-
-	dev_set_drvdata(hdmi->dev, data);
-}
diff --git a/drivers/gpu/drm/sun4i/sun4i_hdmi_enc.c b/drivers/gpu/drm/sun4i/sun4i_hdmi_enc.c
index 074b6968d..3799a745b 100644
--- a/drivers/gpu/drm/sun4i/sun4i_hdmi_enc.c
+++ b/drivers/gpu/drm/sun4i/sun4i_hdmi_enc.c
@@ -24,8 +24,6 @@
 #include <drm/drm_probe_helper.h>
 #include <drm/drm_simple_kms_helper.h>
 
-#include <sound/soc.h>
-
 #include "sun4i_backend.h"
 #include "sun4i_crtc.h"
 #include "sun4i_drv.h"
@@ -90,11 +88,6 @@ static void sun4i_hdmi_disable(struct drm_encoder *encoder)
 
 	DRM_DEBUG_DRIVER("Disabling the HDMI Output\n");
 
-#ifdef CONFIG_DRM_SUN4I_HDMI_AUDIO
-	if (hdmi->hdmi_audio)
-		sun4i_hdmi_audio_destroy(hdmi);
-#endif
-
 	val = readl(hdmi->base + SUN4I_HDMI_VID_CTRL_REG);
 	val &= ~SUN4I_HDMI_VID_CTRL_ENABLE;
 	writel(val, hdmi->base + SUN4I_HDMI_VID_CTRL_REG);
@@ -106,7 +99,6 @@ static void sun4i_hdmi_enable(struct drm_encoder *encoder)
 {
 	struct drm_display_mode *mode = &encoder->crtc->state->adjusted_mode;
 	struct sun4i_hdmi *hdmi = drm_encoder_to_sun4i_hdmi(encoder);
-	struct drm_display_info *display = &hdmi->connector.display_info;
 	u32 val = 0;
 
 	DRM_DEBUG_DRIVER("Enabling the HDMI Output\n");
@@ -119,15 +111,10 @@ static void sun4i_hdmi_enable(struct drm_encoder *encoder)
 	writel(val, hdmi->base + SUN4I_HDMI_PKT_CTRL_REG(0));
 
 	val = SUN4I_HDMI_VID_CTRL_ENABLE;
-	if (display->is_hdmi)
+	if (hdmi->hdmi_monitor)
 		val |= SUN4I_HDMI_VID_CTRL_HDMI_MODE;
 
 	writel(val, hdmi->base + SUN4I_HDMI_VID_CTRL_REG);
-
-#ifdef CONFIG_DRM_SUN4I_HDMI_AUDIO
-	if (hdmi->hdmi_audio && sun4i_hdmi_audio_create(hdmi))
-		DRM_ERROR("Couldn't create the HDMI audio adapter\n");
-#endif
 }
 
 static void sun4i_hdmi_mode_set(struct drm_encoder *encoder,
@@ -228,12 +215,9 @@ static int sun4i_hdmi_get_modes(struct drm_connector *connector)
 	if (!edid)
 		return 0;
 
-#ifdef CONFIG_DRM_SUN4I_HDMI_AUDIO
-	hdmi->hdmi_audio = drm_detect_monitor_audio(edid);
-#endif
-
+	hdmi->hdmi_monitor = drm_detect_hdmi_monitor(edid);
 	DRM_DEBUG_DRIVER("Monitor is %s monitor\n",
-			 connector->display_info.is_hdmi ? "an HDMI" : "a DVI");
+			 hdmi->hdmi_monitor ? "an HDMI" : "a DVI");
 
 	drm_connector_update_edid_property(connector, edid);
 	cec_s_phys_addr_from_edid(hdmi->cec_adap, edid);
diff --git a/drivers/gpu/drm/sun4i/sun4i_tcon.c b/drivers/gpu/drm/sun4i/sun4i_tcon.c
index 9d9721949..f4fff1c11 100644
--- a/drivers/gpu/drm/sun4i/sun4i_tcon.c
+++ b/drivers/gpu/drm/sun4i/sun4i_tcon.c
@@ -39,8 +39,6 @@
 #include "sun8i_tcon_top.h"
 #include "sunxi_engine.h"
 
-static bool hw_preconfigured;
-
 static struct drm_connector *sun4i_tcon_get_connector(const struct drm_encoder *encoder)
 {
 	struct drm_connector *connector;
@@ -109,11 +107,9 @@ static void sun4i_tcon_channel_set_status(struct sun4i_tcon *tcon, int channel,
 
 	if (enabled) {
 		clk_prepare_enable(clk);
-		if (!tcon->quirks->clk_kept_by_ccu)
-			clk_rate_exclusive_get(clk);
+		clk_rate_exclusive_get(clk);
 	} else {
-		if (!tcon->quirks->clk_kept_by_ccu)
-			clk_rate_exclusive_put(clk);
+		clk_rate_exclusive_put(clk);
 		clk_disable_unprepare(clk);
 	}
 }
@@ -243,34 +239,6 @@ void sun4i_tcon_enable_vblank(struct sun4i_tcon *tcon, bool enable)
 }
 EXPORT_SYMBOL(sun4i_tcon_enable_vblank);
 
-void sun4i_tcon_load_gamma_lut(struct sun4i_tcon *tcon,
-			       struct drm_color_lut *lut)
-{
-	int i;
-
-	for (i = 0; i < SUN4I_TCON_GAMMA_LUT_SIZE; i++) {
-		u32 r, g, b;
-
-		r = drm_color_lut_extract(lut[i].red, 8);
-		g = drm_color_lut_extract(lut[i].green, 8);
-		b = drm_color_lut_extract(lut[i].blue, 8);
-
-		regmap_write(tcon->regs, SUN4I_TCON_GAMMA_TABLE_REG + 4 * i,
-			     SUN4I_TCON_GAMMA_TABLE_R(r) |
-			     SUN4I_TCON_GAMMA_TABLE_G(g) |
-			     SUN4I_TCON_GAMMA_TABLE_B(b));
-	}
-}
-EXPORT_SYMBOL(sun4i_tcon_load_gamma_lut);
-
-void sun4i_tcon_enable_gamma(struct sun4i_tcon *tcon, bool enable)
-{
-	regmap_update_bits(tcon->regs, SUN4I_TCON_GCTL_REG,
-			   SUN4I_TCON_GCTL_GAMMA_ENABLE,
-			   enable ? SUN4I_TCON_GCTL_GAMMA_ENABLE : 0);
-}
-EXPORT_SYMBOL(sun4i_tcon_enable_gamma);
-
 /*
  * This function is a helper for TCON output muxing. The TCON output
  * muxing control register in earlier SoCs (without the TCON TOP block)
@@ -322,6 +290,18 @@ static int sun4i_tcon_get_clk_delay(const struct drm_display_mode *mode,
 	return delay;
 }
 
+static void sun4i_tcon0_mode_set_common(struct sun4i_tcon *tcon,
+					const struct drm_display_mode *mode)
+{
+	/* Configure the dot clock */
+	clk_set_rate(tcon->dclk, mode->crtc_clock * 1000);
+
+	/* Set the resolution */
+	regmap_write(tcon->regs, SUN4I_TCON0_BASIC0_REG,
+		     SUN4I_TCON0_BASIC0_X(mode->crtc_hdisplay) |
+		     SUN4I_TCON0_BASIC0_Y(mode->crtc_vdisplay));
+}
+
 static void sun4i_tcon0_mode_set_dithering(struct sun4i_tcon *tcon,
 					   const struct drm_connector *connector)
 {
@@ -384,18 +364,12 @@ static void sun4i_tcon0_mode_set_cpu(struct sun4i_tcon *tcon,
 	u8 bpp = mipi_dsi_pixel_format_to_bpp(device->format);
 	u8 lanes = device->lanes;
 	u32 block_space, start_delay;
+	u32 tcon_div;
 
 	tcon->dclk_min_div = SUN6I_DSI_TCON_DIV;
 	tcon->dclk_max_div = SUN6I_DSI_TCON_DIV;
 
-	/* Configure the dot clock */
-	clk_set_rate(tcon->dclk, mode->crtc_clock * 1000
-				 * bpp / (lanes * SUN6I_DSI_TCON_DIV));
-
-        /* Set the resolution */
-	regmap_write(tcon->regs, SUN4I_TCON0_BASIC0_REG,
-		     SUN4I_TCON0_BASIC0_X(mode->crtc_hdisplay) |
-		     SUN4I_TCON0_BASIC0_Y(mode->crtc_vdisplay));
+	sun4i_tcon0_mode_set_common(tcon, mode);
 
 	/* Set dithering if needed */
 	sun4i_tcon0_mode_set_dithering(tcon, sun4i_tcon_get_connector(encoder));
@@ -419,7 +393,9 @@ static void sun4i_tcon0_mode_set_cpu(struct sun4i_tcon *tcon,
 	 * The datasheet says that this should be set higher than 20 *
 	 * pixel cycle, but it's not clear what a pixel cycle is.
 	 */
-	block_space = mode->htotal * bpp / (SUN6I_DSI_TCON_DIV * lanes);
+	regmap_read(tcon->regs, SUN4I_TCON0_DCLK_REG, &tcon_div);
+	tcon_div &= GENMASK(6, 0);
+	block_space = mode->htotal * bpp / (tcon_div * lanes);
 	block_space -= mode->hdisplay + 40;
 
 	regmap_write(tcon->regs, SUN4I_TCON0_CPU_TRI0_REG,
@@ -461,14 +437,7 @@ static void sun4i_tcon0_mode_set_lvds(struct sun4i_tcon *tcon,
 
 	tcon->dclk_min_div = 7;
 	tcon->dclk_max_div = 7;
-
-	/* Configure the dot clock */
-	clk_set_rate(tcon->dclk, mode->crtc_clock * 1000);
-
-        /* Set the resolution */
-	regmap_write(tcon->regs, SUN4I_TCON0_BASIC0_REG,
-		     SUN4I_TCON0_BASIC0_X(mode->crtc_hdisplay) |
-		     SUN4I_TCON0_BASIC0_Y(mode->crtc_vdisplay));
+	sun4i_tcon0_mode_set_common(tcon, mode);
 
 	/* Set dithering if needed */
 	sun4i_tcon0_mode_set_dithering(tcon, sun4i_tcon_get_connector(encoder));
@@ -505,9 +474,7 @@ static void sun4i_tcon0_mode_set_lvds(struct sun4i_tcon *tcon,
 		     SUN4I_TCON0_BASIC2_V_TOTAL(mode->crtc_vtotal * 2) |
 		     SUN4I_TCON0_BASIC2_V_BACKPORCH(bp));
 
-	reg = SUN4I_TCON0_LVDS_IF_CLK_SEL_TCON0 |
-		SUN4I_TCON0_LVDS_IF_DATA_POL_NORMAL |
-		SUN4I_TCON0_LVDS_IF_CLK_POL_NORMAL;
+	reg = SUN4I_TCON0_LVDS_IF_CLK_SEL_TCON0;
 	if (sun4i_tcon_get_pixel_depth(encoder) == 24)
 		reg |= SUN4I_TCON0_LVDS_IF_BITWIDTH_24BITS;
 	else
@@ -547,14 +514,7 @@ static void sun4i_tcon0_mode_set_rgb(struct sun4i_tcon *tcon,
 
 	tcon->dclk_min_div = tcon->quirks->dclk_min_div;
 	tcon->dclk_max_div = 127;
-
-	/* Configure the dot clock */
-	clk_set_rate(tcon->dclk, mode->crtc_clock * 1000);
-
-	/* Set the resolution */
-	regmap_write(tcon->regs, SUN4I_TCON0_BASIC0_REG,
-		     SUN4I_TCON0_BASIC0_X(mode->crtc_hdisplay) |
-		     SUN4I_TCON0_BASIC0_Y(mode->crtc_vdisplay));
+	sun4i_tcon0_mode_set_common(tcon, mode);
 
 	/* Set dithering if needed */
 	sun4i_tcon0_mode_set_dithering(tcon, connector);
@@ -746,13 +706,6 @@ void sun4i_tcon_mode_set(struct sun4i_tcon *tcon,
 			 const struct drm_encoder *encoder,
 			 const struct drm_display_mode *mode)
 {
-	if (tcon->hw_preconfigured) {
-		// avoid the first modeset
-		tcon->hw_preconfigured = false;
-		hw_preconfigured = false;
-		return;
-	}
-
 	switch (encoder->encoder_type) {
 	case DRM_MODE_ENCODER_DSI:
 		/* DSI is tied to special case of CPU interface */
@@ -837,8 +790,8 @@ static int sun4i_tcon_init_clocks(struct device *dev,
 			dev_err(dev, "Couldn't get the TCON channel 0 clock\n");
 			return PTR_ERR(tcon->sclk0);
 		}
-		clk_prepare_enable(tcon->sclk0);
 	}
+	clk_prepare_enable(tcon->sclk0);
 
 	if (tcon->quirks->has_channel_1) {
 		tcon->sclk1 = devm_clk_get(dev, "tcon-ch1");
@@ -901,7 +854,6 @@ static int sun4i_tcon_init_regmap(struct device *dev,
 		return PTR_ERR(tcon->regs);
 	}
 
-	if (!tcon->hw_preconfigured) {
 	/* Make sure the TCON is disabled and all IRQs are off */
 	regmap_write(tcon->regs, SUN4I_TCON_GCTL_REG, 0);
 	regmap_write(tcon->regs, SUN4I_TCON_GINT0_REG, 0);
@@ -910,7 +862,6 @@ static int sun4i_tcon_init_regmap(struct device *dev,
 	/* Disable IO lines and set them to tristate */
 	regmap_write(tcon->regs, SUN4I_TCON0_IO_TRI_REG, ~0);
 	regmap_write(tcon->regs, SUN4I_TCON1_IO_TRI_REG, ~0);
-	}
 
 	return 0;
 }
@@ -1182,9 +1133,6 @@ static int sun4i_tcon_bind(struct device *dev, struct device *master,
 	tcon->dev = dev;
 	tcon->id = engine->id;
 	tcon->quirks = of_device_get_match_data(dev);
-	
-	if (tcon->id == 0)
-		tcon->hw_preconfigured = hw_preconfigured;
 
 	tcon->lcd_rst = devm_reset_control_get(dev, "lcd");
 	if (IS_ERR(tcon->lcd_rst)) {
@@ -1206,14 +1154,12 @@ static int sun4i_tcon_bind(struct device *dev, struct device *master,
 		}
 	}
 
-	if (!tcon->hw_preconfigured) {
 	/* Make sure our TCON is reset */
 	ret = reset_control_reset(tcon->lcd_rst);
 	if (ret) {
 		dev_err(dev, "Couldn't deassert our reset line\n");
 		return ret;
 	}
-	}
 
 	if (tcon->quirks->supports_lvds) {
 		/*
@@ -1320,6 +1266,10 @@ static int sun4i_tcon_bind(struct device *dev, struct device *master,
 			goto err_free_dotclock;
 	}
 
+	regmap_update_bits(tcon->regs, SUN4I_TCON_GCTL_REG,
+			   SUN4I_TCON_GCTL_PAD_SEL,
+			   SUN4I_TCON_GCTL_PAD_SEL);
+
 	if (tcon->quirks->needs_de_be_mux) {
 		/*
 		 * We assume there is no dynamic muxing of backends
@@ -1341,11 +1291,6 @@ static int sun4i_tcon_bind(struct device *dev, struct device *master,
 
 	list_add_tail(&tcon->list, &drv->tcon_list);
 
-	drm_mode_crtc_set_gamma_size(&tcon->crtc->crtc,
-				     SUN4I_TCON_GAMMA_LUT_SIZE);
-	drm_crtc_enable_color_mgmt(&tcon->crtc->crtc, 0, false,
-				   tcon->crtc->crtc.gamma_size);
-
 	return 0;
 
 err_free_dotclock:
@@ -1380,15 +1325,8 @@ static int sun4i_tcon_probe(struct platform_device *pdev)
 	const struct sun4i_tcon_quirks *quirks;
 	struct drm_bridge *bridge;
 	struct drm_panel *panel;
-	u32 fb_start;
 	int ret;
 
-	ret = of_property_read_u32_index(of_chosen, "p-boot,framebuffer-start", 0, &fb_start);
-	if (ret == 0) {
-		/* the display pipeline is already initialized by p-boot */
-		hw_preconfigured = true;
-	}
-
 	quirks = of_device_get_match_data(&pdev->dev);
 
 	/* panels and bridges are present only on TCONs with channel 0 */
@@ -1575,14 +1513,6 @@ static const struct sun4i_tcon_quirks sun8i_a33_quirks = {
 	.supports_lvds		= true,
 };
 
-static const struct sun4i_tcon_quirks sun50i_a64_lcd_quirks = {
-	.supports_lvds		= true,
-	.has_channel_0		= true,
-	.clk_kept_by_ccu	= true,
-	.dclk_min_div		= 1,
-	.setup_lvds_phy		= sun6i_tcon_setup_lvds_phy,
-};
-
 static const struct sun4i_tcon_quirks sun8i_a83t_lcd_quirks = {
 	.supports_lvds		= true,
 	.has_channel_0		= true,
@@ -1641,7 +1571,6 @@ const struct of_device_id sun4i_tcon_of_table[] = {
 	{ .compatible = "allwinner,sun9i-a80-tcon-tv", .data = &sun9i_a80_tcon_tv_quirks },
 	{ .compatible = "allwinner,sun20i-d1-tcon-lcd", .data = &sun20i_d1_lcd_quirks },
 	{ .compatible = "allwinner,sun20i-d1-tcon-tv", .data = &sun8i_r40_tv_quirks },
-	{ .compatible = "allwinner,sun50i-a64-tcon-lcd", .data = &sun50i_a64_lcd_quirks },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, sun4i_tcon_of_table);
diff --git a/drivers/gpu/drm/sun4i/sun4i_tcon.h b/drivers/gpu/drm/sun4i/sun4i_tcon.h
index f532d87ea..1165cd901 100644
--- a/drivers/gpu/drm/sun4i/sun4i_tcon.h
+++ b/drivers/gpu/drm/sun4i/sun4i_tcon.h
@@ -18,7 +18,7 @@
 
 #define SUN4I_TCON_GCTL_REG			0x0
 #define SUN4I_TCON_GCTL_TCON_ENABLE			BIT(31)
-#define SUN4I_TCON_GCTL_GAMMA_ENABLE			BIT(30)
+#define SUN4I_TCON_GCTL_PAD_SEL				BIT(1)
 #define SUN4I_TCON_GCTL_IOMAP_MASK			BIT(0)
 #define SUN4I_TCON_GCTL_IOMAP_TCON1			(1 << 0)
 #define SUN4I_TCON_GCTL_IOMAP_TCON0			(0 << 0)
@@ -229,13 +229,7 @@
 #define SUN4I_TCON1_FILL_BEG2_REG		0x31c
 #define SUN4I_TCON1_FILL_END2_REG		0x320
 #define SUN4I_TCON1_FILL_DATA2_REG		0x324
-
-#define SUN4I_TCON_GAMMA_TABLE_REG		0x400
-#define SUN4I_TCON_GAMMA_TABLE_B(x)		((x) & 0xff)
-#define SUN4I_TCON_GAMMA_TABLE_G(x)		(((x) & 0xff) << 8)
-#define SUN4I_TCON_GAMMA_TABLE_R(x)		(((x) & 0xff) << 16)
-
-#define SUN4I_TCON_GAMMA_LUT_SIZE		256
+#define SUN4I_TCON1_GAMMA_TABLE_REG		0x400
 
 #define SUN4I_TCON_MAX_CHANNELS		2
 
@@ -249,7 +243,6 @@ struct sun4i_tcon_quirks {
 	bool    needs_edp_reset; /* a80 edp reset needed for tcon0 access */
 	bool	supports_lvds;   /* Does the TCON support an LVDS output? */
 	bool	polarity_in_ch0; /* some tcon1 channels have polarity bits in tcon0 pol register */
-	bool	clk_kept_by_ccu; /* On A64 we rely on CCU to keep TCON0 clock stable */
 	u8	dclk_min_div;	/* minimum divider for TCON0 DCLK */
 
 	/* callback to handle tcon muxing options */
@@ -293,8 +286,6 @@ struct sun4i_tcon {
 
 	/* TCON list management */
 	struct list_head		list;
-
-	bool hw_preconfigured;
 };
 
 struct drm_bridge *sun4i_tcon_find_bridge(struct device_node *node);
@@ -306,9 +297,6 @@ void sun4i_tcon_mode_set(struct sun4i_tcon *tcon,
 			 const struct drm_display_mode *mode);
 void sun4i_tcon_set_status(struct sun4i_tcon *crtc,
 			   const struct drm_encoder *encoder, bool enable);
-void sun4i_tcon_load_gamma_lut(struct sun4i_tcon *tcon,
-			       struct drm_color_lut *lut);
-void sun4i_tcon_enable_gamma(struct sun4i_tcon *tcon, bool enable);
 
 extern const struct of_device_id sun4i_tcon_of_table[];
 
diff --git a/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.c b/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.c
index df657efd0..34234a144 100644
--- a/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.c
+++ b/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.c
@@ -732,7 +732,6 @@ static void sun6i_dsi_encoder_enable(struct drm_encoder *encoder)
 	reset_control_deassert(dsi->reset);
 	clk_prepare_enable(dsi->mod_clk);
 
-	if (!dsi->hw_preconfigured) {
 	/*
 	 * Enable the DSI block.
 	 */
@@ -759,7 +758,6 @@ static void sun6i_dsi_encoder_enable(struct drm_encoder *encoder)
 	sun6i_dsi_setup_inst_loop(dsi, mode);
 	sun6i_dsi_setup_format(dsi, mode);
 	sun6i_dsi_setup_timings(dsi, mode);
-	}
 
 	phy_init(dsi->dphy);
 
@@ -789,15 +787,11 @@ static void sun6i_dsi_encoder_enable(struct drm_encoder *encoder)
 	if (dsi->panel)
 		drm_panel_enable(dsi->panel);
 
-	if (!dsi->hw_preconfigured) {
 	sun6i_dsi_start(dsi, DSI_START_HSC);
 
 	udelay(1000);
 
 	sun6i_dsi_start(dsi, DSI_START_HSD);
-	}
-
-	dsi->hw_preconfigured = false;
 }
 
 static void sun6i_dsi_encoder_disable(struct drm_encoder *encoder)
@@ -858,7 +852,7 @@ static u32 sun6i_dsi_dcs_build_pkt_hdr(struct sun6i_dsi *dsi,
 {
 	u32 pkt = msg->type;
 
-	if (msg->type == MIPI_DSI_DCS_LONG_WRITE || msg->type == MIPI_DSI_GENERIC_LONG_WRITE) {
+	if (msg->type == MIPI_DSI_DCS_LONG_WRITE) {
 		pkt |= ((msg->tx_len) & 0xffff) << 8;
 		pkt |= (((msg->tx_len) >> 8) & 0xffff) << 16;
 	} else {
@@ -1021,7 +1015,6 @@ static ssize_t sun6i_dsi_transfer(struct mipi_dsi_host *host,
 		ret = sun6i_dsi_dcs_write_short(dsi, msg);
 		break;
 
-	case MIPI_DSI_GENERIC_LONG_WRITE:
 	case MIPI_DSI_DCS_LONG_WRITE:
 		ret = sun6i_dsi_dcs_write_long(dsi, msg);
 		break;
@@ -1112,7 +1105,6 @@ static int sun6i_dsi_probe(struct platform_device *pdev)
 	const char *bus_clk_name = NULL;
 	struct sun6i_dsi *dsi;
 	void __iomem *base;
-	u32 fb_start;
 	int ret;
 
 	dsi = devm_kzalloc(dev, sizeof(*dsi), GFP_KERNEL);
@@ -1123,12 +1115,6 @@ static int sun6i_dsi_probe(struct platform_device *pdev)
 	dsi->host.ops = &sun6i_dsi_host_ops;
 	dsi->host.dev = dev;
 
-	ret = of_property_read_u32_index(of_chosen, "p-boot,framebuffer-start", 0, &fb_start);
-	if (ret == 0) {
-		/* the display pipeline is already initialized by p-boot */
-		dsi->hw_preconfigured = true;
-	}
-
 	if (of_device_is_compatible(dev->of_node,
 				    "allwinner,sun6i-a31-mipi-dsi"))
 		bus_clk_name = "bus";
diff --git a/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.h b/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.h
index 7f80ff130..c863900ae 100644
--- a/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.h
+++ b/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.h
@@ -31,8 +31,6 @@ struct sun6i_dsi {
 	struct mipi_dsi_device	*device;
 	struct drm_device	*drm;
 	struct drm_panel	*panel;
-	
-	bool hw_preconfigured;
 };
 
 static inline struct sun6i_dsi *host_to_sun6i_dsi(struct mipi_dsi_host *host)
diff --git a/drivers/gpu/drm/sun4i/sun8i_csc.c b/drivers/gpu/drm/sun4i/sun8i_csc.c
index 58480d8e4..d383d71a6 100644
--- a/drivers/gpu/drm/sun4i/sun8i_csc.c
+++ b/drivers/gpu/drm/sun4i/sun8i_csc.c
@@ -107,6 +107,14 @@ static const u32 yuv2rgb_de3[2][3][12] = {
 	},
 };
 
+static u32 sun8i_csc_base(struct sun8i_mixer *mixer, int layer)
+{
+	if (mixer->cfg->de_type == sun8i_mixer_de33)
+		return sun8i_channel_base(mixer, layer) - 0x200;
+	else
+		return ccsc_base[mixer->cfg->ccsc][layer];
+}
+
 static void sun8i_csc_set_coefficients(struct regmap *map, u32 base,
 				       enum sun8i_csc_mode mode,
 				       enum drm_color_encoding encoding,
@@ -178,6 +186,41 @@ static void sun8i_de3_ccsc_set_coefficients(struct regmap *map, int layer,
 	}
 }
 
+static void sun8i_de33_ccsc_set_coefficients(struct sun8i_mixer *mixer,
+					     int layer,
+					     enum sun8i_csc_mode mode,
+					     enum drm_color_encoding encoding,
+					     enum drm_color_range range)
+{
+	const u32 *table;
+	u32 base, addr;
+	int i;
+
+	base = sun8i_csc_base(mixer, layer);
+	table = yuv2rgb_de3[range][encoding];
+
+	regmap_write(mixer->engine.regs, base + 4, table[3] >> 16);
+	regmap_write(mixer->engine.regs, base + 8, table[7] >> 16);
+	regmap_write(mixer->engine.regs, base + 12, table[11] >> 16);
+
+	for (i = 0; i < 12; i++) {
+		u32 val = table[i];
+
+		addr = SUN8I_CSC_COEFF(base, i);
+		if (mode == SUN8I_CSC_MODE_YVU2RGB) {
+			if ((i & 3) == 1)
+				addr = SUN8I_CSC_COEFF(base, i + 1);
+			else if ((i & 3) == 2)
+				addr = SUN8I_CSC_COEFF(base, i - 1);
+		}
+
+		if (i == 3 || i == 7 || i == 11)
+			val &= 0xffff;
+
+		regmap_write(mixer->engine.regs, addr, val);
+	}
+}
+
 static void sun8i_csc_enable(struct regmap *map, u32 base, bool enable)
 {
 	u32 val;
@@ -212,10 +255,14 @@ void sun8i_csc_set_ccsc_coefficients(struct sun8i_mixer *mixer, int layer,
 {
 	u32 base;
 
-	if (mixer->cfg->is_de3) {
+	if (mixer->cfg->de_type == sun8i_mixer_de3) {
 		sun8i_de3_ccsc_set_coefficients(mixer->engine.regs, layer,
 						mode, encoding, range);
 		return;
+	} else if (mixer->cfg->de_type == sun8i_mixer_de33) {
+		sun8i_de33_ccsc_set_coefficients(mixer, layer, mode,
+						 encoding, range);
+		return;
 	}
 
 	base = ccsc_base[mixer->cfg->ccsc][layer];
@@ -228,12 +275,12 @@ void sun8i_csc_enable_ccsc(struct sun8i_mixer *mixer, int layer, bool enable)
 {
 	u32 base;
 
-	if (mixer->cfg->is_de3) {
+	if (mixer->cfg->de_type == sun8i_mixer_de3) {
 		sun8i_de3_ccsc_enable(mixer->engine.regs, layer, enable);
 		return;
 	}
 
-	base = ccsc_base[mixer->cfg->ccsc][layer];
+	base = sun8i_csc_base(mixer, layer);
 
 	sun8i_csc_enable(mixer->engine.regs, base, enable);
 }
diff --git a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
index 2860e6bff..244070cfd 100644
--- a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
+++ b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
@@ -90,7 +90,7 @@ static const struct dw_hdmi_mpll_config sun50i_h6_mpll_cfg[] = {
 		},
 	},  {
 		594000000, {
-			{ 0x1a40, 0x0003 },
+			{ 0x1a7c, 0x0003 },
 			{ 0x3b4c, 0x0003 },
 			{ 0x5a64, 0x0003 },
 		},
@@ -123,6 +123,66 @@ static const struct dw_hdmi_phy_config sun50i_h6_phy_config[] = {
 	{ ~0UL,	     0x0000, 0x0000, 0x0000}
 };
 
+static const struct dw_hdmi_mpll_config sun50i_h616_mpll_cfg[] = {
+	{
+		27000000, {
+			{ 0x00b3, 0x0003 },
+			{ 0x2153, 0x0003 },
+			{ 0x40f3, 0x0003 },
+		},
+	},  {
+		74250000, {
+			{ 0x0072, 0x0003 },
+			{ 0x2145, 0x0003 },
+			{ 0x4061, 0x0003 },
+		},
+	},  {
+		148500000, {
+			{ 0x0051, 0x0003 },
+			{ 0x214c, 0x0003 },
+			{ 0x4064, 0x0003 },
+		},
+	},  {
+		297000000, {
+			{ 0x0040, 0x0003 },
+			{ 0x3b4c, 0x0003 },
+			{ 0x5a64, 0x0003 },
+		},
+	},  {
+		594000000, {
+			{ 0x1a40, 0x0003 },
+			{ 0x3b4c, 0x0003 },
+			{ 0x5a64, 0x0003 },
+		},
+	}, {
+		~0UL, {
+			{ 0x0000, 0x0000 },
+			{ 0x0000, 0x0000 },
+			{ 0x0000, 0x0000 },
+		},
+	}
+};
+
+static const struct dw_hdmi_curr_ctrl sun50i_h616_cur_ctr[] = {
+	/* pixelclk    bpp8    bpp10   bpp12 */
+	{ 27000000,  { 0x0012, 0x0000, 0x0000 }, },
+	{ 74250000,  { 0x0013, 0x0013, 0x0013 }, },
+	{ 148500000, { 0x0019, 0x0019, 0x0019 }, },
+	{ 297000000, { 0x0019, 0x001b, 0x0019 }, },
+	{ 594000000, { 0x0010, 0x0010, 0x0010 }, },
+	{ ~0UL,      { 0x0000, 0x0000, 0x0000 }, }
+};
+
+static const struct dw_hdmi_phy_config sun50i_h616_phy_config[] = {
+	/*pixelclk   symbol   term   vlev*/
+	{ 27000000,  0x8009, 0x0007, 0x02b0},
+	{ 74250000,  0x8019, 0x0004, 0x0290},
+	{ 148500000, 0x8019, 0x0004, 0x0290},
+	{ 297000000, 0x8039, 0x0004, 0x022b},
+	{ 594000000, 0x8029, 0x0000, 0x008a},
+	{ ~0UL,	     0x0000, 0x0000, 0x0000}
+};
+
 static int sun8i_hdmi_phy_config_a83t(struct dw_hdmi *hdmi,
 				      struct sun8i_hdmi_phy *phy,
 				      unsigned int clk_rate)
@@ -625,6 +685,13 @@ static const struct sun8i_hdmi_phy_variant sun50i_h6_hdmi_phy = {
 	.phy_init = &sun50i_hdmi_phy_init_h6,
 };
 
+static const struct sun8i_hdmi_phy_variant sun50i_h616_hdmi_phy = {
+	.cur_ctr  = sun50i_h616_cur_ctr,
+	.mpll_cfg = sun50i_h616_mpll_cfg,
+	.phy_cfg  = sun50i_h616_phy_config,
+	.phy_init = &sun50i_hdmi_phy_init_h6,
+};
+
 static const struct of_device_id sun8i_hdmi_phy_of_table[] = {
 	{
 		.compatible = "allwinner,sun8i-a83t-hdmi-phy",
@@ -646,6 +713,10 @@ static const struct of_device_id sun8i_hdmi_phy_of_table[] = {
 		.compatible = "allwinner,sun50i-h6-hdmi-phy",
 		.data = &sun50i_h6_hdmi_phy,
 	},
+	{
+		.compatible = "allwinner,sun50i-h616-hdmi-phy",
+		.data = &sun50i_h616_hdmi_phy,
+	},
 	{ /* sentinel */ }
 };
 
diff --git a/drivers/gpu/drm/sun4i/sun8i_mixer.c b/drivers/gpu/drm/sun4i/sun8i_mixer.c
index 407e5a87e..0318872ea 100644
--- a/drivers/gpu/drm/sun4i/sun8i_mixer.c
+++ b/drivers/gpu/drm/sun4i/sun8i_mixer.c
@@ -22,7 +22,6 @@
 #include <drm/drm_probe_helper.h>
 
 #include "sun4i_drv.h"
-#include "sun4i_tcon.h"
 #include "sun8i_mixer.h"
 #include "sun8i_ui_layer.h"
 #include "sun8i_vi_layer.h"
@@ -33,8 +32,6 @@ struct de2_fmt_info {
 	u32	de2_fmt;
 };
 
-static bool hw_preconfigured;
-
 static const struct de2_fmt_info de2_formats[] = {
 	{
 		.drm_fmt = DRM_FORMAT_ARGB8888,
@@ -253,38 +250,16 @@ int sun8i_mixer_drm_format_to_hw(u32 format, u32 *hw_format)
 
 static void sun8i_mixer_commit(struct sunxi_engine *engine)
 {
-	struct sun8i_mixer* mixer = engine_to_sun8i_mixer(engine);
-	struct sun4i_tcon* tcon;
-	u32 val, saved, ret;
+	struct sun8i_mixer *mixer = engine_to_sun8i_mixer(engine);
 
 	DRM_DEBUG_DRIVER("Committing changes\n");
 
-	if (mixer->hw_preconfigured && engine->id == 0) {
-		/*
-		 * This is the first commit, wait for vblank on tcon0 before continuing.
-		 */
-		list_for_each_entry(tcon, &mixer->drv->tcon_list, list) {
-			if (tcon->id == 0) {
-				regmap_read(tcon->regs, SUN4I_TCON_GINT0_REG, &saved);
-				saved &= 0xffff0000;
-
-				regmap_write(tcon->regs, SUN4I_TCON_GINT0_REG, 0);
-
-				ret = regmap_read_poll_timeout(tcon->regs, SUN4I_TCON_GINT0_REG, val,
-							 val & (SUN4I_TCON_GINT0_VBLANK_INT(0) |
-								SUN4I_TCON_GINT0_VBLANK_INT(1) |
-								SUN4I_TCON_GINT0_TCON0_TRI_FINISH_INT),
-							 100, 40000);
-
-				regmap_write(tcon->regs, SUN4I_TCON_GINT0_REG, saved);
-			}
-		}
-
-		mixer->hw_preconfigured = false;
-	}
-
-	regmap_write(engine->regs, SUN8I_MIXER_GLOBAL_DBUFF,
-		     SUN8I_MIXER_GLOBAL_DBUFF_ENABLE);
+	if (mixer->cfg->de_type == sun8i_mixer_de33)
+		regmap_write(mixer->top_regs, SUN50I_MIXER_GLOBAL_DBUFF,
+			     SUN8I_MIXER_GLOBAL_DBUFF_ENABLE);
+	else
+		regmap_write(engine->regs, SUN8I_MIXER_GLOBAL_DBUFF,
+			     SUN8I_MIXER_GLOBAL_DBUFF_ENABLE);
 }
 
 static struct drm_plane **sun8i_layers_init(struct drm_device *drm,
@@ -315,13 +290,8 @@ static struct drm_plane **sun8i_layers_init(struct drm_device *drm,
 
 	for (i = 0; i < mixer->cfg->ui_num; i++) {
 		struct sun8i_ui_layer *layer;
-		enum drm_plane_type type = DRM_PLANE_TYPE_OVERLAY;
-		if (i == 0)
-			type = DRM_PLANE_TYPE_PRIMARY;
-		else if (i == (mixer->cfg->ui_num - 1))
-			type = DRM_PLANE_TYPE_CURSOR;
 
-		layer = sun8i_ui_layer_init_one(drm, mixer, i, type);
+		layer = sun8i_ui_layer_init_one(drm, mixer, i);
 		if (IS_ERR(layer)) {
 			dev_err(drm->dev, "Couldn't initialize %s plane\n",
 				i ? "overlay" : "primary");
@@ -334,46 +304,42 @@ static struct drm_plane **sun8i_layers_init(struct drm_device *drm,
 	return planes;
 }
 
-static void sun8i_mixer_mode_set(struct sunxi_engine *engine,
-				 const struct drm_display_mode *mode)
-{
-	struct sun8i_mixer *mixer = engine_to_sun8i_mixer(engine);
-	u32 bld_base, size, val;
-	bool interlaced;
-
-	bld_base = sun8i_blender_base(mixer);
-	interlaced = !!(mode->flags & DRM_MODE_FLAG_INTERLACE);
-	size = SUN8I_MIXER_SIZE(mode->hdisplay, mode->vdisplay);
-
-	DRM_DEBUG_DRIVER("Updating global size W: %u H: %u\n",
-			 mode->hdisplay, mode->vdisplay);
-
-	regmap_write(engine->regs, SUN8I_MIXER_GLOBAL_SIZE, size);
-	regmap_write(engine->regs, SUN8I_MIXER_BLEND_OUTSIZE(bld_base), size);
-
-	if (interlaced)
-		val = SUN8I_MIXER_BLEND_OUTCTL_INTERLACED;
-	else
-		val = 0;
-
-	regmap_update_bits(engine->regs, SUN8I_MIXER_BLEND_OUTCTL(bld_base),
-			   SUN8I_MIXER_BLEND_OUTCTL_INTERLACED, val);
-
-	DRM_DEBUG_DRIVER("Switching display mixer interlaced mode %s\n",
-			 interlaced ? "on" : "off");
-}
-
 static const struct sunxi_engine_ops sun8i_engine_ops = {
 	.commit		= sun8i_mixer_commit,
 	.layers_init	= sun8i_layers_init,
-	.mode_set	= sun8i_mixer_mode_set,
 };
 
+static bool sun8i_mixer_volatile_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case SUN8I_MIXER_GLOBAL_STATUS:
+	case SUN8I_MIXER_GLOBAL_DBUFF:
+		return true;
+	}
+	return false;
+}
+
 static const struct regmap_config sun8i_mixer_regmap_config = {
+	.cache_type	= REGCACHE_FLAT,
 	.reg_bits	= 32,
 	.val_bits	= 32,
 	.reg_stride	= 4,
 	.max_register	= 0xffffc, /* guessed */
+	.volatile_reg	= sun8i_mixer_volatile_reg,
+};
+
+static const struct regmap_config sun8i_top_regmap_config = {
+	.reg_bits	= 32,
+	.val_bits	= 32,
+	.reg_stride	= 4,
+	.max_register	= 0x3c,
+};
+
+static const struct regmap_config sun8i_disp_regmap_config = {
+	.reg_bits	= 32,
+	.val_bits	= 32,
+	.reg_stride	= 4,
+	.max_register	= 0x20000,
 };
 
 static int sun8i_mixer_of_get_id(struct device_node *node)
@@ -396,6 +362,76 @@ static int sun8i_mixer_of_get_id(struct device_node *node)
 	return of_ep.id;
 }
 
+static void sun8i_mixer_de2_init(struct sun8i_mixer *mixer)
+{
+	unsigned int base;
+	int plane_cnt, i;
+
+	base = sun8i_blender_base(mixer);
+
+	/* Enable the mixer */
+	regmap_write(mixer->engine.regs, SUN8I_MIXER_GLOBAL_CTL,
+		     SUN8I_MIXER_GLOBAL_CTL_RT_EN);
+
+	/* Set background color to black */
+	regmap_write(mixer->engine.regs, SUN8I_MIXER_BLEND_BKCOLOR(base),
+		     SUN8I_MIXER_BLEND_COLOR_BLACK);
+
+	/*
+	 * Set fill color of bottom plane to black. Generally not needed
+	 * except when VI plane is at bottom (zpos = 0) and enabled.
+	 */
+	regmap_write(mixer->engine.regs, SUN8I_MIXER_BLEND_PIPE_CTL(base),
+		     SUN8I_MIXER_BLEND_PIPE_CTL_FC_EN(0));
+	regmap_write(mixer->engine.regs, SUN8I_MIXER_BLEND_ATTR_FCOLOR(base, 0),
+		     SUN8I_MIXER_BLEND_COLOR_BLACK);
+
+	plane_cnt = mixer->cfg->vi_num + mixer->cfg->ui_num;
+	for (i = 0; i < plane_cnt; i++)
+		regmap_write(mixer->engine.regs,
+			     SUN8I_MIXER_BLEND_MODE(base, i),
+			     SUN8I_MIXER_BLEND_MODE_DEF);
+
+	regmap_update_bits(mixer->engine.regs, SUN8I_MIXER_BLEND_PIPE_CTL(base),
+			   SUN8I_MIXER_BLEND_PIPE_CTL_EN_MSK, 0);
+}
+
+static void sun8i_mixer_de33_init(struct sun8i_mixer *mixer)
+{
+	unsigned int base;
+	int plane_cnt, i;
+
+	base = sun8i_blender_base(mixer);
+
+	/* Enable the mixer */
+	regmap_write(mixer->top_regs, SUN50I_MIXER_GLOBAL_CTL,
+		     SUN8I_MIXER_GLOBAL_CTL_RT_EN);
+
+	regmap_write(mixer->top_regs, SUN50I_MIXER_GLOBAL_CLK, 1);
+
+	/* Set background color to black */
+	regmap_write(mixer->disp_regs, SUN8I_MIXER_BLEND_BKCOLOR(base),
+		     SUN8I_MIXER_BLEND_COLOR_BLACK);
+
+	/*
+	 * Set fill color of bottom plane to black. Generally not needed
+	 * except when VI plane is at bottom (zpos = 0) and enabled.
+	 */
+	regmap_write(mixer->disp_regs, SUN8I_MIXER_BLEND_PIPE_CTL(base),
+		     SUN8I_MIXER_BLEND_PIPE_CTL_FC_EN(0));
+	regmap_write(mixer->disp_regs, SUN8I_MIXER_BLEND_ATTR_FCOLOR(base, 0),
+		     SUN8I_MIXER_BLEND_COLOR_BLACK);
+
+	plane_cnt = mixer->cfg->vi_num + mixer->cfg->ui_num;
+	for (i = 0; i < plane_cnt; i++)
+		regmap_write(mixer->disp_regs,
+			     SUN8I_MIXER_BLEND_MODE(base, i),
+			     SUN8I_MIXER_BLEND_MODE_DEF);
+
+	regmap_update_bits(mixer->disp_regs, SUN8I_MIXER_BLEND_PIPE_CTL(base),
+			   SUN8I_MIXER_BLEND_PIPE_CTL_EN_MSK, 0);
+}
+
 static int sun8i_mixer_bind(struct device *dev, struct device *master,
 			      void *data)
 {
@@ -404,8 +440,6 @@ static int sun8i_mixer_bind(struct device *dev, struct device *master,
 	struct sun4i_drv *drv = drm->dev_private;
 	struct sun8i_mixer *mixer;
 	void __iomem *regs;
-	unsigned int base;
-	int plane_cnt;
 	int i, ret;
 
 	/*
@@ -427,7 +461,6 @@ static int sun8i_mixer_bind(struct device *dev, struct device *master,
 	dev_set_drvdata(dev, mixer);
 	mixer->engine.ops = &sun8i_engine_ops;
 	mixer->engine.node = dev->of_node;
-	mixer->drv = drv;
 
 	if (of_find_property(dev->of_node, "iommus", NULL)) {
 		/*
@@ -452,11 +485,6 @@ static int sun8i_mixer_bind(struct device *dev, struct device *master,
 	 */
 	mixer->engine.id = sun8i_mixer_of_get_id(dev->of_node);
 
-	if (mixer->engine.id == 0) {
-		mixer->hw_preconfigured = hw_preconfigured;
-		hw_preconfigured = false;
-	}
-
 	mixer->cfg = of_device_get_match_data(dev);
 	if (!mixer->cfg)
 		return -EINVAL;
@@ -472,6 +500,30 @@ static int sun8i_mixer_bind(struct device *dev, struct device *master,
 		return PTR_ERR(mixer->engine.regs);
 	}
 
+	if (mixer->cfg->de_type == sun8i_mixer_de33) {
+		regs = devm_platform_ioremap_resource(pdev, 1);
+		if (IS_ERR(regs))
+			return PTR_ERR(regs);
+
+		mixer->top_regs = devm_regmap_init_mmio(dev, regs,
+							&sun8i_top_regmap_config);
+		if (IS_ERR(mixer->top_regs)) {
+			dev_err(dev, "Couldn't create the top regmap\n");
+			return PTR_ERR(mixer->top_regs);
+		}
+
+		regs = devm_platform_ioremap_resource(pdev, 2);
+		if (IS_ERR(regs))
+			return PTR_ERR(regs);
+
+		mixer->disp_regs = devm_regmap_init_mmio(dev, regs,
+							&sun8i_disp_regmap_config);
+		if (IS_ERR(mixer->disp_regs)) {
+			dev_err(dev, "Couldn't create the disp regmap\n");
+			return PTR_ERR(mixer->disp_regs);
+		}
+	}
+
 	mixer->reset = devm_reset_control_get(dev, NULL);
 	if (IS_ERR(mixer->reset)) {
 		dev_err(dev, "Couldn't get our reset line\n");
@@ -504,21 +556,17 @@ static int sun8i_mixer_bind(struct device *dev, struct device *master,
 	 * reason for the mixer to be functional. Make sure it's the
 	 * case.
 	 */
-
-	if (!mixer->hw_preconfigured) {
 	if (mixer->cfg->mod_rate)
 		clk_set_rate(mixer->mod_clk, mixer->cfg->mod_rate);
-	}
 
 	clk_prepare_enable(mixer->mod_clk);
 
 	list_add_tail(&mixer->engine.list, &drv->engine_list);
 
-	base = sun8i_blender_base(mixer);
-
-	if (!mixer->hw_preconfigured) {
 	/* Reset registers and disable unused sub-engines */
-	if (mixer->cfg->is_de3) {
+	if (mixer->cfg->de_type == sun8i_mixer_de33) {
+		sun8i_mixer_de33_init(mixer);
+	} else if (mixer->cfg->de_type == sun8i_mixer_de3) {
 		for (i = 0; i < DE3_MIXER_UNIT_SIZE; i += 4)
 			regmap_write(mixer->engine.regs, i, 0);
 
@@ -532,7 +580,9 @@ static int sun8i_mixer_bind(struct device *dev, struct device *master,
 		regmap_write(mixer->engine.regs, SUN50I_MIXER_FMT_EN, 0);
 		regmap_write(mixer->engine.regs, SUN50I_MIXER_CDC0_EN, 0);
 		regmap_write(mixer->engine.regs, SUN50I_MIXER_CDC1_EN, 0);
-	} else {
+
+		sun8i_mixer_de2_init(mixer);
+	} else if (mixer->cfg->de_type == sun8i_mixer_de2) {
 		for (i = 0; i < DE2_MIXER_UNIT_SIZE; i += 4)
 			regmap_write(mixer->engine.regs, i, 0);
 
@@ -543,35 +593,8 @@ static int sun8i_mixer_bind(struct device *dev, struct device *master,
 		regmap_write(mixer->engine.regs, SUN8I_MIXER_ASE_EN, 0);
 		regmap_write(mixer->engine.regs, SUN8I_MIXER_FCC_EN, 0);
 		regmap_write(mixer->engine.regs, SUN8I_MIXER_DCSC_EN, 0);
-	}
-
-	/* Enable the mixer */
-	regmap_write(mixer->engine.regs, SUN8I_MIXER_GLOBAL_CTL,
-		     SUN8I_MIXER_GLOBAL_CTL_RT_EN);
-	} /* hw_preconfigured */
-
-	/* Set background color to black */
-	regmap_write(mixer->engine.regs, SUN8I_MIXER_BLEND_BKCOLOR(base),
-		     SUN8I_MIXER_BLEND_COLOR_BLACK);
 
-	/*
-	 * Set fill color of bottom plane to black. Generally not needed
-	 * except when VI plane is at bottom (zpos = 0) and enabled.
-	 */
-	regmap_write(mixer->engine.regs, SUN8I_MIXER_BLEND_PIPE_CTL(base),
-		     SUN8I_MIXER_BLEND_PIPE_CTL_FC_EN(0));
-	regmap_write(mixer->engine.regs, SUN8I_MIXER_BLEND_ATTR_FCOLOR(base, 0),
-		     SUN8I_MIXER_BLEND_COLOR_BLACK);
-
-	plane_cnt = mixer->cfg->vi_num + mixer->cfg->ui_num;
-	for (i = 0; i < plane_cnt; i++)
-		regmap_write(mixer->engine.regs,
-			     SUN8I_MIXER_BLEND_MODE(base, i),
-			     SUN8I_MIXER_BLEND_MODE_DEF);
-
-	if (!mixer->hw_preconfigured) {
-	regmap_update_bits(mixer->engine.regs, SUN8I_MIXER_BLEND_PIPE_CTL(base),
-			   SUN8I_MIXER_BLEND_PIPE_CTL_EN_MSK, 0);
+		sun8i_mixer_de2_init(mixer);
 	}
 
 	return 0;
@@ -602,15 +625,6 @@ static const struct component_ops sun8i_mixer_ops = {
 
 static int sun8i_mixer_probe(struct platform_device *pdev)
 {
-	int ret;
-	u32 fb_start;
-
-	ret = of_property_read_u32_index(of_chosen, "p-boot,framebuffer-start", 0, &fb_start);
-	if (ret == 0) {
-		/* the display pipeline is already initialized by p-boot */
-		hw_preconfigured = true;
-	}
-
 	return component_add(&pdev->dev, &sun8i_mixer_ops);
 }
 
@@ -623,6 +637,7 @@ static int sun8i_mixer_remove(struct platform_device *pdev)
 
 static const struct sun8i_mixer_cfg sun8i_a83t_mixer0_cfg = {
 	.ccsc		= CCSC_MIXER0_LAYOUT,
+	.de_type	= sun8i_mixer_de2,
 	.scaler_mask	= 0xf,
 	.scanline_yuv	= 2048,
 	.ui_num		= 3,
@@ -631,6 +646,7 @@ static const struct sun8i_mixer_cfg sun8i_a83t_mixer0_cfg = {
 
 static const struct sun8i_mixer_cfg sun8i_a83t_mixer1_cfg = {
 	.ccsc		= CCSC_MIXER1_LAYOUT,
+	.de_type	= sun8i_mixer_de2,
 	.scaler_mask	= 0x3,
 	.scanline_yuv	= 2048,
 	.ui_num		= 1,
@@ -639,6 +655,7 @@ static const struct sun8i_mixer_cfg sun8i_a83t_mixer1_cfg = {
 
 static const struct sun8i_mixer_cfg sun8i_h3_mixer0_cfg = {
 	.ccsc		= CCSC_MIXER0_LAYOUT,
+	.de_type	= sun8i_mixer_de2,
 	.mod_rate	= 432000000,
 	.scaler_mask	= 0xf,
 	.scanline_yuv	= 2048,
@@ -646,16 +663,9 @@ static const struct sun8i_mixer_cfg sun8i_h3_mixer0_cfg = {
 	.vi_num		= 1,
 };
 
-static const struct sun8i_mixer_cfg sun8i_h3_mixer1_cfg = {
-	.ccsc		= CCSC_MIXER1_LAYOUT,
-	.mod_rate	= 432000000,
-	.scaler_mask	= 0xf,
-	.ui_num		= 3,
-	.vi_num		= 1,
-};
-
 static const struct sun8i_mixer_cfg sun8i_r40_mixer0_cfg = {
 	.ccsc		= CCSC_MIXER0_LAYOUT,
+	.de_type	= sun8i_mixer_de2,
 	.mod_rate	= 297000000,
 	.scaler_mask	= 0xf,
 	.scanline_yuv	= 2048,
@@ -665,6 +675,7 @@ static const struct sun8i_mixer_cfg sun8i_r40_mixer0_cfg = {
 
 static const struct sun8i_mixer_cfg sun8i_r40_mixer1_cfg = {
 	.ccsc		= CCSC_MIXER1_LAYOUT,
+	.de_type	= sun8i_mixer_de2,
 	.mod_rate	= 297000000,
 	.scaler_mask	= 0x3,
 	.scanline_yuv	= 2048,
@@ -673,6 +684,7 @@ static const struct sun8i_mixer_cfg sun8i_r40_mixer1_cfg = {
 };
 
 static const struct sun8i_mixer_cfg sun8i_v3s_mixer_cfg = {
+	.de_type = sun8i_mixer_de2,
 	.vi_num = 2,
 	.ui_num = 1,
 	.scaler_mask = 0x3,
@@ -701,6 +713,7 @@ static const struct sun8i_mixer_cfg sun20i_d1_mixer1_cfg = {
 
 static const struct sun8i_mixer_cfg sun50i_a64_mixer0_cfg = {
 	.ccsc		= CCSC_MIXER0_LAYOUT,
+	.de_type	= sun8i_mixer_de2,
 	.mod_rate	= 297000000,
 	.scaler_mask	= 0xf,
 	.scanline_yuv	= 4096,
@@ -710,6 +723,7 @@ static const struct sun8i_mixer_cfg sun50i_a64_mixer0_cfg = {
 
 static const struct sun8i_mixer_cfg sun50i_a64_mixer1_cfg = {
 	.ccsc		= CCSC_MIXER1_LAYOUT,
+	.de_type	= sun8i_mixer_de2,
 	.mod_rate	= 297000000,
 	.scaler_mask	= 0x3,
 	.scanline_yuv	= 2048,
@@ -719,7 +733,7 @@ static const struct sun8i_mixer_cfg sun50i_a64_mixer1_cfg = {
 
 static const struct sun8i_mixer_cfg sun50i_h6_mixer0_cfg = {
 	.ccsc		= CCSC_MIXER0_LAYOUT,
-	.is_de3		= true,
+	.de_type	= sun8i_mixer_de3,
 	.mod_rate	= 600000000,
 	.scaler_mask	= 0xf,
 	.scanline_yuv	= 4096,
@@ -727,6 +741,17 @@ static const struct sun8i_mixer_cfg sun50i_h6_mixer0_cfg = {
 	.vi_num		= 1,
 };
 
+static const struct sun8i_mixer_cfg sun50i_h616_mixer0_cfg = {
+	.ccsc		= CCSC_MIXER0_LAYOUT,
+	.de_type	= sun8i_mixer_de33,
+	.mod_rate	= 600000000,
+	.scaler_mask	= 0xf,
+	.scanline_yuv	= 4096,
+	.ui_num		= 3,
+	.vi_num		= 1,
+	.map		= {0, 6, 7, 8},
+};
+
 static const struct of_device_id sun8i_mixer_of_table[] = {
 	{
 		.compatible = "allwinner,sun8i-a83t-de2-mixer-0",
@@ -740,10 +765,6 @@ static const struct of_device_id sun8i_mixer_of_table[] = {
 		.compatible = "allwinner,sun8i-h3-de2-mixer-0",
 		.data = &sun8i_h3_mixer0_cfg,
 	},
-	{
-		.compatible = "allwinner,sun8i-h3-de2-mixer-1",
-		.data = &sun8i_h3_mixer1_cfg,
-	},
 	{
 		.compatible = "allwinner,sun8i-r40-de2-mixer-0",
 		.data = &sun8i_r40_mixer0_cfg,
@@ -776,6 +797,10 @@ static const struct of_device_id sun8i_mixer_of_table[] = {
 		.compatible = "allwinner,sun50i-h6-de3-mixer-0",
 		.data = &sun50i_h6_mixer0_cfg,
 	},
+	{
+		.compatible = "allwinner,sun50i-h616-de33-mixer-0",
+		.data = &sun50i_h616_mixer0_cfg,
+	},
 	{ }
 };
 MODULE_DEVICE_TABLE(of, sun8i_mixer_of_table);
diff --git a/drivers/gpu/drm/sun4i/sun8i_mixer.h b/drivers/gpu/drm/sun4i/sun8i_mixer.h
index 9ed85dd73..ebd4de66b 100644
--- a/drivers/gpu/drm/sun4i/sun8i_mixer.h
+++ b/drivers/gpu/drm/sun4i/sun8i_mixer.h
@@ -20,6 +20,12 @@
 #define SUN8I_MIXER_GLOBAL_DBUFF		0x8
 #define SUN8I_MIXER_GLOBAL_SIZE			0xc
 
+#define SUN50I_MIXER_GLOBAL_CTL			0x0
+#define SUN50I_MIXER_GLOBAL_STATUS		0x4
+#define SUN50I_MIXER_GLOBAL_SIZE		0x8
+#define SUN50I_MIXER_GLOBAL_CLK			0xc
+#define SUN50I_MIXER_GLOBAL_DBUFF		0x10
+
 #define SUN8I_MIXER_GLOBAL_CTL_RT_EN		BIT(0)
 
 #define SUN8I_MIXER_GLOBAL_DBUFF_ENABLE		BIT(0)
@@ -141,6 +147,12 @@
 #define SUN50I_MIXER_CDC0_EN			0xd0000
 #define SUN50I_MIXER_CDC1_EN			0xd8000
 
+enum sun8i_mixer_type {
+	sun8i_mixer_de2,
+	sun8i_mixer_de3,
+	sun8i_mixer_de33,
+};
+
 enum {
 	/* First mixer or second mixer with VEP support. */
 	CCSC_MIXER0_LAYOUT,
@@ -170,8 +182,9 @@ struct sun8i_mixer_cfg {
 	int		scaler_mask;
 	int		ccsc;
 	unsigned long	mod_rate;
-	unsigned int	is_de3 : 1;
+	unsigned int	de_type;
 	unsigned int	scanline_yuv;
+	unsigned int	map[6];
 };
 
 struct sun8i_mixer {
@@ -184,8 +197,8 @@ struct sun8i_mixer {
 	struct clk			*bus_clk;
 	struct clk			*mod_clk;
 
-	struct sun4i_drv		*drv;
-	bool				hw_preconfigured;
+	struct regmap			*top_regs;
+	struct regmap			*disp_regs;
 };
 
 static inline struct sun8i_mixer *
@@ -197,13 +210,22 @@ engine_to_sun8i_mixer(struct sunxi_engine *engine)
 static inline u32
 sun8i_blender_base(struct sun8i_mixer *mixer)
 {
-	return mixer->cfg->is_de3 ? DE3_BLD_BASE : DE2_BLD_BASE;
+	return mixer->cfg->de_type == sun8i_mixer_de3 ? DE3_BLD_BASE : DE2_BLD_BASE;
+}
+
+static inline struct regmap *
+sun8i_blender_regmap(struct sun8i_mixer *mixer)
+{
+	return mixer->cfg->de_type == sun8i_mixer_de33 ?
+		mixer->disp_regs : mixer->engine.regs;
 }
 
 static inline u32
 sun8i_channel_base(struct sun8i_mixer *mixer, int channel)
 {
-	if (mixer->cfg->is_de3)
+	if (mixer->cfg->de_type == sun8i_mixer_de33)
+		return mixer->cfg->map[channel] * 0x20000 + DE2_CH_SIZE;
+	else if (mixer->cfg->de_type == sun8i_mixer_de3)
 		return DE3_CH_BASE + channel * DE3_CH_SIZE;
 	else
 		return DE2_CH_BASE + channel * DE2_CH_SIZE;
diff --git a/drivers/gpu/drm/sun4i/sun8i_ui_layer.c b/drivers/gpu/drm/sun4i/sun8i_ui_layer.c
index cee59271e..7b5af04d2 100644
--- a/drivers/gpu/drm/sun4i/sun8i_ui_layer.c
+++ b/drivers/gpu/drm/sun4i/sun8i_ui_layer.c
@@ -22,90 +22,57 @@
 #include "sun8i_mixer.h"
 #include "sun8i_ui_layer.h"
 #include "sun8i_ui_scaler.h"
+#include "sun8i_vi_scaler.h"
 
 static void sun8i_ui_layer_enable(struct sun8i_mixer *mixer, int channel,
-				  int overlay, bool was_enabled, bool enable,
-				  unsigned int zpos, unsigned int old_zpos)
+				  int overlay, bool enable, unsigned int zpos,
+				  unsigned int old_zpos)
 {
 	u32 val, bld_base, ch_base;
-	unsigned int old_pipe_ch;
-	unsigned tmp;
+	struct regmap *bld_regs;
 
 	bld_base = sun8i_blender_base(mixer);
+	bld_regs = sun8i_blender_regmap(mixer);
 	ch_base = sun8i_channel_base(mixer, channel);
 
 	DRM_DEBUG_DRIVER("%sabling channel %d overlay %d\n",
 			 enable ? "En" : "Dis", channel, overlay);
 
-	/* We always update the layer enable bit, because it can clear
-	 * spontaneously for unknown reasons. */
-	val = enable ? SUN8I_MIXER_CHAN_UI_LAYER_ATTR_EN : 0;
+	if (enable)
+		val = SUN8I_MIXER_CHAN_UI_LAYER_ATTR_EN;
+	else
+		val = 0;
+
 	regmap_update_bits(mixer->engine.regs,
 			   SUN8I_MIXER_CHAN_UI_LAYER_ATTR(ch_base, overlay),
 			   SUN8I_MIXER_CHAN_UI_LAYER_ATTR_EN, val);
 
-	/*
-	 * If this layer was enabled and is being disabled or if it is
-	 * enabled and just changing zpos, clear the old route, if it is
-	 * still configured to this layer in HW.
-	 */
-	if ((was_enabled && !enable) || (enable && zpos != old_zpos)) {
-		/* get channel the pipe for old_zpos is routed to from the HW */
-		regmap_read(mixer->engine.regs,
+	if (!enable || zpos != old_zpos) {
+		regmap_update_bits(bld_regs,
+				   SUN8I_MIXER_BLEND_PIPE_CTL(bld_base),
+				   SUN8I_MIXER_BLEND_PIPE_CTL_EN(old_zpos),
+				   0);
+
+		regmap_update_bits(bld_regs,
 				   SUN8I_MIXER_BLEND_ROUTE(bld_base),
-				   &old_pipe_ch);
-		old_pipe_ch &= SUN8I_MIXER_BLEND_ROUTE_PIPE_MSK(old_zpos);
-		old_pipe_ch >>= SUN8I_MIXER_BLEND_ROUTE_PIPE_SHIFT(old_zpos);
-
-		/*
-		 * Check that pipe for old_zpos is still routed to our layer,
-		 * and clear/disable it if it is.
-		 */
-
-		if (old_pipe_ch == channel) {
-			DRM_DEBUG_DRIVER("chan=%d en=%d->%d zpos=%d->%d\n",
-			       channel, was_enabled, enable, old_zpos, zpos);
-
-			DRM_DEBUG_DRIVER("  disable pipe %d\n", old_zpos);
-
-			regmap_update_bits(mixer->engine.regs,
-					   SUN8I_MIXER_BLEND_ROUTE(bld_base),
-					   SUN8I_MIXER_BLEND_ROUTE_PIPE_MSK(old_zpos),
-					   0);
-
-			regmap_update_bits(mixer->engine.regs,
-					   SUN8I_MIXER_BLEND_PIPE_CTL(bld_base),
-					   SUN8I_MIXER_BLEND_PIPE_CTL_EN(old_zpos),
-					   0);
-		}
+				   SUN8I_MIXER_BLEND_ROUTE_PIPE_MSK(old_zpos),
+				   0);
 	}
 
-	/*
-	 * If enabling this layer or changin zpos, set route to this layer.
-	 */
-	if ((enable && !was_enabled) || (enable && zpos != old_zpos)) {
-		DRM_DEBUG_DRIVER("chan=%d en=%d->%d zpos=%d->%d\n",
-		       channel, was_enabled, enable, old_zpos, zpos);
-
+	if (enable) {
 		val = SUN8I_MIXER_BLEND_PIPE_CTL_EN(zpos);
 
-		regmap_update_bits(mixer->engine.regs,
+		regmap_update_bits(bld_regs,
 				   SUN8I_MIXER_BLEND_PIPE_CTL(bld_base),
 				   val, val);
 
 		val = channel << SUN8I_MIXER_BLEND_ROUTE_PIPE_SHIFT(zpos);
 
-		regmap_update_bits(mixer->engine.regs,
+		regmap_update_bits(bld_regs,
 				   SUN8I_MIXER_BLEND_ROUTE(bld_base),
 				   SUN8I_MIXER_BLEND_ROUTE_PIPE_MSK(zpos),
 				   val);
-
-		DRM_DEBUG_DRIVER("  enable pipe %d <- ch %d\n", zpos, channel);
 	}
-
-	regmap_read(mixer->engine.regs,
-			   SUN8I_MIXER_CHAN_UI_LAYER_ATTR(ch_base, overlay), &tmp);
-	DRM_DEBUG_DRIVER("  post-en-dis %08x\n", tmp);
 }
 
 static void sun8i_ui_layer_update_alpha(struct sun8i_mixer *mixer, int channel,
@@ -135,6 +102,7 @@ static int sun8i_ui_layer_update_coord(struct sun8i_mixer *mixer, int channel,
 {
 	struct drm_plane_state *state = plane->state;
 	u32 src_w, src_h, dst_w, dst_h;
+	struct regmap *bld_regs;
 	u32 bld_base, ch_base;
 	u32 outsize, insize;
 	u32 hphase, vphase;
@@ -143,6 +111,7 @@ static int sun8i_ui_layer_update_coord(struct sun8i_mixer *mixer, int channel,
 			 channel, overlay);
 
 	bld_base = sun8i_blender_base(mixer);
+	bld_regs = sun8i_blender_regmap(mixer);
 	ch_base = sun8i_channel_base(mixer, channel);
 
 	src_w = drm_rect_width(&state->src) >> 16;
@@ -156,6 +125,41 @@ static int sun8i_ui_layer_update_coord(struct sun8i_mixer *mixer, int channel,
 	insize = SUN8I_MIXER_SIZE(src_w, src_h);
 	outsize = SUN8I_MIXER_SIZE(dst_w, dst_h);
 
+	if (plane->type == DRM_PLANE_TYPE_PRIMARY) {
+		bool interlaced = false;
+		u32 val;
+
+		DRM_DEBUG_DRIVER("Primary layer, updating global size W: %u H: %u\n",
+				 dst_w, dst_h);
+
+		if (mixer->cfg->de_type == sun8i_mixer_de33)
+			regmap_write(mixer->top_regs,
+				     SUN50I_MIXER_GLOBAL_SIZE, outsize);
+		else
+			regmap_write(mixer->engine.regs,
+				     SUN8I_MIXER_GLOBAL_SIZE, outsize);
+
+		regmap_write(bld_regs,
+			     SUN8I_MIXER_BLEND_OUTSIZE(bld_base), outsize);
+
+		if (state->crtc)
+			interlaced = state->crtc->state->adjusted_mode.flags
+				& DRM_MODE_FLAG_INTERLACE;
+
+		if (interlaced)
+			val = SUN8I_MIXER_BLEND_OUTCTL_INTERLACED;
+		else
+			val = 0;
+
+		regmap_update_bits(bld_regs,
+				   SUN8I_MIXER_BLEND_OUTCTL(bld_base),
+				   SUN8I_MIXER_BLEND_OUTCTL_INTERLACED,
+				   val);
+
+		DRM_DEBUG_DRIVER("Switching display mixer interlaced mode %s\n",
+				 interlaced ? "on" : "off");
+	}
+
 	/* Set height and width */
 	DRM_DEBUG_DRIVER("Layer source offset X: %d Y: %d\n",
 			 state->src.x1 >> 16, state->src.y1 >> 16);
@@ -175,9 +179,18 @@ static int sun8i_ui_layer_update_coord(struct sun8i_mixer *mixer, int channel,
 		hscale = state->src_w / state->crtc_w;
 		vscale = state->src_h / state->crtc_h;
 
-		sun8i_ui_scaler_setup(mixer, channel, src_w, src_h, dst_w,
-				      dst_h, hscale, vscale, hphase, vphase);
-		sun8i_ui_scaler_enable(mixer, channel, true);
+		if (mixer->cfg->de_type == sun8i_mixer_de33) {
+			sun8i_ui_scaler_setup(mixer, channel, src_w, src_h,
+					      dst_w, dst_h, hscale, vscale,
+					      hphase, vphase);
+			sun8i_ui_scaler_enable(mixer, channel, true);
+		} else {
+			sun8i_vi_scaler_setup(mixer, channel, src_w, src_h,
+					      dst_w, dst_h, hscale, vscale,
+					      hphase, vphase,
+					      state->fb->format);
+			sun8i_vi_scaler_enable(mixer, channel, true);
+		}
 	} else {
 		DRM_DEBUG_DRIVER("HW scaling is not needed\n");
 		sun8i_ui_scaler_enable(mixer, channel, false);
@@ -187,10 +200,10 @@ static int sun8i_ui_layer_update_coord(struct sun8i_mixer *mixer, int channel,
 	DRM_DEBUG_DRIVER("Layer destination coordinates X: %d Y: %d\n",
 			 state->dst.x1, state->dst.y1);
 	DRM_DEBUG_DRIVER("Layer destination size W: %d H: %d\n", dst_w, dst_h);
-	regmap_write(mixer->engine.regs,
+	regmap_write(bld_regs,
 		     SUN8I_MIXER_BLEND_ATTR_COORD(bld_base, zpos),
 		     SUN8I_MIXER_COORD(state->dst.x1, state->dst.y1));
-	regmap_write(mixer->engine.regs,
+	regmap_write(bld_regs,
 		     SUN8I_MIXER_BLEND_ATTR_INSIZE(bld_base, zpos),
 		     outsize);
 
@@ -203,7 +216,6 @@ static int sun8i_ui_layer_update_formats(struct sun8i_mixer *mixer, int channel,
 	struct drm_plane_state *state = plane->state;
 	const struct drm_format_info *fmt;
 	u32 val, ch_base, hw_fmt;
-	unsigned tmp;
 	int ret;
 
 	ch_base = sun8i_channel_base(mixer, channel);
@@ -215,19 +227,11 @@ static int sun8i_ui_layer_update_formats(struct sun8i_mixer *mixer, int channel,
 		return -EINVAL;
 	}
 
-	regmap_read(mixer->engine.regs,
-			   SUN8I_MIXER_CHAN_UI_LAYER_ATTR(ch_base, overlay), &tmp);
-	DRM_DEBUG_DRIVER("  pre-format %08x\n", tmp);
-
 	val = hw_fmt << SUN8I_MIXER_CHAN_UI_LAYER_ATTR_FBFMT_OFFSET;
 	regmap_update_bits(mixer->engine.regs,
 			   SUN8I_MIXER_CHAN_UI_LAYER_ATTR(ch_base, overlay),
 			   SUN8I_MIXER_CHAN_UI_LAYER_ATTR_FBFMT_MASK, val);
 
-	regmap_read(mixer->engine.regs,
-			   SUN8I_MIXER_CHAN_UI_LAYER_ATTR(ch_base, overlay), &tmp);
-	DRM_DEBUG_DRIVER("  post-format %08x\n", tmp);
-
 	return 0;
 }
 
@@ -303,6 +307,19 @@ static int sun8i_ui_layer_atomic_check(struct drm_plane *plane,
 						   true, true);
 }
 
+static void sun8i_ui_layer_atomic_disable(struct drm_plane *plane,
+					  struct drm_atomic_state *state)
+{
+	struct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,
+									   plane);
+	struct sun8i_ui_layer *layer = plane_to_sun8i_ui_layer(plane);
+	unsigned int old_zpos = old_state->normalized_zpos;
+	struct sun8i_mixer *mixer = layer->mixer;
+
+	sun8i_ui_layer_enable(mixer, layer->channel, layer->overlay, false, 0,
+			      old_zpos);
+}
+
 static void sun8i_ui_layer_atomic_update(struct drm_plane *plane,
 					 struct drm_atomic_state *state)
 {
@@ -314,37 +331,28 @@ static void sun8i_ui_layer_atomic_update(struct drm_plane *plane,
 	unsigned int zpos = new_state->normalized_zpos;
 	unsigned int old_zpos = old_state->normalized_zpos;
 	struct sun8i_mixer *mixer = layer->mixer;
-	bool was_enabled = old_state->crtc && old_state->visible;
-	bool enable = new_state->crtc && new_state->visible;
 
-	if (enable) {
-		sun8i_ui_layer_update_coord(mixer, layer->channel,
-					    layer->overlay, plane, zpos);
-		sun8i_ui_layer_update_alpha(mixer, layer->channel,
-					    layer->overlay, plane);
-		sun8i_ui_layer_update_formats(mixer, layer->channel,
-					      layer->overlay, plane);
-		sun8i_ui_layer_update_buffer(mixer, layer->channel,
-					     layer->overlay, plane);
+	if (!new_state->visible) {
+		sun8i_ui_layer_enable(mixer, layer->channel,
+				      layer->overlay, false, 0, old_zpos);
+		return;
 	}
 
+	sun8i_ui_layer_update_coord(mixer, layer->channel,
+				    layer->overlay, plane, zpos);
+	sun8i_ui_layer_update_alpha(mixer, layer->channel,
+				    layer->overlay, plane);
+	sun8i_ui_layer_update_formats(mixer, layer->channel,
+				      layer->overlay, plane);
+	sun8i_ui_layer_update_buffer(mixer, layer->channel,
+				     layer->overlay, plane);
 	sun8i_ui_layer_enable(mixer, layer->channel, layer->overlay,
-			      was_enabled, enable, zpos, old_zpos);
-}
-
-void sun8i_ui_layer_plane_reset(struct drm_plane *plane)
-{
-	struct sun8i_ui_layer *layer = plane_to_sun8i_ui_layer(plane);
-
-	drm_atomic_helper_plane_reset(plane);
-	if (!plane->state)
-		return;
-
-	plane->state->zpos = layer->channel;
+			      true, zpos, old_zpos);
 }
 
 static const struct drm_plane_helper_funcs sun8i_ui_layer_helper_funcs = {
 	.atomic_check	= sun8i_ui_layer_atomic_check,
+	.atomic_disable	= sun8i_ui_layer_atomic_disable,
 	.atomic_update	= sun8i_ui_layer_atomic_update,
 };
 
@@ -353,7 +361,7 @@ static const struct drm_plane_funcs sun8i_ui_layer_funcs = {
 	.atomic_duplicate_state	= drm_atomic_helper_plane_duplicate_state,
 	.destroy		= drm_plane_cleanup,
 	.disable_plane		= drm_atomic_helper_disable_plane,
-	.reset			= sun8i_ui_layer_plane_reset,
+	.reset			= drm_atomic_helper_plane_reset,
 	.update_plane		= drm_atomic_helper_update_plane,
 };
 
@@ -387,9 +395,9 @@ static const uint64_t sun8i_layer_modifiers[] = {
 
 struct sun8i_ui_layer *sun8i_ui_layer_init_one(struct drm_device *drm,
 					       struct sun8i_mixer *mixer,
-					       int index,
-					       enum drm_plane_type type)
+					       int index)
 {
+	enum drm_plane_type type = DRM_PLANE_TYPE_OVERLAY;
 	int channel = mixer->cfg->vi_num + index;
 	struct sun8i_ui_layer *layer;
 	unsigned int plane_cnt;
@@ -399,6 +407,9 @@ struct sun8i_ui_layer *sun8i_ui_layer_init_one(struct drm_device *drm,
 	if (!layer)
 		return ERR_PTR(-ENOMEM);
 
+	if (index == 0)
+		type = DRM_PLANE_TYPE_PRIMARY;
+
 	/* possible crtcs are set later */
 	ret = drm_universal_plane_init(drm, &layer->plane, 0,
 				       &sun8i_ui_layer_funcs,
diff --git a/drivers/gpu/drm/sun4i/sun8i_ui_layer.h b/drivers/gpu/drm/sun4i/sun8i_ui_layer.h
index 552703b9f..e3e32ee11 100644
--- a/drivers/gpu/drm/sun4i/sun8i_ui_layer.h
+++ b/drivers/gpu/drm/sun4i/sun8i_ui_layer.h
@@ -63,6 +63,5 @@ plane_to_sun8i_ui_layer(struct drm_plane *plane)
 
 struct sun8i_ui_layer *sun8i_ui_layer_init_one(struct drm_device *drm,
 					       struct sun8i_mixer *mixer,
-					       int index,
-					       enum drm_plane_type type);
+					       int index);
 #endif /* _SUN8I_UI_LAYER_H_ */
diff --git a/drivers/gpu/drm/sun4i/sun8i_ui_scaler.c b/drivers/gpu/drm/sun4i/sun8i_ui_scaler.c
index ae0806bcc..504ffa097 100644
--- a/drivers/gpu/drm/sun4i/sun8i_ui_scaler.c
+++ b/drivers/gpu/drm/sun4i/sun8i_ui_scaler.c
@@ -93,7 +93,7 @@ static u32 sun8i_ui_scaler_base(struct sun8i_mixer *mixer, int channel)
 {
 	int vi_num = mixer->cfg->vi_num;
 
-	if (mixer->cfg->is_de3)
+	if (mixer->cfg->de_type == sun8i_mixer_de3)
 		return DE3_VI_SCALER_UNIT_BASE +
 		       DE3_VI_SCALER_UNIT_SIZE * vi_num +
 		       DE3_UI_SCALER_UNIT_SIZE * (channel - vi_num);
diff --git a/drivers/gpu/drm/sun4i/sun8i_vi_layer.c b/drivers/gpu/drm/sun4i/sun8i_vi_layer.c
index 266379896..fe39b5cde 100644
--- a/drivers/gpu/drm/sun4i/sun8i_vi_layer.c
+++ b/drivers/gpu/drm/sun4i/sun8i_vi_layer.c
@@ -18,88 +18,54 @@
 #include "sun8i_vi_scaler.h"
 
 static void sun8i_vi_layer_enable(struct sun8i_mixer *mixer, int channel,
-				  int overlay, bool was_enabled, bool enable,
-				  unsigned int zpos, unsigned int old_zpos)
+				  int overlay, bool enable, unsigned int zpos,
+				  unsigned int old_zpos)
 {
 	u32 val, bld_base, ch_base;
-	unsigned int old_pipe_ch;
-	unsigned  tmp;
+	struct regmap *bld_regs;
 
 	bld_base = sun8i_blender_base(mixer);
+	bld_regs = sun8i_blender_regmap(mixer);
 	ch_base = sun8i_channel_base(mixer, channel);
 
 	DRM_DEBUG_DRIVER("%sabling VI channel %d overlay %d\n",
 			 enable ? "En" : "Dis", channel, overlay);
 
-	/* We always update the layer enable bit, because it can clear
-	 * spontaneously for unknown reasons. */
-	val = enable ? SUN8I_MIXER_CHAN_VI_LAYER_ATTR_EN : 0;
+	if (enable)
+		val = SUN8I_MIXER_CHAN_VI_LAYER_ATTR_EN;
+	else
+		val = 0;
+
 	regmap_update_bits(mixer->engine.regs,
 			   SUN8I_MIXER_CHAN_VI_LAYER_ATTR(ch_base, overlay),
 			   SUN8I_MIXER_CHAN_VI_LAYER_ATTR_EN, val);
 
-	/*
-	 * If this layer was enabled and is being disabled or if it is
-	 * enabled and just changing zpos, clear the old route, if it is
-	 * still configured to this layer in HW.
-	 */
-	if ((was_enabled && !enable) || (enable && zpos != old_zpos)) {
-		/* get channel the pipe for old_zpos is routed to from the HW */
-		regmap_read(mixer->engine.regs,
+	if (!enable || zpos != old_zpos) {
+		regmap_update_bits(bld_regs,
+				   SUN8I_MIXER_BLEND_PIPE_CTL(bld_base),
+				   SUN8I_MIXER_BLEND_PIPE_CTL_EN(old_zpos),
+				   0);
+
+		regmap_update_bits(bld_regs,
 				   SUN8I_MIXER_BLEND_ROUTE(bld_base),
-				   &old_pipe_ch);
-		old_pipe_ch &= SUN8I_MIXER_BLEND_ROUTE_PIPE_MSK(old_zpos);
-		old_pipe_ch >>= SUN8I_MIXER_BLEND_ROUTE_PIPE_SHIFT(old_zpos);
-
-		/*
-		 * Check that pipe for old_zpos is still routed to our layer,
-		 * and clear/disable it if it is.
-		 */
-
-		if (old_pipe_ch == channel) {
-			DRM_DEBUG_DRIVER("chan=%d en=%d->%d zpos=%d->%d\n",
-			       channel, was_enabled, enable, old_zpos, zpos);
-
-			DRM_DEBUG_DRIVER("  disable pipe %d\n", old_zpos);
-
-			regmap_update_bits(mixer->engine.regs,
-					   SUN8I_MIXER_BLEND_ROUTE(bld_base),
-					   SUN8I_MIXER_BLEND_ROUTE_PIPE_MSK(old_zpos),
-					   0);
-
-			regmap_update_bits(mixer->engine.regs,
-					   SUN8I_MIXER_BLEND_PIPE_CTL(bld_base),
-					   SUN8I_MIXER_BLEND_PIPE_CTL_EN(old_zpos),
-					   0);
-		}
+				   SUN8I_MIXER_BLEND_ROUTE_PIPE_MSK(old_zpos),
+				   0);
 	}
 
-	/*
-	 * If enabling this layer or changin zpos, set route to this layer.
-	 */
-	if ((enable && !was_enabled) || (enable && zpos != old_zpos)) {
-		DRM_DEBUG_DRIVER("chan=%d en=%d->%d zpos=%d->%d\n",
-		       channel, was_enabled, enable, old_zpos, zpos);
-
+	if (enable) {
 		val = SUN8I_MIXER_BLEND_PIPE_CTL_EN(zpos);
 
-		regmap_update_bits(mixer->engine.regs,
+		regmap_update_bits(bld_regs,
 				   SUN8I_MIXER_BLEND_PIPE_CTL(bld_base),
 				   val, val);
 
 		val = channel << SUN8I_MIXER_BLEND_ROUTE_PIPE_SHIFT(zpos);
 
-		regmap_update_bits(mixer->engine.regs,
+		regmap_update_bits(bld_regs,
 				   SUN8I_MIXER_BLEND_ROUTE(bld_base),
 				   SUN8I_MIXER_BLEND_ROUTE_PIPE_MSK(zpos),
 				   val);
-
-		DRM_DEBUG_DRIVER("  enable pipe %d <- ch %d\n", zpos, channel);
 	}
-
-	regmap_read(mixer->engine.regs,
-			   SUN8I_MIXER_CHAN_VI_LAYER_ATTR(ch_base, overlay), &tmp);
-	DRM_DEBUG_DRIVER("  post-en-dis %08x\n", tmp);
 }
 
 static void sun8i_vi_layer_update_alpha(struct sun8i_mixer *mixer, int channel,
@@ -109,7 +75,7 @@ static void sun8i_vi_layer_update_alpha(struct sun8i_mixer *mixer, int channel,
 
 	ch_base = sun8i_channel_base(mixer, channel);
 
-	if (mixer->cfg->is_de3) {
+	if (mixer->cfg->de_type >= sun8i_mixer_de3) {
 		mask = SUN50I_MIXER_CHAN_VI_LAYER_ATTR_ALPHA_MASK |
 		       SUN50I_MIXER_CHAN_VI_LAYER_ATTR_ALPHA_MODE_MASK;
 		val = SUN50I_MIXER_CHAN_VI_LAYER_ATTR_ALPHA
@@ -139,6 +105,7 @@ static int sun8i_vi_layer_update_coord(struct sun8i_mixer *mixer, int channel,
 	struct drm_plane_state *state = plane->state;
 	const struct drm_format_info *format = state->fb->format;
 	u32 src_w, src_h, dst_w, dst_h;
+	struct regmap *bld_regs;
 	u32 bld_base, ch_base;
 	u32 outsize, insize;
 	u32 hphase, vphase;
@@ -150,6 +117,7 @@ static int sun8i_vi_layer_update_coord(struct sun8i_mixer *mixer, int channel,
 			 channel, overlay);
 
 	bld_base = sun8i_blender_base(mixer);
+	bld_regs = sun8i_blender_regmap(mixer);
 	ch_base = sun8i_channel_base(mixer, channel);
 
 	src_w = drm_rect_width(&state->src) >> 16;
@@ -267,10 +235,10 @@ static int sun8i_vi_layer_update_coord(struct sun8i_mixer *mixer, int channel,
 	DRM_DEBUG_DRIVER("Layer destination coordinates X: %d Y: %d\n",
 			 state->dst.x1, state->dst.y1);
 	DRM_DEBUG_DRIVER("Layer destination size W: %d H: %d\n", dst_w, dst_h);
-	regmap_write(mixer->engine.regs,
+	regmap_write(bld_regs,
 		     SUN8I_MIXER_BLEND_ATTR_COORD(bld_base, zpos),
 		     SUN8I_MIXER_COORD(state->dst.x1, state->dst.y1));
-	regmap_write(mixer->engine.regs,
+	regmap_write(bld_regs,
 		     SUN8I_MIXER_BLEND_ATTR_INSIZE(bld_base, zpos),
 		     outsize);
 
@@ -299,7 +267,6 @@ static int sun8i_vi_layer_update_formats(struct sun8i_mixer *mixer, int channel,
 	struct drm_plane_state *state = plane->state;
 	u32 val, ch_base, csc_mode, hw_fmt;
 	const struct drm_format_info *fmt;
-	unsigned  tmp;
 	int ret;
 
 	ch_base = sun8i_channel_base(mixer, channel);
@@ -311,19 +278,11 @@ static int sun8i_vi_layer_update_formats(struct sun8i_mixer *mixer, int channel,
 		return ret;
 	}
 
-	regmap_read(mixer->engine.regs,
-			   SUN8I_MIXER_CHAN_VI_LAYER_ATTR(ch_base, overlay), &tmp);
-	DRM_DEBUG_DRIVER("  pre-format %08x\n", tmp);
-
 	val = hw_fmt << SUN8I_MIXER_CHAN_VI_LAYER_ATTR_FBFMT_OFFSET;
 	regmap_update_bits(mixer->engine.regs,
 			   SUN8I_MIXER_CHAN_VI_LAYER_ATTR(ch_base, overlay),
 			   SUN8I_MIXER_CHAN_VI_LAYER_ATTR_FBFMT_MASK, val);
 
-	regmap_read(mixer->engine.regs,
-			   SUN8I_MIXER_CHAN_VI_LAYER_ATTR(ch_base, overlay), &tmp);
-	DRM_DEBUG_DRIVER("  mid1-format %08x\n", tmp);
-
 	csc_mode = sun8i_vi_layer_get_csc_mode(fmt);
 	if (csc_mode != SUN8I_CSC_MODE_OFF) {
 		sun8i_csc_set_ccsc_coefficients(mixer, channel, csc_mode,
@@ -334,10 +293,6 @@ static int sun8i_vi_layer_update_formats(struct sun8i_mixer *mixer, int channel,
 		sun8i_csc_enable_ccsc(mixer, channel, false);
 	}
 
-	regmap_read(mixer->engine.regs,
-			   SUN8I_MIXER_CHAN_VI_LAYER_ATTR(ch_base, overlay), &tmp);
-	DRM_DEBUG_DRIVER("  mid2-format %08x\n", tmp);
-
 	if (!fmt->is_yuv)
 		val = SUN8I_MIXER_CHAN_VI_LAYER_ATTR_RGB_MODE;
 	else
@@ -347,10 +302,6 @@ static int sun8i_vi_layer_update_formats(struct sun8i_mixer *mixer, int channel,
 			   SUN8I_MIXER_CHAN_VI_LAYER_ATTR(ch_base, overlay),
 			   SUN8I_MIXER_CHAN_VI_LAYER_ATTR_RGB_MODE, val);
 
-	regmap_read(mixer->engine.regs,
-			   SUN8I_MIXER_CHAN_VI_LAYER_ATTR(ch_base, overlay), &tmp);
-	DRM_DEBUG_DRIVER("  post-format %08x\n", tmp);
-
 	return 0;
 }
 
@@ -445,6 +396,19 @@ static int sun8i_vi_layer_atomic_check(struct drm_plane *plane,
 						   true, true);
 }
 
+static void sun8i_vi_layer_atomic_disable(struct drm_plane *plane,
+					  struct drm_atomic_state *state)
+{
+	struct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,
+									   plane);
+	struct sun8i_vi_layer *layer = plane_to_sun8i_vi_layer(plane);
+	unsigned int old_zpos = old_state->normalized_zpos;
+	struct sun8i_mixer *mixer = layer->mixer;
+
+	sun8i_vi_layer_enable(mixer, layer->channel, layer->overlay, false, 0,
+			      old_zpos);
+}
+
 static void sun8i_vi_layer_atomic_update(struct drm_plane *plane,
 					 struct drm_atomic_state *state)
 {
@@ -456,37 +420,28 @@ static void sun8i_vi_layer_atomic_update(struct drm_plane *plane,
 	unsigned int zpos = new_state->normalized_zpos;
 	unsigned int old_zpos = old_state->normalized_zpos;
 	struct sun8i_mixer *mixer = layer->mixer;
-	bool was_enabled = old_state->crtc && old_state->visible;
-	bool enable = new_state->crtc && new_state->visible;
 
-	if (enable) {
-		sun8i_vi_layer_update_coord(mixer, layer->channel,
-					    layer->overlay, plane, zpos);
-		sun8i_vi_layer_update_alpha(mixer, layer->channel,
-					    layer->overlay, plane);
-		sun8i_vi_layer_update_formats(mixer, layer->channel,
-					      layer->overlay, plane);
-		sun8i_vi_layer_update_buffer(mixer, layer->channel,
-					     layer->overlay, plane);
+	if (!new_state->visible) {
+		sun8i_vi_layer_enable(mixer, layer->channel,
+				      layer->overlay, false, 0, old_zpos);
+		return;
 	}
 
+	sun8i_vi_layer_update_coord(mixer, layer->channel,
+				    layer->overlay, plane, zpos);
+	sun8i_vi_layer_update_alpha(mixer, layer->channel,
+				    layer->overlay, plane);
+	sun8i_vi_layer_update_formats(mixer, layer->channel,
+				      layer->overlay, plane);
+	sun8i_vi_layer_update_buffer(mixer, layer->channel,
+				     layer->overlay, plane);
 	sun8i_vi_layer_enable(mixer, layer->channel, layer->overlay,
-			      was_enabled, enable, zpos, old_zpos);
-}
-
-void sun8i_vi_layer_plane_reset(struct drm_plane *plane)
-{
-	struct sun8i_vi_layer *layer = plane_to_sun8i_vi_layer(plane);
-
-	drm_atomic_helper_plane_reset(plane);
-	if (!plane->state)
-		return;
-
-	plane->state->zpos = layer->channel;
+			      true, zpos, old_zpos);
 }
 
 static const struct drm_plane_helper_funcs sun8i_vi_layer_helper_funcs = {
 	.atomic_check	= sun8i_vi_layer_atomic_check,
+	.atomic_disable	= sun8i_vi_layer_atomic_disable,
 	.atomic_update	= sun8i_vi_layer_atomic_update,
 };
 
@@ -495,7 +450,7 @@ static const struct drm_plane_funcs sun8i_vi_layer_funcs = {
 	.atomic_duplicate_state	= drm_atomic_helper_plane_duplicate_state,
 	.destroy		= drm_plane_cleanup,
 	.disable_plane		= drm_atomic_helper_disable_plane,
-	.reset			= sun8i_vi_layer_plane_reset,
+	.reset			= drm_atomic_helper_plane_reset,
 	.update_plane		= drm_atomic_helper_update_plane,
 };
 
@@ -602,7 +557,7 @@ struct sun8i_vi_layer *sun8i_vi_layer_init_one(struct drm_device *drm,
 	if (!layer)
 		return ERR_PTR(-ENOMEM);
 
-	if (mixer->cfg->is_de3) {
+	if (mixer->cfg->de_type >= sun8i_mixer_de3) {
 		formats = sun8i_vi_layer_de3_formats;
 		format_count = ARRAY_SIZE(sun8i_vi_layer_de3_formats);
 	} else {
@@ -626,7 +581,7 @@ struct sun8i_vi_layer *sun8i_vi_layer_init_one(struct drm_device *drm,
 
 	plane_cnt = mixer->cfg->ui_num + mixer->cfg->vi_num;
 
-	if (mixer->cfg->vi_num == 1 || mixer->cfg->is_de3) {
+	if (mixer->cfg->vi_num == 1 || mixer->cfg->de_type >= sun8i_mixer_de3) {
 		ret = drm_plane_create_alpha_property(&layer->plane);
 		if (ret) {
 			dev_err(drm->dev, "Couldn't add alpha property\n");
@@ -643,7 +598,7 @@ struct sun8i_vi_layer *sun8i_vi_layer_init_one(struct drm_device *drm,
 
 	supported_encodings = BIT(DRM_COLOR_YCBCR_BT601) |
 			      BIT(DRM_COLOR_YCBCR_BT709);
-	if (mixer->cfg->is_de3)
+	if (mixer->cfg->de_type >= sun8i_mixer_de3)
 		supported_encodings |= BIT(DRM_COLOR_YCBCR_BT2020);
 
 	supported_ranges = BIT(DRM_COLOR_YCBCR_LIMITED_RANGE) |
diff --git a/drivers/gpu/drm/sun4i/sun8i_vi_scaler.c b/drivers/gpu/drm/sun4i/sun8i_vi_scaler.c
index 7ba75011a..6839fd5ab 100644
--- a/drivers/gpu/drm/sun4i/sun8i_vi_scaler.c
+++ b/drivers/gpu/drm/sun4i/sun8i_vi_scaler.c
@@ -835,7 +835,9 @@ static const u32 bicubic4coefftab32[480] = {
 
 static u32 sun8i_vi_scaler_base(struct sun8i_mixer *mixer, int channel)
 {
-	if (mixer->cfg->is_de3)
+	if (mixer->cfg->de_type == sun8i_mixer_de33)
+		return sun8i_channel_base(mixer, channel) + 0x3000;
+	else if (mixer->cfg->de_type == sun8i_mixer_de3)
 		return DE3_VI_SCALER_UNIT_BASE +
 		       DE3_VI_SCALER_UNIT_SIZE * channel;
 	else
@@ -956,7 +958,7 @@ void sun8i_vi_scaler_setup(struct sun8i_mixer *mixer, int layer,
 		cvphase = vphase;
 	}
 
-	if (mixer->cfg->is_de3) {
+	if (mixer->cfg->de_type >= sun8i_mixer_de3) {
 		u32 val;
 
 		if (format->hsub == 1 && format->vsub == 1)
diff --git a/drivers/gpu/drm/sun4i/sunxi_engine.h b/drivers/gpu/drm/sun4i/sunxi_engine.h
index ec8cf9b2b..548710a93 100644
--- a/drivers/gpu/drm/sun4i/sunxi_engine.h
+++ b/drivers/gpu/drm/sun4i/sunxi_engine.h
@@ -9,7 +9,6 @@
 struct drm_plane;
 struct drm_device;
 struct drm_crtc_state;
-struct drm_display_mode;
 
 struct sunxi_engine;
 
@@ -109,17 +108,6 @@ struct sunxi_engine_ops {
 	 * This function is optional.
 	 */
 	void (*vblank_quirk)(struct sunxi_engine *engine);
-
-	/**
-	 * @mode_set
-	 *
-	 * This callback is used to set mode related parameters
-	 * like interlacing, screen size, etc. once per mode set.
-	 *
-	 * This function is optional.
-	 */
-	void (*mode_set)(struct sunxi_engine *engine,
-			 const struct drm_display_mode *mode);
 };
 
 /**
@@ -193,19 +181,4 @@ sunxi_engine_disable_color_correction(struct sunxi_engine *engine)
 	if (engine->ops && engine->ops->disable_color_correction)
 		engine->ops->disable_color_correction(engine);
 }
-
-/**
- * sunxi_engine_mode_set - Inform engine of a new mode
- * @engine:	pointer to the engine
- * @mode:	new mode
- *
- * Engine can use this functionality to set specifics once per mode change.
- */
-static inline void
-sunxi_engine_mode_set(struct sunxi_engine *engine,
-		      const struct drm_display_mode *mode)
-{
-	if (engine->ops && engine->ops->mode_set)
-		engine->ops->mode_set(engine, mode);
-}
 #endif /* _SUNXI_ENGINE_H_ */
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index e86584db6..4b9fcd45e 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -142,9 +142,8 @@ obj-$(CONFIG_MFD_DA9052_I2C)	+= da9052-i2c.o
 
 obj-$(CONFIG_MFD_AC100)		+= ac100.o
 obj-$(CONFIG_MFD_AC200)		+= sunxi-ac200.o
-obj-$(CONFIG_MFD_AXP20X)	+= axp20x.o
-obj-$(CONFIG_MFD_AXP20X_I2C)	+= axp20x-i2c.o
-obj-$(CONFIG_MFD_AXP20X_RSB)	+= axp20x-rsb.o
+obj-$(CONFIG_MFD_AXP20X)	+= axp2101.o
+obj-$(CONFIG_MFD_AXP20X_I2C)	+= axp2101-i2c.o
 
 obj-$(CONFIG_MFD_LP3943)	+= lp3943.o
 obj-$(CONFIG_MFD_LP8788)	+= lp8788.o lp8788-irq.o
diff --git a/drivers/mfd/axp2101-i2c.c b/drivers/mfd/axp2101-i2c.c
new file mode 100644
index 000000000..afe063789
--- /dev/null
+++ b/drivers/mfd/axp2101-i2c.c
@@ -0,0 +1,130 @@
+/*
+ * I2C driver for the X-Powers' Power Management ICs
+ *
+ * AXP20x typically comprises an adaptive USB-Compatible PWM charger, BUCK DC-DC
+ * converters, LDOs, multiple 12-bit ADCs of voltage, current and temperature
+ * as well as configurable GPIOs.
+ *
+ * This driver supports the I2C variants.
+ *
+ * Copyright (C) 2014 Carlo Caione
+ *
+ * Author: Carlo Caione <carlo@caione.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/acpi.h>
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/mfd/axp2101.h>
+#include <linux/of.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+
+static int axp20x_i2c_probe(struct i2c_client *i2c,
+			    const struct i2c_device_id *id)
+{
+	struct axp20x_dev *axp20x;
+	int ret;
+
+	axp20x = devm_kzalloc(&i2c->dev, sizeof(*axp20x), GFP_KERNEL);
+	if (!axp20x)
+		return -ENOMEM;
+
+	axp20x->dev = &i2c->dev;
+	axp20x->irq = i2c->irq;
+	dev_set_drvdata(axp20x->dev, axp20x);
+
+	ret = axp20x_match_device(axp20x);
+	if (ret)
+		return ret;
+
+	axp20x->regmap = devm_regmap_init_i2c(i2c, axp20x->regmap_cfg);
+	if (IS_ERR(axp20x->regmap)) {
+		ret = PTR_ERR(axp20x->regmap);
+		dev_err(&i2c->dev, "regmap init failed: %d\n", ret);
+		return ret;
+	}
+
+	return axp20x_device_probe(axp20x);
+}
+
+static int axp20x_i2c_remove(struct i2c_client *i2c)
+{
+	struct axp20x_dev *axp20x = i2c_get_clientdata(i2c);
+
+	return axp20x_device_remove(axp20x);
+}
+
+static const struct of_device_id axp20x_i2c_of_match[] = {
+	{ .compatible = "x-powers,axp152", .data = (void *)AXP152_ID },
+	{ .compatible = "x-powers,axp202", .data = (void *)AXP202_ID },
+	{ .compatible = "x-powers,axp209", .data = (void *)AXP209_ID },
+	{ .compatible = "x-powers,axp221", .data = (void *)AXP221_ID },
+	{ .compatible = "x-powers,axp2101", .data = (void *)AXP2101_ID },
+	{ .compatible = "x-powers,axp15", .data = (void *)AXP15_ID },
+	{ .compatible = "x-powers,axp1530", .data = (void *)AXP1530_ID },
+	{ .compatible = "x-powers,axp858", .data = (void *)AXP858_ID },
+	{ .compatible = "x-powers,axp803", .data = (void *)AXP803_ID },
+	{ .compatible = "x-powers,axp2202", .data = (void *)AXP2202_ID },
+	{ .compatible = "x-powers,axp806", .data = (void *)AXP806_ID },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, axp20x_i2c_of_match);
+
+/*
+ * This is useless for OF-enabled devices, but it is needed by I2C subsystem
+ */
+static const struct i2c_device_id axp20x_i2c_id[] = {
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, axp20x_i2c_id);
+
+static const struct acpi_device_id axp20x_i2c_acpi_match[] = {
+	{
+		.id = "INT33F4",
+		.driver_data = AXP288_ID,
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(acpi, axp20x_i2c_acpi_match);
+
+static struct i2c_driver axp2101_i2c_driver = {
+	.driver = {
+		.name	= "axp20x-i2c",
+		.of_match_table	= of_match_ptr(axp20x_i2c_of_match),
+		.acpi_match_table = ACPI_PTR(axp20x_i2c_acpi_match),
+	},
+	.probe		= axp20x_i2c_probe,
+	.remove		= axp20x_i2c_remove,
+	.id_table	= axp20x_i2c_id,
+};
+
+static int __init axp2101_i2c_init(void)
+{
+	int ret;
+
+	ret = i2c_add_driver(&axp2101_i2c_driver);
+	if (ret != 0) {
+		pr_err("axp2101 i2c registration failed %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+subsys_initcall(axp2101_i2c_init);
+
+static void __exit axp2101_i2c_exit(void)
+{
+	i2c_del_driver(&axp2101_i2c_driver);
+}
+module_exit(axp2101_i2c_exit);
+
+MODULE_DESCRIPTION("PMIC MFD I2C driver for AXP20X");
+MODULE_AUTHOR("Carlo Caione <carlo@caione.org>");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/mfd/axp2101.c b/drivers/mfd/axp2101.c
new file mode 100644
index 000000000..e61ca4679
--- /dev/null
+++ b/drivers/mfd/axp2101.c
@@ -0,0 +1,2570 @@
+/*
+ * MFD core driver for the X-Powers' Power Management ICs
+ *
+ * AXP20x typically comprises an adaptive USB-Compatible PWM charger, BUCK DC-DC
+ * converters, LDOs, multiple 12-bit ADCs of voltage, current and temperature
+ * as well as configurable GPIOs.
+ *
+ * This file contains the interface independent core functions.
+ *
+ * Copyright (C) 2014 Carlo Caione
+ *
+ * Author: Carlo Caione <carlo@caione.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/mfd/axp2101.h>
+#include <linux/mfd/core.h>
+#include <linux/of_device.h>
+#include <linux/acpi.h>
+
+#define AXP20X_OFF	0x80
+
+static const char *const axp20x_model_names[] = {
+	"AXP152", "AXP202", "AXP209", "AXP221",  "AXP223",
+	"AXP288", "AXP806", "AXP809", "AXP2101", "AXP15",
+	"AXP1530", "AXP858", "AXP803", "AXP2202",
+};
+
+static const struct regmap_range axp152_writeable_ranges[] = {
+	regmap_reg_range(AXP152_LDO3456_DC1234_CTRL, AXP152_IRQ3_STATE),
+	regmap_reg_range(AXP152_DCDC_MODE, AXP152_PWM1_DUTY_CYCLE),
+};
+
+static const struct regmap_range axp152_volatile_ranges[] = {
+	regmap_reg_range(AXP152_PWR_OP_MODE, AXP152_PWR_OP_MODE),
+	regmap_reg_range(AXP152_IRQ1_EN, AXP152_IRQ3_STATE),
+	regmap_reg_range(AXP152_GPIO_INPUT, AXP152_GPIO_INPUT),
+};
+
+static const struct regmap_access_table axp152_writeable_table = {
+	.yes_ranges	= axp152_writeable_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(axp152_writeable_ranges),
+};
+
+static const struct regmap_access_table axp152_volatile_table = {
+	.yes_ranges	= axp152_volatile_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(axp152_volatile_ranges),
+};
+
+static const struct regmap_range axp20x_writeable_ranges[] = {
+	regmap_reg_range(AXP20X_DATACACHE(0), AXP20X_IRQ5_STATE),
+	regmap_reg_range(AXP20X_DCDC_MODE, AXP20X_FG_RES),
+	regmap_reg_range(AXP20X_RDC_H, AXP20X_OCV(AXP20X_OCV_MAX)),
+};
+
+static const struct regmap_range axp20x_volatile_ranges[] = {
+	regmap_reg_range(AXP20X_PWR_INPUT_STATUS, AXP20X_USB_OTG_STATUS),
+	regmap_reg_range(AXP20X_CHRG_CTRL1, AXP20X_CHRG_CTRL2),
+	regmap_reg_range(AXP20X_IRQ1_EN, AXP20X_IRQ5_STATE),
+	regmap_reg_range(AXP20X_ACIN_V_ADC_H, AXP20X_IPSOUT_V_HIGH_L),
+	regmap_reg_range(AXP20X_GPIO20_SS, AXP20X_GPIO3_CTRL),
+	regmap_reg_range(AXP20X_FG_RES, AXP20X_RDC_L),
+};
+
+static const struct regmap_access_table axp20x_writeable_table = {
+	.yes_ranges	= axp20x_writeable_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(axp20x_writeable_ranges),
+};
+
+static const struct regmap_access_table axp20x_volatile_table = {
+	.yes_ranges	= axp20x_volatile_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(axp20x_volatile_ranges),
+};
+
+/* AXP22x ranges are shared with the AXP809, as they cover the same range */
+static const struct regmap_range axp22x_writeable_ranges[] = {
+	regmap_reg_range(AXP20X_DATACACHE(0), AXP20X_IRQ5_STATE),
+	regmap_reg_range(AXP20X_DCDC_MODE, AXP22X_BATLOW_THRES1),
+};
+
+static const struct regmap_range axp22x_volatile_ranges[] = {
+	regmap_reg_range(AXP20X_PWR_INPUT_STATUS, AXP20X_PWR_OP_MODE),
+	regmap_reg_range(AXP20X_IRQ1_EN, AXP20X_IRQ5_STATE),
+	regmap_reg_range(AXP22X_GPIO_STATE, AXP22X_GPIO_STATE),
+	regmap_reg_range(AXP20X_FG_RES, AXP20X_FG_RES),
+};
+
+static const struct regmap_access_table axp22x_writeable_table = {
+	.yes_ranges	= axp22x_writeable_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(axp22x_writeable_ranges),
+};
+
+static const struct regmap_access_table axp22x_volatile_table = {
+	.yes_ranges	= axp22x_volatile_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(axp22x_volatile_ranges),
+};
+
+static const struct regmap_range axp288_writeable_ranges[] = {
+	regmap_reg_range(AXP20X_DATACACHE(0), AXP20X_IRQ6_STATE),
+	regmap_reg_range(AXP20X_DCDC_MODE, AXP288_FG_TUNE5),
+};
+
+static const struct regmap_range axp288_volatile_ranges[] = {
+	regmap_reg_range(AXP20X_IRQ1_EN, AXP20X_IPSOUT_V_HIGH_L),
+};
+
+static const struct regmap_access_table axp288_writeable_table = {
+	.yes_ranges	= axp288_writeable_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(axp288_writeable_ranges),
+};
+
+static const struct regmap_access_table axp288_volatile_table = {
+	.yes_ranges	= axp288_volatile_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(axp288_volatile_ranges),
+};
+
+static const struct regmap_range axp806_writeable_ranges[] = {
+	regmap_reg_range(AXP806_STARTUP_SRC, AXP806_REG_ADDR_EXT),
+};
+
+static const struct regmap_range axp806_volatile_ranges[] = {
+	regmap_reg_range(AXP20X_IRQ1_STATE, AXP20X_IRQ2_STATE),
+};
+
+static const struct regmap_access_table axp806_writeable_table = {
+	.yes_ranges	= axp806_writeable_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(axp806_writeable_ranges),
+};
+
+static const struct regmap_access_table axp806_volatile_table = {
+	.yes_ranges	= axp806_volatile_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(axp806_volatile_ranges),
+};
+
+static const struct regmap_range axp2101_writeable_ranges[] = {
+	regmap_reg_range(AXP2101_COMM_STAT0, AXP2101_BUFFERC),
+};
+
+static const struct regmap_range axp2101_volatile_ranges[] = {
+	regmap_reg_range(AXP2101_COMM_STAT0, AXP2101_BUFFERC),
+};
+
+static const struct regmap_access_table axp2101_writeable_table = {
+	.yes_ranges	= axp2101_writeable_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(axp2101_writeable_ranges),
+};
+
+static const struct regmap_access_table axp2101_volatile_table = {
+	.yes_ranges	= axp2101_volatile_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(axp2101_volatile_ranges),
+};
+/***********************/
+static const struct regmap_range axp15_writeable_ranges[] = {
+	regmap_reg_range(AXP15_STATUS, AXP15_GPIO0123_SIGNAL),
+};
+
+static const struct regmap_range axp15_volatile_ranges[] = {
+	regmap_reg_range(AXP15_STATUS, AXP15_GPIO0123_SIGNAL),
+};
+
+static const struct regmap_access_table axp15_writeable_table = {
+	.yes_ranges	= axp15_writeable_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(axp15_writeable_ranges),
+};
+
+static const struct regmap_access_table axp15_volatile_table = {
+	.yes_ranges	= axp15_volatile_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(axp15_volatile_ranges),
+};
+/***********************/
+static const struct regmap_range axp1530_writeable_ranges[] = {
+	regmap_reg_range(AXP1530_ON_INDICATE, AXP1530_FREQUENCY),
+};
+
+static const struct regmap_range axp1530_volatile_ranges[] = {
+	regmap_reg_range(AXP1530_ON_INDICATE, AXP1530_FREQUENCY),
+};
+
+static const struct regmap_access_table axp1530_writeable_table = {
+	.yes_ranges	= axp1530_writeable_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(axp1530_writeable_ranges),
+};
+
+static const struct regmap_access_table axp1530_volatile_table = {
+	.yes_ranges	= axp1530_volatile_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(axp1530_volatile_ranges),
+};
+/***********************/
+static const struct regmap_range axp858_writeable_ranges[] = {
+	regmap_reg_range(AXP858_ON_INDICATE, AXP858_FREQUENCY_ALDO2),
+};
+
+static const struct regmap_range axp858_volatile_ranges[] = {
+	regmap_reg_range(AXP858_ON_INDICATE, AXP858_FREQUENCY_ALDO2),
+};
+
+static const struct regmap_access_table axp858_writeable_table = {
+	.yes_ranges	= axp858_writeable_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(axp858_writeable_ranges),
+};
+
+static const struct regmap_access_table axp858_volatile_table = {
+	.yes_ranges	= axp858_volatile_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(axp858_volatile_ranges),
+};
+
+
+static const struct regmap_range axp803_writeable_ranges[] = {
+	regmap_reg_range(AXP803_STATUS, AXP803_REG_ADDR_EXT),
+};
+
+static const struct regmap_range axp803_volatile_ranges[] = {
+	regmap_reg_range(AXP803_STATUS, AXP803_REG_ADDR_EXT),
+};
+
+static const struct regmap_access_table axp803_writeable_table = {
+	.yes_ranges	= axp803_writeable_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(axp803_writeable_ranges),
+};
+
+static const struct regmap_access_table axp803_volatile_table = {
+	.yes_ranges	= axp803_volatile_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(axp803_volatile_ranges),
+};
+
+/*---------------*/
+static struct resource axp152_pek_resources[] = {
+	DEFINE_RES_IRQ_NAMED(AXP152_IRQ_PEK_RIS_EDGE, "PEK_DBR"),
+	DEFINE_RES_IRQ_NAMED(AXP152_IRQ_PEK_FAL_EDGE, "PEK_DBF"),
+};
+
+static struct resource axp20x_ac_power_supply_resources[] = {
+	DEFINE_RES_IRQ_NAMED(AXP20X_IRQ_ACIN_PLUGIN, "ACIN_PLUGIN"),
+	DEFINE_RES_IRQ_NAMED(AXP20X_IRQ_ACIN_REMOVAL, "ACIN_REMOVAL"),
+	DEFINE_RES_IRQ_NAMED(AXP20X_IRQ_ACIN_OVER_V, "ACIN_OVER_V"),
+};
+
+static struct resource axp20x_pek_resources[] = {
+	{
+		.name	= "PEK_DBR",
+		.start	= AXP20X_IRQ_PEK_RIS_EDGE,
+		.end	= AXP20X_IRQ_PEK_RIS_EDGE,
+		.flags	= IORESOURCE_IRQ,
+	}, {
+		.name	= "PEK_DBF",
+		.start	= AXP20X_IRQ_PEK_FAL_EDGE,
+		.end	= AXP20X_IRQ_PEK_FAL_EDGE,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource axp20x_usb_power_supply_resources[] = {
+	DEFINE_RES_IRQ_NAMED(AXP20X_IRQ_VBUS_PLUGIN, "VBUS_PLUGIN"),
+	DEFINE_RES_IRQ_NAMED(AXP20X_IRQ_VBUS_REMOVAL, "VBUS_REMOVAL"),
+	DEFINE_RES_IRQ_NAMED(AXP20X_IRQ_VBUS_VALID, "VBUS_VALID"),
+	DEFINE_RES_IRQ_NAMED(AXP20X_IRQ_VBUS_NOT_VALID, "VBUS_NOT_VALID"),
+};
+
+static struct resource axp22x_usb_power_supply_resources[] = {
+	DEFINE_RES_IRQ_NAMED(AXP22X_IRQ_VBUS_PLUGIN, "VBUS_PLUGIN"),
+	DEFINE_RES_IRQ_NAMED(AXP22X_IRQ_VBUS_REMOVAL, "VBUS_REMOVAL"),
+};
+
+static struct resource axp22x_pek_resources[] = {
+	{
+		.name   = "PEK_DBR",
+		.start  = AXP22X_IRQ_PEK_RIS_EDGE,
+		.end    = AXP22X_IRQ_PEK_RIS_EDGE,
+		.flags  = IORESOURCE_IRQ,
+	}, {
+		.name   = "PEK_DBF",
+		.start  = AXP22X_IRQ_PEK_FAL_EDGE,
+		.end    = AXP22X_IRQ_PEK_FAL_EDGE,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource axp288_power_button_resources[] = {
+	{
+		.name	= "PEK_DBR",
+		.start	= AXP288_IRQ_POKP,
+		.end	= AXP288_IRQ_POKP,
+		.flags	= IORESOURCE_IRQ,
+	},
+	{
+		.name	= "PEK_DBF",
+		.start	= AXP288_IRQ_POKN,
+		.end	= AXP288_IRQ_POKN,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource axp288_fuel_gauge_resources[] = {
+	{
+		.start = AXP288_IRQ_QWBTU,
+		.end   = AXP288_IRQ_QWBTU,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = AXP288_IRQ_WBTU,
+		.end   = AXP288_IRQ_WBTU,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = AXP288_IRQ_QWBTO,
+		.end   = AXP288_IRQ_QWBTO,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = AXP288_IRQ_WBTO,
+		.end   = AXP288_IRQ_WBTO,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = AXP288_IRQ_WL2,
+		.end   = AXP288_IRQ_WL2,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = AXP288_IRQ_WL1,
+		.end   = AXP288_IRQ_WL1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource axp809_pek_resources[] = {
+	{
+		.name   = "PEK_DBR",
+		.start  = AXP809_IRQ_PEK_RIS_EDGE,
+		.end    = AXP809_IRQ_PEK_RIS_EDGE,
+		.flags  = IORESOURCE_IRQ,
+	}, {
+		.name   = "PEK_DBF",
+		.start  = AXP809_IRQ_PEK_FAL_EDGE,
+		.end    = AXP809_IRQ_PEK_FAL_EDGE,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static const struct regmap_config axp152_regmap_config = {
+	.reg_bits	= 8,
+	.val_bits	= 8,
+	.wr_table	= &axp152_writeable_table,
+	.volatile_table	= &axp152_volatile_table,
+	.max_register	= AXP152_PWM1_DUTY_CYCLE,
+	.cache_type	= REGCACHE_RBTREE,
+};
+
+static const struct regmap_config axp20x_regmap_config = {
+	.reg_bits	= 8,
+	.val_bits	= 8,
+	.wr_table	= &axp20x_writeable_table,
+	.volatile_table	= &axp20x_volatile_table,
+	.max_register	= AXP20X_OCV(AXP20X_OCV_MAX),
+	.cache_type	= REGCACHE_RBTREE,
+};
+
+static const struct regmap_config axp22x_regmap_config = {
+	.reg_bits	= 8,
+	.val_bits	= 8,
+	.wr_table	= &axp22x_writeable_table,
+	.volatile_table	= &axp22x_volatile_table,
+	.max_register	= AXP22X_BATLOW_THRES1,
+	.cache_type	= REGCACHE_RBTREE,
+};
+
+static const struct regmap_config axp288_regmap_config = {
+	.reg_bits	= 8,
+	.val_bits	= 8,
+	.wr_table	= &axp288_writeable_table,
+	.volatile_table	= &axp288_volatile_table,
+	.max_register	= AXP288_FG_TUNE5,
+	.cache_type	= REGCACHE_RBTREE,
+};
+
+static const struct regmap_config axp806_regmap_config = {
+	.reg_bits	= 8,
+	.val_bits	= 8,
+	.wr_table	= &axp806_writeable_table,
+	.volatile_table	= &axp806_volatile_table,
+	.max_register	= AXP806_VREF_TEMP_WARN_L,
+	.cache_type	= REGCACHE_RBTREE,
+};
+
+
+static const struct regmap_config axp2101_regmap_config = {
+	.reg_bits	= 8,
+	.val_bits	= 8,
+	.wr_table	= &axp2101_writeable_table,
+	.volatile_table	= &axp2101_volatile_table,
+	.max_register	= AXP2101_BUFFERC,
+	.use_single_read = true,
+	.use_single_write = true,
+	.cache_type	= REGCACHE_RBTREE,
+};
+/******************************/
+static const struct regmap_config axp15_regmap_config = {
+	.reg_bits	= 8,
+	.val_bits	= 8,
+	.wr_table	= &axp15_writeable_table,
+	.volatile_table	= &axp15_volatile_table,
+	.max_register	= AXP15_GPIO0123_SIGNAL,
+	.use_single_read = true,
+	.use_single_write = true,
+	.cache_type	= REGCACHE_RBTREE,
+};
+/******************************/
+static const struct regmap_config axp1530_regmap_config = {
+	.reg_bits	= 8,
+	.val_bits	= 8,
+	.wr_table	= &axp1530_writeable_table,
+	.volatile_table	= &axp1530_volatile_table,
+	.max_register	= AXP1530_FREQUENCY,
+	.use_single_read = true,
+	.use_single_write = true,
+	.cache_type	= REGCACHE_RBTREE,
+};
+/******************************/
+static const struct regmap_config axp858_regmap_config = {
+	.reg_bits	= 8,
+	.val_bits	= 8,
+	.wr_table	= &axp858_writeable_table,
+	.volatile_table	= &axp858_volatile_table,
+	.max_register	= AXP858_FREQUENCY_ALDO2,
+	.use_single_read = true,
+	.use_single_write = true,
+	.cache_type	= REGCACHE_RBTREE,
+};
+
+static const struct regmap_config axp803_regmap_config = {
+	.reg_bits	= 8,
+	.val_bits	= 8,
+	.wr_table	= &axp803_writeable_table,
+	.volatile_table	= &axp803_volatile_table,
+	.max_register	= AXP803_REG_ADDR_EXT,
+	.use_single_read = true,
+	.use_single_write = true,
+	.cache_type	= REGCACHE_RBTREE,
+};
+
+static const struct regmap_config axp2202_regmap_config = {
+	.reg_bits	= 8,
+	.val_bits	= 8,
+	.max_register	= AXP2202_TWI_ADDR_EXT,
+	.use_single_read = true,
+	.use_single_write = true,
+	.cache_type	= REGCACHE_NONE,
+};
+
+/*------------------*/
+#define INIT_REGMAP_IRQ(_variant, _irq, _off, _mask)			\
+	[_variant##_IRQ_##_irq] = { .reg_offset = (_off), .mask = BIT(_mask) }
+
+static const struct regmap_irq axp152_regmap_irqs[] = {
+	INIT_REGMAP_IRQ(AXP152, LDO0IN_CONNECT,		0, 6),
+	INIT_REGMAP_IRQ(AXP152, LDO0IN_REMOVAL,		0, 5),
+	INIT_REGMAP_IRQ(AXP152, ALDO0IN_CONNECT,	0, 3),
+	INIT_REGMAP_IRQ(AXP152, ALDO0IN_REMOVAL,	0, 2),
+	INIT_REGMAP_IRQ(AXP152, DCDC1_V_LOW,		1, 5),
+	INIT_REGMAP_IRQ(AXP152, DCDC2_V_LOW,		1, 4),
+	INIT_REGMAP_IRQ(AXP152, DCDC3_V_LOW,		1, 3),
+	INIT_REGMAP_IRQ(AXP152, DCDC4_V_LOW,		1, 2),
+	INIT_REGMAP_IRQ(AXP152, PEK_SHORT,		1, 1),
+	INIT_REGMAP_IRQ(AXP152, PEK_LONG,		1, 0),
+	INIT_REGMAP_IRQ(AXP152, TIMER,			2, 7),
+	INIT_REGMAP_IRQ(AXP152, PEK_RIS_EDGE,		2, 6),
+	INIT_REGMAP_IRQ(AXP152, PEK_FAL_EDGE,		2, 5),
+	INIT_REGMAP_IRQ(AXP152, GPIO3_INPUT,		2, 3),
+	INIT_REGMAP_IRQ(AXP152, GPIO2_INPUT,		2, 2),
+	INIT_REGMAP_IRQ(AXP152, GPIO1_INPUT,		2, 1),
+	INIT_REGMAP_IRQ(AXP152, GPIO0_INPUT,		2, 0),
+};
+
+static const struct regmap_irq axp20x_regmap_irqs[] = {
+	INIT_REGMAP_IRQ(AXP20X, ACIN_OVER_V,		0, 7),
+	INIT_REGMAP_IRQ(AXP20X, ACIN_PLUGIN,		0, 6),
+	INIT_REGMAP_IRQ(AXP20X, ACIN_REMOVAL,	        0, 5),
+	INIT_REGMAP_IRQ(AXP20X, VBUS_OVER_V,		0, 4),
+	INIT_REGMAP_IRQ(AXP20X, VBUS_PLUGIN,		0, 3),
+	INIT_REGMAP_IRQ(AXP20X, VBUS_REMOVAL,	        0, 2),
+	INIT_REGMAP_IRQ(AXP20X, VBUS_V_LOW,		0, 1),
+	INIT_REGMAP_IRQ(AXP20X, BATT_PLUGIN,		1, 7),
+	INIT_REGMAP_IRQ(AXP20X, BATT_REMOVAL,	        1, 6),
+	INIT_REGMAP_IRQ(AXP20X, BATT_ENT_ACT_MODE,	1, 5),
+	INIT_REGMAP_IRQ(AXP20X, BATT_EXIT_ACT_MODE,	1, 4),
+	INIT_REGMAP_IRQ(AXP20X, CHARG,		        1, 3),
+	INIT_REGMAP_IRQ(AXP20X, CHARG_DONE,		1, 2),
+	INIT_REGMAP_IRQ(AXP20X, BATT_TEMP_HIGH,	        1, 1),
+	INIT_REGMAP_IRQ(AXP20X, BATT_TEMP_LOW,	        1, 0),
+	INIT_REGMAP_IRQ(AXP20X, DIE_TEMP_HIGH,	        2, 7),
+	INIT_REGMAP_IRQ(AXP20X, CHARG_I_LOW,		2, 6),
+	INIT_REGMAP_IRQ(AXP20X, DCDC1_V_LONG,	        2, 5),
+	INIT_REGMAP_IRQ(AXP20X, DCDC2_V_LONG,	        2, 4),
+	INIT_REGMAP_IRQ(AXP20X, DCDC3_V_LONG,	        2, 3),
+	INIT_REGMAP_IRQ(AXP20X, PEK_SHORT,		2, 1),
+	INIT_REGMAP_IRQ(AXP20X, PEK_LONG,		2, 0),
+	INIT_REGMAP_IRQ(AXP20X, N_OE_PWR_ON,		3, 7),
+	INIT_REGMAP_IRQ(AXP20X, N_OE_PWR_OFF,	        3, 6),
+	INIT_REGMAP_IRQ(AXP20X, VBUS_VALID,		3, 5),
+	INIT_REGMAP_IRQ(AXP20X, VBUS_NOT_VALID,	        3, 4),
+	INIT_REGMAP_IRQ(AXP20X, VBUS_SESS_VALID,	3, 3),
+	INIT_REGMAP_IRQ(AXP20X, VBUS_SESS_END,	        3, 2),
+	INIT_REGMAP_IRQ(AXP20X, LOW_PWR_LVL1,	        3, 1),
+	INIT_REGMAP_IRQ(AXP20X, LOW_PWR_LVL2,	        3, 0),
+	INIT_REGMAP_IRQ(AXP20X, TIMER,		        4, 7),
+	INIT_REGMAP_IRQ(AXP20X, PEK_RIS_EDGE,	        4, 6),
+	INIT_REGMAP_IRQ(AXP20X, PEK_FAL_EDGE,	        4, 5),
+	INIT_REGMAP_IRQ(AXP20X, GPIO3_INPUT,		4, 3),
+	INIT_REGMAP_IRQ(AXP20X, GPIO2_INPUT,		4, 2),
+	INIT_REGMAP_IRQ(AXP20X, GPIO1_INPUT,		4, 1),
+	INIT_REGMAP_IRQ(AXP20X, GPIO0_INPUT,		4, 0),
+};
+
+static const struct regmap_irq axp22x_regmap_irqs[] = {
+	INIT_REGMAP_IRQ(AXP22X, ACIN_OVER_V,		0, 7),
+	INIT_REGMAP_IRQ(AXP22X, ACIN_PLUGIN,		0, 6),
+	INIT_REGMAP_IRQ(AXP22X, ACIN_REMOVAL,	        0, 5),
+	INIT_REGMAP_IRQ(AXP22X, VBUS_OVER_V,		0, 4),
+	INIT_REGMAP_IRQ(AXP22X, VBUS_PLUGIN,		0, 3),
+	INIT_REGMAP_IRQ(AXP22X, VBUS_REMOVAL,	        0, 2),
+	INIT_REGMAP_IRQ(AXP22X, VBUS_V_LOW,		0, 1),
+	INIT_REGMAP_IRQ(AXP22X, BATT_PLUGIN,		1, 7),
+	INIT_REGMAP_IRQ(AXP22X, BATT_REMOVAL,	        1, 6),
+	INIT_REGMAP_IRQ(AXP22X, BATT_ENT_ACT_MODE,	1, 5),
+	INIT_REGMAP_IRQ(AXP22X, BATT_EXIT_ACT_MODE,	1, 4),
+	INIT_REGMAP_IRQ(AXP22X, CHARG,		        1, 3),
+	INIT_REGMAP_IRQ(AXP22X, CHARG_DONE,		1, 2),
+	INIT_REGMAP_IRQ(AXP22X, BATT_TEMP_HIGH,	        1, 1),
+	INIT_REGMAP_IRQ(AXP22X, BATT_TEMP_LOW,	        1, 0),
+	INIT_REGMAP_IRQ(AXP22X, DIE_TEMP_HIGH,	        2, 7),
+	INIT_REGMAP_IRQ(AXP22X, PEK_SHORT,		2, 1),
+	INIT_REGMAP_IRQ(AXP22X, PEK_LONG,		2, 0),
+	INIT_REGMAP_IRQ(AXP22X, LOW_PWR_LVL1,	        3, 1),
+	INIT_REGMAP_IRQ(AXP22X, LOW_PWR_LVL2,	        3, 0),
+	INIT_REGMAP_IRQ(AXP22X, TIMER,		        4, 7),
+	INIT_REGMAP_IRQ(AXP22X, PEK_RIS_EDGE,	        4, 6),
+	INIT_REGMAP_IRQ(AXP22X, PEK_FAL_EDGE,	        4, 5),
+	INIT_REGMAP_IRQ(AXP22X, GPIO1_INPUT,		4, 1),
+	INIT_REGMAP_IRQ(AXP22X, GPIO0_INPUT,		4, 0),
+};
+
+/* some IRQs are compatible with axp20x models */
+static const struct regmap_irq axp288_regmap_irqs[] = {
+	INIT_REGMAP_IRQ(AXP288, VBUS_FALL,              0, 2),
+	INIT_REGMAP_IRQ(AXP288, VBUS_RISE,              0, 3),
+	INIT_REGMAP_IRQ(AXP288, OV,                     0, 4),
+
+	INIT_REGMAP_IRQ(AXP288, DONE,                   1, 2),
+	INIT_REGMAP_IRQ(AXP288, CHARGING,               1, 3),
+	INIT_REGMAP_IRQ(AXP288, SAFE_QUIT,              1, 4),
+	INIT_REGMAP_IRQ(AXP288, SAFE_ENTER,             1, 5),
+	INIT_REGMAP_IRQ(AXP288, ABSENT,                 1, 6),
+	INIT_REGMAP_IRQ(AXP288, APPEND,                 1, 7),
+
+	INIT_REGMAP_IRQ(AXP288, QWBTU,                  2, 0),
+	INIT_REGMAP_IRQ(AXP288, WBTU,                   2, 1),
+	INIT_REGMAP_IRQ(AXP288, QWBTO,                  2, 2),
+	INIT_REGMAP_IRQ(AXP288, WBTO,                   2, 3),
+	INIT_REGMAP_IRQ(AXP288, QCBTU,                  2, 4),
+	INIT_REGMAP_IRQ(AXP288, CBTU,                   2, 5),
+	INIT_REGMAP_IRQ(AXP288, QCBTO,                  2, 6),
+	INIT_REGMAP_IRQ(AXP288, CBTO,                   2, 7),
+
+	INIT_REGMAP_IRQ(AXP288, WL2,                    3, 0),
+	INIT_REGMAP_IRQ(AXP288, WL1,                    3, 1),
+	INIT_REGMAP_IRQ(AXP288, GPADC,                  3, 2),
+	INIT_REGMAP_IRQ(AXP288, OT,                     3, 7),
+
+	INIT_REGMAP_IRQ(AXP288, GPIO0,                  4, 0),
+	INIT_REGMAP_IRQ(AXP288, GPIO1,                  4, 1),
+	INIT_REGMAP_IRQ(AXP288, POKO,                   4, 2),
+	INIT_REGMAP_IRQ(AXP288, POKL,                   4, 3),
+	INIT_REGMAP_IRQ(AXP288, POKS,                   4, 4),
+	INIT_REGMAP_IRQ(AXP288, POKN,                   4, 5),
+	INIT_REGMAP_IRQ(AXP288, POKP,                   4, 6),
+	INIT_REGMAP_IRQ(AXP288, TIMER,                  4, 7),
+
+	INIT_REGMAP_IRQ(AXP288, MV_CHNG,                5, 0),
+	INIT_REGMAP_IRQ(AXP288, BC_USB_CHNG,            5, 1),
+};
+
+static const struct regmap_irq axp806_regmap_irqs[] = {
+	INIT_REGMAP_IRQ(AXP806, DIE_TEMP_HIGH_LV1,	0, 0),
+	INIT_REGMAP_IRQ(AXP806, DIE_TEMP_HIGH_LV2,	0, 1),
+	INIT_REGMAP_IRQ(AXP806, DCDCA_V_LOW,		0, 3),
+	INIT_REGMAP_IRQ(AXP806, DCDCB_V_LOW,		0, 4),
+	INIT_REGMAP_IRQ(AXP806, DCDCC_V_LOW,		0, 5),
+	INIT_REGMAP_IRQ(AXP806, DCDCD_V_LOW,		0, 6),
+	INIT_REGMAP_IRQ(AXP806, DCDCE_V_LOW,		0, 7),
+	INIT_REGMAP_IRQ(AXP806, PWROK_LONG,		1, 0),
+	INIT_REGMAP_IRQ(AXP806, PWROK_SHORT,		1, 1),
+	INIT_REGMAP_IRQ(AXP806, WAKEUP,			1, 4),
+	INIT_REGMAP_IRQ(AXP806, PWROK_FALL,		1, 5),
+	INIT_REGMAP_IRQ(AXP806, PWROK_RISE,		1, 6),
+};
+
+static const struct regmap_irq axp809_regmap_irqs[] = {
+	INIT_REGMAP_IRQ(AXP809, ACIN_OVER_V,		0, 7),
+	INIT_REGMAP_IRQ(AXP809, ACIN_PLUGIN,		0, 6),
+	INIT_REGMAP_IRQ(AXP809, ACIN_REMOVAL,	        0, 5),
+	INIT_REGMAP_IRQ(AXP809, VBUS_OVER_V,		0, 4),
+	INIT_REGMAP_IRQ(AXP809, VBUS_PLUGIN,		0, 3),
+	INIT_REGMAP_IRQ(AXP809, VBUS_REMOVAL,	        0, 2),
+	INIT_REGMAP_IRQ(AXP809, VBUS_V_LOW,		0, 1),
+	INIT_REGMAP_IRQ(AXP809, BATT_PLUGIN,		1, 7),
+	INIT_REGMAP_IRQ(AXP809, BATT_REMOVAL,	        1, 6),
+	INIT_REGMAP_IRQ(AXP809, BATT_ENT_ACT_MODE,	1, 5),
+	INIT_REGMAP_IRQ(AXP809, BATT_EXIT_ACT_MODE,	1, 4),
+	INIT_REGMAP_IRQ(AXP809, CHARG,		        1, 3),
+	INIT_REGMAP_IRQ(AXP809, CHARG_DONE,		1, 2),
+	INIT_REGMAP_IRQ(AXP809, BATT_CHG_TEMP_HIGH,	2, 7),
+	INIT_REGMAP_IRQ(AXP809, BATT_CHG_TEMP_HIGH_END,	2, 6),
+	INIT_REGMAP_IRQ(AXP809, BATT_CHG_TEMP_LOW,	2, 5),
+	INIT_REGMAP_IRQ(AXP809, BATT_CHG_TEMP_LOW_END,	2, 4),
+	INIT_REGMAP_IRQ(AXP809, BATT_ACT_TEMP_HIGH,	2, 3),
+	INIT_REGMAP_IRQ(AXP809, BATT_ACT_TEMP_HIGH_END,	2, 2),
+	INIT_REGMAP_IRQ(AXP809, BATT_ACT_TEMP_LOW,	2, 1),
+	INIT_REGMAP_IRQ(AXP809, BATT_ACT_TEMP_LOW_END,	2, 0),
+	INIT_REGMAP_IRQ(AXP809, DIE_TEMP_HIGH,	        3, 7),
+	INIT_REGMAP_IRQ(AXP809, LOW_PWR_LVL1,	        3, 1),
+	INIT_REGMAP_IRQ(AXP809, LOW_PWR_LVL2,	        3, 0),
+	INIT_REGMAP_IRQ(AXP809, TIMER,		        4, 7),
+	INIT_REGMAP_IRQ(AXP809, PEK_RIS_EDGE,	        4, 6),
+	INIT_REGMAP_IRQ(AXP809, PEK_FAL_EDGE,	        4, 5),
+	INIT_REGMAP_IRQ(AXP809, PEK_SHORT,		4, 4),
+	INIT_REGMAP_IRQ(AXP809, PEK_LONG,		4, 3),
+	INIT_REGMAP_IRQ(AXP809, PEK_OVER_OFF,		4, 2),
+	INIT_REGMAP_IRQ(AXP809, GPIO1_INPUT,		4, 1),
+	INIT_REGMAP_IRQ(AXP809, GPIO0_INPUT,		4, 0),
+};
+
+static const struct regmap_irq axp2101_regmap_irqs[] = {
+	INIT_REGMAP_IRQ(AXP2101, SOCWL2,		0, 7),
+	INIT_REGMAP_IRQ(AXP2101, SOCWL1,		0, 6),
+	INIT_REGMAP_IRQ(AXP2101, GWDT,			0, 5),
+	INIT_REGMAP_IRQ(AXP2101, NEWSOC,		0, 4),
+	INIT_REGMAP_IRQ(AXP2101, BCOT,			0, 3),
+	INIT_REGMAP_IRQ(AXP2101, BCUT,			0, 2),
+	INIT_REGMAP_IRQ(AXP2101, BWOT,			0, 1),
+	INIT_REGMAP_IRQ(AXP2101, BWUT,			0, 0),
+	INIT_REGMAP_IRQ(AXP2101, VINSET,		1, 7),
+	INIT_REGMAP_IRQ(AXP2101, VREMOV,		1, 6),
+	INIT_REGMAP_IRQ(AXP2101, BINSERT,		1, 5),
+	INIT_REGMAP_IRQ(AXP2101, BREMOV,		1, 4),
+	INIT_REGMAP_IRQ(AXP2101, PONS,			1, 3),
+	INIT_REGMAP_IRQ(AXP2101, PONL,			1, 2),
+	INIT_REGMAP_IRQ(AXP2101, PONN,			1, 1),
+	INIT_REGMAP_IRQ(AXP2101, PONP,			1, 0),
+	INIT_REGMAP_IRQ(AXP2101, WDEXP,			2, 7),
+	INIT_REGMAP_IRQ(AXP2101, LDOOC,			2, 6),
+	INIT_REGMAP_IRQ(AXP2101, BOCP,			2, 5),
+	INIT_REGMAP_IRQ(AXP2101, CHGDN,			2, 4),
+	INIT_REGMAP_IRQ(AXP2101, CHGST,			2, 3),
+	INIT_REGMAP_IRQ(AXP2101, DOTL1,			2, 2),
+	INIT_REGMAP_IRQ(AXP2101, CHGTE,			2, 1),
+	INIT_REGMAP_IRQ(AXP2101, BOVP,			2, 0),
+};
+/********************************/
+static const struct regmap_irq axp15_regmap_irqs[] = {
+	INIT_REGMAP_IRQ(AXP15, LDO0IN_L2H,		0, 6),
+	INIT_REGMAP_IRQ(AXP15, LDO0IN_H2L,			0, 5),
+	INIT_REGMAP_IRQ(AXP15, ALDOIN_L2H,			0, 3),
+	INIT_REGMAP_IRQ(AXP15, ALDOIN_H2L,			0, 2),
+	INIT_REGMAP_IRQ(AXP15, DCDC1_V_LOW,		1, 5),
+	INIT_REGMAP_IRQ(AXP15, DCDC2_V_LOW,		1, 4),
+	INIT_REGMAP_IRQ(AXP15, DCDC3_V_LOW,			1, 3),
+	INIT_REGMAP_IRQ(AXP15, DCDC4_V_LOW,			1, 2),
+	INIT_REGMAP_IRQ(AXP15, PEKSH,			1, 1),
+	INIT_REGMAP_IRQ(AXP15, PEKLO,			1, 0),
+	INIT_REGMAP_IRQ(AXP15, EVENT_TIMEOUT,			2, 7),
+	INIT_REGMAP_IRQ(AXP15, PEKRE,			2, 6),
+	INIT_REGMAP_IRQ(AXP15, PEKFE,			2, 5),
+	INIT_REGMAP_IRQ(AXP15, GPIO3,			2, 3),
+	INIT_REGMAP_IRQ(AXP15, GPIO2,			2, 2),
+	INIT_REGMAP_IRQ(AXP15, GPIO1,			2, 1),
+	INIT_REGMAP_IRQ(AXP15, GPIO0,			2, 0),
+};
+/********************************/
+static const struct regmap_irq axp1530_regmap_irqs[] = {
+	INIT_REGMAP_IRQ(AXP1530, KEY_L2H_EN,		0, 7),
+	INIT_REGMAP_IRQ(AXP1530, KEY_H2L_EN,		0, 6),
+	INIT_REGMAP_IRQ(AXP1530, POKSIRQ_EN,		0, 5),
+	INIT_REGMAP_IRQ(AXP1530, POKLIRQ_EN,		0, 4),
+	INIT_REGMAP_IRQ(AXP1530, DCDC3_UNDER,		0, 3),
+	INIT_REGMAP_IRQ(AXP1530, DCDC2_UNDER,		0, 2),
+	INIT_REGMAP_IRQ(AXP1530, TEMP_OVER,			0, 0),
+};
+/********************************/
+static const struct regmap_irq axp858_regmap_irqs[] = {
+	INIT_REGMAP_IRQ(AXP858, DCDC3_CUR_OVER,		1, 7),
+	INIT_REGMAP_IRQ(AXP858, DCDC2_CUR_OVER,		1, 6),
+	INIT_REGMAP_IRQ(AXP858, GPIO2_EN,			1, 5),
+	INIT_REGMAP_IRQ(AXP858, POKPIRQ_EN,			1, 4),
+	INIT_REGMAP_IRQ(AXP858, POKNIRQ_EN,			1, 3),
+	INIT_REGMAP_IRQ(AXP858, GPIO1_EN,			1, 2),
+	INIT_REGMAP_IRQ(AXP858, POKSIRQ_EN,			1, 1),
+	INIT_REGMAP_IRQ(AXP858, POKLIRQ_EN,			1, 0),
+	INIT_REGMAP_IRQ(AXP858, DCDC6_UNDER,		0, 7),
+	INIT_REGMAP_IRQ(AXP858, DCDC5_UNDER,		0, 6),
+	INIT_REGMAP_IRQ(AXP858, DCDC4_UNDER,		0, 5),
+	INIT_REGMAP_IRQ(AXP858, DCDC3_UNDER,		0, 4),
+	INIT_REGMAP_IRQ(AXP858, DCDC2_UNDER,		0, 3),
+	INIT_REGMAP_IRQ(AXP858, DCDC1_UNDER,		0, 2),
+	INIT_REGMAP_IRQ(AXP858, TEMP_OVER2,			0, 1),
+	INIT_REGMAP_IRQ(AXP858, TEMP_OVER1,			0, 0),
+};
+/*------------------*/
+static const struct regmap_irq axp803_regmap_irqs[] = {
+	INIT_REGMAP_IRQ(AXP803, ACOV,			0, 7),
+	INIT_REGMAP_IRQ(AXP803, ACIN,			0, 6),
+	INIT_REGMAP_IRQ(AXP803, ACRE,			0, 5),
+	INIT_REGMAP_IRQ(AXP803, USBOV,			0, 4),
+	INIT_REGMAP_IRQ(AXP803, USBIN,			0, 3),
+	INIT_REGMAP_IRQ(AXP803, USBRE,			0, 2),
+	INIT_REGMAP_IRQ(AXP803, BATIN,			1, 7),
+	INIT_REGMAP_IRQ(AXP803, BATRE,			1, 6),
+	INIT_REGMAP_IRQ(AXP803, BATATIN,		1, 5),
+	INIT_REGMAP_IRQ(AXP803, BATATOU,		1, 4),
+	INIT_REGMAP_IRQ(AXP803, CHAST,			1, 3),
+	INIT_REGMAP_IRQ(AXP803, CHAOV,			1, 2),
+	INIT_REGMAP_IRQ(AXP803, BATOVCHG,		2, 7),
+	INIT_REGMAP_IRQ(AXP803, QBATOVCHG,		2, 6),
+	INIT_REGMAP_IRQ(AXP803, BATINCHG,		2, 5),
+	INIT_REGMAP_IRQ(AXP803, QBATINCHG,		2, 4),
+	INIT_REGMAP_IRQ(AXP803, BATOVWORK,		2, 3),
+	INIT_REGMAP_IRQ(AXP803, QBATOVWORK,		2, 2),
+	INIT_REGMAP_IRQ(AXP803, BATINWORK,		2, 1),
+	INIT_REGMAP_IRQ(AXP803, QBATINWORK,		2, 0),
+	INIT_REGMAP_IRQ(AXP803, LOWN1,			3, 1),
+	INIT_REGMAP_IRQ(AXP803, LOWN2,			3, 0),
+	INIT_REGMAP_IRQ(AXP803, TIMER,			4, 7),
+	INIT_REGMAP_IRQ(AXP803, PEKRE,			4, 6),
+	INIT_REGMAP_IRQ(AXP803, PEKFE,			4, 5),
+	INIT_REGMAP_IRQ(AXP803, POKSH,			4, 4),
+	INIT_REGMAP_IRQ(AXP803, POKLO,			4, 3),
+	INIT_REGMAP_IRQ(AXP803, GPIO1,			4, 1),
+	INIT_REGMAP_IRQ(AXP803, GPIO0,			4, 0),
+};
+
+static const struct regmap_irq axp2202_regmap_irqs[] = {
+	INIT_REGMAP_IRQ(AXP2202, SOCWL2,      0, 7),
+	INIT_REGMAP_IRQ(AXP2202, SOCWL1,      0, 6),
+	INIT_REGMAP_IRQ(AXP2202, GWDT,        0, 5),
+	INIT_REGMAP_IRQ(AXP2202, NEWSOC,      0, 4),
+	INIT_REGMAP_IRQ(AXP2202, BST_OV,      0, 2),
+	INIT_REGMAP_IRQ(AXP2202, VBUS_OV,     0, 1),
+	INIT_REGMAP_IRQ(AXP2202, VBUS_FAULT,  0, 0),
+	INIT_REGMAP_IRQ(AXP2202, VINSERT,     1, 7),
+	INIT_REGMAP_IRQ(AXP2202, VREMOVE,     1, 6),
+	INIT_REGMAP_IRQ(AXP2202, BINSERT,     1, 5),
+	INIT_REGMAP_IRQ(AXP2202, BREMOVE,     1, 4),
+	INIT_REGMAP_IRQ(AXP2202, PONS,        1, 3),
+	INIT_REGMAP_IRQ(AXP2202, PONL,        1, 2),
+	INIT_REGMAP_IRQ(AXP2202, PONN,        1, 1),
+	INIT_REGMAP_IRQ(AXP2202, PONP,        1, 0),
+	INIT_REGMAP_IRQ(AXP2202, WDEXP,       2, 7),
+	INIT_REGMAP_IRQ(AXP2202, LDOOC,       2, 6),
+	INIT_REGMAP_IRQ(AXP2202, BOCP,        2, 5),
+	INIT_REGMAP_IRQ(AXP2202, CHGDN,       2, 4),
+	INIT_REGMAP_IRQ(AXP2202, CHGST,       2, 3),
+	INIT_REGMAP_IRQ(AXP2202, DOTL1,       2, 2),
+	INIT_REGMAP_IRQ(AXP2202, CHGTE,       2, 1),
+	INIT_REGMAP_IRQ(AXP2202, BOVP,        2, 0),
+	INIT_REGMAP_IRQ(AXP2202, BC_DONE,     3, 7),
+	INIT_REGMAP_IRQ(AXP2202, BC_CHNG,     3, 6),
+	INIT_REGMAP_IRQ(AXP2202, RID_CHNG,    3, 5),
+	INIT_REGMAP_IRQ(AXP2202, BCOTQ,       3, 4),
+	INIT_REGMAP_IRQ(AXP2202, BCOT,        3, 3),
+	INIT_REGMAP_IRQ(AXP2202, BCUT,        3, 2),
+	INIT_REGMAP_IRQ(AXP2202, BWOT,        3, 1),
+	INIT_REGMAP_IRQ(AXP2202, BWUT,        3, 0),
+	INIT_REGMAP_IRQ(AXP2202, CREMOVE,     4, 6),
+	INIT_REGMAP_IRQ(AXP2202, CINSERT,     4, 5),
+	INIT_REGMAP_IRQ(AXP2202, TOGGLE_DONE, 4, 4),
+	INIT_REGMAP_IRQ(AXP2202, VBUS_SAFE5V, 4, 3),
+	INIT_REGMAP_IRQ(AXP2202, VBUS_SAFE0V, 4, 2),
+	INIT_REGMAP_IRQ(AXP2202, ERR_GEN,     4, 1),
+	INIT_REGMAP_IRQ(AXP2202, PWR_CHNG,    4, 0),
+};
+
+static const struct regmap_irq_chip axp152_regmap_irq_chip = {
+	.name			= "axp152_irq_chip",
+	.status_base		= AXP152_IRQ1_STATE,
+	.ack_base		= AXP152_IRQ1_STATE,
+	.mask_base		= AXP152_IRQ1_EN,
+	.mask_invert		= true,
+	.init_ack_masked	= true,
+	.irqs			= axp152_regmap_irqs,
+	.num_irqs		= ARRAY_SIZE(axp152_regmap_irqs),
+	.num_regs		= 3,
+};
+
+static const struct regmap_irq_chip axp20x_regmap_irq_chip = {
+	.name			= "axp20x_irq_chip",
+	.status_base		= AXP20X_IRQ1_STATE,
+	.ack_base		= AXP20X_IRQ1_STATE,
+	.mask_base		= AXP20X_IRQ1_EN,
+	.mask_invert		= true,
+	.init_ack_masked	= true,
+	.irqs			= axp20x_regmap_irqs,
+	.num_irqs		= ARRAY_SIZE(axp20x_regmap_irqs),
+	.num_regs		= 5,
+
+};
+
+static const struct regmap_irq_chip axp22x_regmap_irq_chip = {
+	.name			= "axp22x_irq_chip",
+	.status_base		= AXP20X_IRQ1_STATE,
+	.ack_base		= AXP20X_IRQ1_STATE,
+	.mask_base		= AXP20X_IRQ1_EN,
+	.mask_invert		= true,
+	.init_ack_masked	= true,
+	.irqs			= axp22x_regmap_irqs,
+	.num_irqs		= ARRAY_SIZE(axp22x_regmap_irqs),
+	.num_regs		= 5,
+};
+
+static const struct regmap_irq_chip axp288_regmap_irq_chip = {
+	.name			= "axp288_irq_chip",
+	.status_base		= AXP20X_IRQ1_STATE,
+	.ack_base		= AXP20X_IRQ1_STATE,
+	.mask_base		= AXP20X_IRQ1_EN,
+	.mask_invert		= true,
+	.init_ack_masked	= true,
+	.irqs			= axp288_regmap_irqs,
+	.num_irqs		= ARRAY_SIZE(axp288_regmap_irqs),
+	.num_regs		= 6,
+
+};
+
+static const struct regmap_irq_chip axp806_regmap_irq_chip = {
+	.name			= "axp806",
+	.status_base		= AXP20X_IRQ1_STATE,
+	.ack_base		= AXP20X_IRQ1_STATE,
+	.mask_base		= AXP20X_IRQ1_EN,
+	.mask_invert		= true,
+	.init_ack_masked	= true,
+	.irqs			= axp806_regmap_irqs,
+	.num_irqs		= ARRAY_SIZE(axp806_regmap_irqs),
+	.num_regs		= 2,
+};
+
+static const struct regmap_irq_chip axp809_regmap_irq_chip = {
+	.name			= "axp809",
+	.status_base		= AXP20X_IRQ1_STATE,
+	.ack_base		= AXP20X_IRQ1_STATE,
+	.mask_base		= AXP20X_IRQ1_EN,
+	.mask_invert		= true,
+	.init_ack_masked	= true,
+	.irqs			= axp809_regmap_irqs,
+	.num_irqs		= ARRAY_SIZE(axp809_regmap_irqs),
+	.num_regs		= 5,
+};
+
+static const struct regmap_irq_chip axp2101_regmap_irq_chip = {
+	.name			= "axp2101_irq_chip",
+	.status_base		= AXP2101_INTSTS1,
+	.ack_base		= AXP2101_INTSTS1,
+	.mask_base		= AXP2101_INTEN1,
+	.mask_invert		= true,
+	.init_ack_masked	= true,
+	.irqs			= axp2101_regmap_irqs,
+	.num_irqs		= ARRAY_SIZE(axp2101_regmap_irqs),
+	.num_regs		= 3,
+
+};
+/********************************/
+static const struct regmap_irq_chip axp15_regmap_irq_chip = {
+	.name			= "axp15_irq_chip",
+	.status_base		= AXP15_INTSTS1,
+	.ack_base		= AXP15_INTSTS1,
+	.mask_base		= AXP15_INTEN1,
+	.mask_invert		= true,
+	.init_ack_masked	= true,
+	.irqs			= axp15_regmap_irqs,
+	.num_irqs		= ARRAY_SIZE(axp15_regmap_irqs),
+	.num_regs		= 3,
+};
+/********************************/
+static const struct regmap_irq_chip axp1530_regmap_irq_chip = {
+	.name			= "axp1530_irq_chip",
+	.status_base		= AXP1530_IRQ_STATUS1,
+	.ack_base		= AXP1530_IRQ_STATUS1,
+	.mask_base		= AXP1530_IRQ_ENABLE1,
+	.mask_invert		= true,
+	.init_ack_masked	= true,
+	.irqs			= axp1530_regmap_irqs,
+	.num_irqs		= ARRAY_SIZE(axp1530_regmap_irqs),
+	.num_regs		= 1,
+};
+/********************************/
+static const struct regmap_irq_chip axp858_regmap_irq_chip = {
+	.name			= "axp858_irq_chip",
+	.status_base		= AXP858_IRQ_STS1,
+	.ack_base		= AXP858_IRQ_STS1,
+	.mask_base		= AXP858_IRQ_EN1,
+	.mask_invert		= true,
+	.init_ack_masked	= true,
+	.irqs			= axp858_regmap_irqs,
+	.num_irqs		= ARRAY_SIZE(axp858_regmap_irqs),
+	.num_regs		= 2,
+};
+
+static const struct regmap_irq_chip axp803_regmap_irq_chip = {
+	.name			= "axp803_irq_chip",
+	.status_base		= AXP803_INTSTS1,
+	.ack_base		= AXP803_INTSTS1,
+	.mask_base		= AXP803_INTEN1,
+	.mask_invert		= true,
+	.init_ack_masked	= true,
+	.irqs			= axp803_regmap_irqs,
+	.num_irqs		= ARRAY_SIZE(axp803_regmap_irqs),
+	.num_regs		= 6,
+};
+
+static const struct regmap_irq_chip axp2202_regmap_irq_chip = {
+	.name			= "axp2202_irq_chip",
+	.status_base		= AXP2202_IRQ0,
+	.ack_base		= AXP2202_IRQ0,
+	.mask_base		= AXP2202_IRQ_EN0,
+	.mask_invert		= true,
+	.init_ack_masked	= true,
+	.irqs			= axp2202_regmap_irqs,
+	.num_irqs		= ARRAY_SIZE(axp2202_regmap_irqs),
+	.num_regs		= 5,
+};
+
+/*--------------------*/
+static struct mfd_cell axp20x_cells[] = {
+	{
+		.name		= "axp20x-gpio",
+		.of_compatible	= "x-powers,axp209-gpio",
+	}, {
+		.name		= "axp20x-pek",
+		.num_resources	= ARRAY_SIZE(axp20x_pek_resources),
+		.resources	= axp20x_pek_resources,
+	}, {
+		.name		= "axp20x-regulator",
+	}, {
+		.name		= "axp20x-ac-power-supply",
+		.of_compatible	= "x-powers,axp202-ac-power-supply",
+		.num_resources	= ARRAY_SIZE(axp20x_ac_power_supply_resources),
+		.resources	= axp20x_ac_power_supply_resources,
+	}, {
+		.name		= "axp20x-usb-power-supply",
+		.of_compatible	= "x-powers,axp202-usb-power-supply",
+		.num_resources	= ARRAY_SIZE(axp20x_usb_power_supply_resources),
+		.resources	= axp20x_usb_power_supply_resources,
+	},
+};
+
+static struct mfd_cell axp22x_cells[] = {
+	{
+		.name			= "axp20x-pek",
+		.num_resources		= ARRAY_SIZE(axp22x_pek_resources),
+		.resources		= axp22x_pek_resources,
+	}, {
+		.name			= "axp20x-regulator",
+	}, {
+		.name		= "axp20x-usb-power-supply",
+		.of_compatible	= "x-powers,axp221-usb-power-supply",
+		.num_resources	= ARRAY_SIZE(axp22x_usb_power_supply_resources),
+		.resources	= axp22x_usb_power_supply_resources,
+	},
+};
+
+#define AXP152_DCDC1_NAME "dcdc1"
+#define AXP152_DCDC2_NAME "dcdc2"
+#define AXP152_DCDC3_NAME "dcdc3"
+#define AXP152_DCDC4_NAME "dcdc4"
+#define AXP152_ALDO1_NAME "aldo1"
+#define AXP152_ALDO2_NAME "aldo2"
+#define AXP152_DLDO1_NAME "dldo1"
+#define AXP152_DLDO2_NAME "dldo2"
+#define AXP152_LDO0_NAME  "ldo0"
+static struct mfd_cell axp152_cells[] = {
+/*	{
+		.name			= "axp20x-pek",
+		.num_resources		= ARRAY_SIZE(axp152_pek_resources),
+		.resources		= axp152_pek_resources,
+	},*/
+	{
+		.name = "axp152-pek",
+		.num_resources = ARRAY_SIZE(axp152_pek_resources),
+		.resources = axp152_pek_resources,
+		.of_compatible = "x-powers,axp152-pek",
+	},
+	{
+		/* match drivers/regulator/axp2101.c */
+		.name = "axp2101-regulator",
+	},
+	{
+		/* match drivers/power/supply/axp152_vbus_power.c */
+		.name = "axp152-vbus",
+		.of_compatible = "x-powers,axp152-vbus",
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc1",
+		.name = "reg-virt-consumer",
+		.id = 1,
+		.platform_data = AXP152_DCDC1_NAME,
+		.pdata_size = sizeof(AXP152_DCDC1_NAME),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc2",
+		.name = "reg-virt-consumer",
+		.id = 2,
+		.platform_data = AXP152_DCDC2_NAME,
+		.pdata_size = sizeof(AXP152_DCDC2_NAME),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc3",
+		.name = "reg-virt-consumer",
+		.id = 3,
+		.platform_data = AXP152_DCDC3_NAME,
+		.pdata_size = sizeof(AXP152_DCDC3_NAME),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc4",
+		.name = "reg-virt-consumer",
+		.id = 4,
+		.platform_data = AXP152_DCDC4_NAME,
+		.pdata_size = sizeof(AXP152_DCDC4_NAME),
+	},
+	{
+		.of_compatible = "xpower-vregulator,aldo1",
+		.name = "reg-virt-consumer",
+		.id = 5,
+		.platform_data = AXP152_ALDO1_NAME,
+		.pdata_size = sizeof(AXP152_ALDO1_NAME),
+	},
+	{
+		.of_compatible = "xpower-vregulator,aldo2",
+		.name = "reg-virt-consumer",
+		.id = 6,
+		.platform_data = AXP152_ALDO2_NAME,
+		.pdata_size = sizeof(AXP152_ALDO2_NAME),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dldo1",
+		.name = "reg-virt-consumer",
+		.id = 7,
+		.platform_data = AXP152_DLDO1_NAME,
+		.pdata_size = sizeof(AXP152_DLDO1_NAME),
+	},
+	{
+		.of_compatible = "xpower-vregulator,ldo0",
+		.name = "reg-virt-consumer",
+		.id = 8,
+		.platform_data = AXP152_LDO0_NAME,
+		.pdata_size = sizeof(AXP152_LDO0_NAME),
+	},
+};
+
+static struct resource axp288_adc_resources[] = {
+	{
+		.name  = "GPADC",
+		.start = AXP288_IRQ_GPADC,
+		.end   = AXP288_IRQ_GPADC,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource axp2101_power_supply_resources[] = {
+	DEFINE_RES_IRQ_NAMED(AXP2101_IRQ_BWUT, "bat untemp work"),
+	DEFINE_RES_IRQ_NAMED(AXP2101_IRQ_BWOT, "bat ovtemp work"),
+	DEFINE_RES_IRQ_NAMED(AXP2101_IRQ_BCUT, "bat untemp chg"),
+	DEFINE_RES_IRQ_NAMED(AXP2101_IRQ_BCOT, "bat ovtemp chg"),
+	DEFINE_RES_IRQ_NAMED(AXP2101_IRQ_NEWSOC, "CHG_NEWSOC"),
+	DEFINE_RES_IRQ_NAMED(AXP2101_IRQ_GWDT, "CHG_GWDT"),
+	DEFINE_RES_IRQ_NAMED(AXP2101_IRQ_SOCWL1, "low warning1"),
+	DEFINE_RES_IRQ_NAMED(AXP2101_IRQ_SOCWL2, "low warning2"),
+	DEFINE_RES_IRQ_NAMED(AXP2101_IRQ_BREMOV, "bat out"),
+	DEFINE_RES_IRQ_NAMED(AXP2101_IRQ_BINSERT, "bat in"),
+	DEFINE_RES_IRQ_NAMED(AXP2101_IRQ_VINSET, "usb in"),
+	DEFINE_RES_IRQ_NAMED(AXP2101_IRQ_VREMOV, "usb out"),
+	DEFINE_RES_IRQ_NAMED(AXP2101_IRQ_BOVP, "CHG_BOVP"),
+	DEFINE_RES_IRQ_NAMED(AXP2101_IRQ_CHGTE, "CHG_CHGTE"),
+	DEFINE_RES_IRQ_NAMED(AXP2101_IRQ_DOTL1, "CHG_DOTL1"),
+	DEFINE_RES_IRQ_NAMED(AXP2101_IRQ_CHGST, "charging"),
+	DEFINE_RES_IRQ_NAMED(AXP2101_IRQ_CHGDN, "charge over"),
+	DEFINE_RES_IRQ_NAMED(AXP2101_IRQ_BOCP, "CHG_BOCP"),
+	DEFINE_RES_IRQ_NAMED(AXP2101_IRQ_LDOOC, "CHG_LDOOC"),
+	DEFINE_RES_IRQ_NAMED(AXP2101_IRQ_WDEXP, "CHG_WDEXP"),
+};
+
+static struct resource axp2101_pek_resources[] = {
+	DEFINE_RES_IRQ_NAMED(AXP2101_IRQ_PONN, "PEK_DBF"),
+	DEFINE_RES_IRQ_NAMED(AXP2101_IRQ_PONP, "PEK_DBR"),
+};
+/*
+static struct resource axp15_power_supply_resources[] = {
+	DEFINE_RES_IRQ_NAMED(AXP15_IRQ_ALDOIN_H2L, "aldoin H2L"),
+	DEFINE_RES_IRQ_NAMED(AXP15_IRQ_ALDOIN_L2H, "aldoin L2H"),
+	DEFINE_RES_IRQ_NAMED(AXP15_IRQ_LDO0IN_H2L, "ldoin H2L"),
+	DEFINE_RES_IRQ_NAMED(AXP15_IRQ_LDO0IN_L2H, "ldoin L2H"),
+	DEFINE_RES_IRQ_NAMED(AXP15_IRQ_PEKLO, "pek long"),
+	DEFINE_RES_IRQ_NAMED(AXP15_IRQ_PEKSH, "pek short"),
+	DEFINE_RES_IRQ_NAMED(AXP15_IRQ_DCDC4_V_LOW, "DCDC4 smaller"),
+	DEFINE_RES_IRQ_NAMED(AXP15_IRQ_DCDC3_V_LOW, "DCDC3 smaller"),
+	DEFINE_RES_IRQ_NAMED(AXP15_IRQ_DCDC2_V_LOW, "DCDC2 smaller"),
+	DEFINE_RES_IRQ_NAMED(AXP15_IRQ_DCDC1_V_LOW, "DCDC1 smaller"),
+	DEFINE_RES_IRQ_NAMED(AXP15_IRQ_EVENT_TIMEOUT, "envent timeout"),
+};
+*/
+static struct resource axp15_pek_resources[] = {
+	DEFINE_RES_IRQ_NAMED(AXP15_IRQ_PEKRE, "PEK_DBR"),
+	DEFINE_RES_IRQ_NAMED(AXP15_IRQ_PEKFE, "PEK_DBF"),
+};
+
+static struct resource axp15_gpio_resources[] = {
+	DEFINE_RES_IRQ_NAMED(AXP15_IRQ_GPIO0, "GPIO0 input"),
+	DEFINE_RES_IRQ_NAMED(AXP15_IRQ_GPIO1, "GPIO1 input"),
+	DEFINE_RES_IRQ_NAMED(AXP15_IRQ_GPIO2, "GPIO2 input"),
+	DEFINE_RES_IRQ_NAMED(AXP15_IRQ_GPIO3, "GPIO3 input"),
+};
+
+static struct resource axp1530_pek_resources[] = {
+	DEFINE_RES_IRQ_NAMED(AXP1530_IRQ_KEY_L2H_EN, "PEK_DBR"),
+	DEFINE_RES_IRQ_NAMED(AXP1530_IRQ_KEY_H2L_EN, "PEK_DBF"),
+};
+
+static struct resource axp858_pek_resources[] = {
+	DEFINE_RES_IRQ_NAMED(AXP858_IRQ_POKNIRQ_EN, "PEK_DBF"),
+	DEFINE_RES_IRQ_NAMED(AXP858_IRQ_POKPIRQ_EN, "PEK_DBR"),
+};
+
+static struct resource axp803_ac_power_supply_resources[] = {
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_ACIN, "ac in"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_ACRE, "ac out"),
+};
+
+static struct resource axp803_usb_power_supply_resources[] = {
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_USBIN, "usb in"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_USBRE, "usb out"),
+};
+
+static struct resource axp803_bat_power_supply_resources[] = {
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_BATINWORK, "bat untemp work"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_BATOVWORK, "bat ovtemp work"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_BATINCHG, "bat untemp chg"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_BATOVCHG, "bat ovtemp chg"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_LOWN1, "low warning1"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_LOWN2, "low warning2"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_BATRE, "bat out"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_BATIN, "bat in"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_CHAST, "charging"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_CHAOV, "charge over"),
+};
+
+static struct resource axp803_pek_resources[] = {
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_PEKFE, "PEK_DBF"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_PEKRE, "PEK_DBR"),
+};
+
+static struct resource axp806_pek_resources[] = {
+	DEFINE_RES_IRQ_NAMED(AXP806_IRQ_PWROK_FALL, "PEK_DBF"),
+	DEFINE_RES_IRQ_NAMED(AXP806_IRQ_PWROK_RISE, "PEK_DBR"),
+};
+
+static struct resource axp2202_pek_resources[] = {
+	DEFINE_RES_IRQ_NAMED(AXP2202_IRQ_PONN, "PEK_DBF"),
+	DEFINE_RES_IRQ_NAMED(AXP2202_IRQ_PONP, "PEK_DBR"),
+};
+
+static struct resource axp2202_ps_resources[] = {
+	DEFINE_RES_IRQ_NAMED(AXP2202_IRQ_SOCWL1, "soc_drop_w1"),
+	DEFINE_RES_IRQ_NAMED(AXP2202_IRQ_SOCWL2, "soc_drop_w2"),
+	DEFINE_RES_IRQ_NAMED(AXP2202_IRQ_NEWSOC, "gauge_new_soc"),
+	DEFINE_RES_IRQ_NAMED(AXP2202_IRQ_VBUS_OV, "vbus_over_volt"),
+	DEFINE_RES_IRQ_NAMED(AXP2202_IRQ_VINSERT, "vbus_insert"),
+	DEFINE_RES_IRQ_NAMED(AXP2202_IRQ_VREMOVE, "vbus_remove"),
+	DEFINE_RES_IRQ_NAMED(AXP2202_IRQ_BINSERT, "battery_insert"),
+	DEFINE_RES_IRQ_NAMED(AXP2202_IRQ_BREMOVE, "battery_remove"),
+	DEFINE_RES_IRQ_NAMED(AXP2202_IRQ_CHGDN, "battery_charge_done"),
+	DEFINE_RES_IRQ_NAMED(AXP2202_IRQ_CHGST, "battery_charge_start"),
+	DEFINE_RES_IRQ_NAMED(AXP2202_IRQ_BOVP, "battery_over_voltage"),
+	DEFINE_RES_IRQ_NAMED(AXP2202_IRQ_BC_DONE, "bc1_2_detected"),
+	DEFINE_RES_IRQ_NAMED(AXP2202_IRQ_BC_CHNG, "bc1_2_detect_change"),
+	DEFINE_RES_IRQ_NAMED(AXP2202_IRQ_RID_CHNG, "rid_detect_change"),
+	DEFINE_RES_IRQ_NAMED(AXP2202_IRQ_BCOT, "battery_over_temp_chg"),
+	DEFINE_RES_IRQ_NAMED(AXP2202_IRQ_BCUT, "battery_under_temp_chg"),
+	DEFINE_RES_IRQ_NAMED(AXP2202_IRQ_BWOT, "battery_over_temp_work"),
+	DEFINE_RES_IRQ_NAMED(AXP2202_IRQ_BWUT, "battery_under_temp_work"),
+	DEFINE_RES_IRQ_NAMED(AXP2202_IRQ_CREMOVE, "type-c_remove"),
+	DEFINE_RES_IRQ_NAMED(AXP2202_IRQ_CINSERT, "type-c_insert"),
+	DEFINE_RES_IRQ_NAMED(AXP2202_IRQ_TOGGLE_DONE, "type-c_toggle"),
+	DEFINE_RES_IRQ_NAMED(AXP2202_IRQ_VBUS_SAFE5V, "type-c_safe-5v"),
+	DEFINE_RES_IRQ_NAMED(AXP2202_IRQ_VBUS_SAFE0V, "type-c_safe-0v"),
+	DEFINE_RES_IRQ_NAMED(AXP2202_IRQ_PWR_CHNG, "type-c_state_change"),
+};
+
+static struct resource axp288_extcon_resources[] = {
+	{
+		.start = AXP288_IRQ_VBUS_FALL,
+		.end   = AXP288_IRQ_VBUS_FALL,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = AXP288_IRQ_VBUS_RISE,
+		.end   = AXP288_IRQ_VBUS_RISE,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = AXP288_IRQ_MV_CHNG,
+		.end   = AXP288_IRQ_MV_CHNG,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = AXP288_IRQ_BC_USB_CHNG,
+		.end   = AXP288_IRQ_BC_USB_CHNG,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource axp288_charger_resources[] = {
+	{
+		.start = AXP288_IRQ_OV,
+		.end   = AXP288_IRQ_OV,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = AXP288_IRQ_DONE,
+		.end   = AXP288_IRQ_DONE,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = AXP288_IRQ_CHARGING,
+		.end   = AXP288_IRQ_CHARGING,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = AXP288_IRQ_SAFE_QUIT,
+		.end   = AXP288_IRQ_SAFE_QUIT,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = AXP288_IRQ_SAFE_ENTER,
+		.end   = AXP288_IRQ_SAFE_ENTER,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = AXP288_IRQ_QCBTU,
+		.end   = AXP288_IRQ_QCBTU,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = AXP288_IRQ_CBTU,
+		.end   = AXP288_IRQ_CBTU,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = AXP288_IRQ_QCBTO,
+		.end   = AXP288_IRQ_QCBTO,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = AXP288_IRQ_CBTO,
+		.end   = AXP288_IRQ_CBTO,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct mfd_cell axp288_cells[] = {
+	{
+		.name = "axp288_adc",
+		.num_resources = ARRAY_SIZE(axp288_adc_resources),
+		.resources = axp288_adc_resources,
+	},
+	{
+		.name = "axp288_extcon",
+		.num_resources = ARRAY_SIZE(axp288_extcon_resources),
+		.resources = axp288_extcon_resources,
+	},
+	{
+		.name = "axp288_charger",
+		.num_resources = ARRAY_SIZE(axp288_charger_resources),
+		.resources = axp288_charger_resources,
+	},
+	{
+		.name = "axp288_fuel_gauge",
+		.num_resources = ARRAY_SIZE(axp288_fuel_gauge_resources),
+		.resources = axp288_fuel_gauge_resources,
+	},
+	{
+		.name = "axp20x-pek",
+		.num_resources = ARRAY_SIZE(axp288_power_button_resources),
+		.resources = axp288_power_button_resources,
+	},
+	{
+		.name = "axp288_pmic_acpi",
+	},
+};
+
+#define AXP806_DCDC1_NAME "dcdc1"
+#define AXP806_DCDC2_NAME "dcdc2"
+#define AXP806_DCDC3_NAME "dcdc3"
+#define AXP806_DCDC4_NAME "dcdc4"
+#define AXP806_DCDC5_NAME "dcdc5"
+#define AXP806_ALDO1_NAME "aldo1"
+#define AXP806_ALDO2_NAME "aldo2"
+#define AXP806_ALDO3_NAME "aldo3"
+#define AXP806_BLDO1_NAME "bldo1"
+#define AXP806_BLDO2_NAME "bldo2"
+#define AXP806_BLDO3_NAME "bldo3"
+#define AXP806_BLDO4_NAME "bldo4"
+#define AXP806_CLDO1_NAME "cldo1"
+#define AXP806_CLDO2_NAME "cldo2"
+#define AXP806_CLDO3_NAME "cldo3"
+static struct mfd_cell axp806_cells[] = {
+	{
+		.name = "axp2101-pek",
+		.num_resources = ARRAY_SIZE(axp806_pek_resources),
+		.resources = axp806_pek_resources,
+		.of_compatible = "x-powers,axp2101-pek",
+	},
+	{
+		.name = "axp2101-regulator",
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc1",
+		.name = "reg-virt-consumer",
+		.id = 1,
+		.platform_data = AXP806_DCDC1_NAME,
+		.pdata_size = sizeof(AXP806_DCDC1_NAME),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc2",
+		.name = "reg-virt-consumer",
+		.id = 2,
+		.platform_data = AXP806_DCDC2_NAME,
+		.pdata_size = sizeof(AXP806_DCDC2_NAME),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc3",
+		.name = "reg-virt-consumer",
+		.id = 3,
+		.platform_data = AXP806_DCDC3_NAME,
+		.pdata_size = sizeof(AXP806_DCDC3_NAME),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc4",
+		.name = "reg-virt-consumer",
+		.id = 4,
+		.platform_data = AXP806_DCDC4_NAME,
+		.pdata_size = sizeof(AXP806_DCDC4_NAME),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc5",
+		.name = "reg-virt-consumer",
+		.id = 5,
+		.platform_data = AXP806_DCDC5_NAME,
+		.pdata_size = sizeof(AXP806_DCDC5_NAME),
+	},
+	{
+		.of_compatible = "xpower-vregulator,aldo1",
+		.name = "reg-virt-consumer",
+		.id = 6,
+		.platform_data = AXP806_ALDO1_NAME,
+		.pdata_size = sizeof(AXP806_ALDO1_NAME),
+	},
+	{
+		.of_compatible = "xpower-vregulator,aldo2",
+		.name = "reg-virt-consumer",
+		.id = 7,
+		.platform_data = AXP806_ALDO2_NAME,
+		.pdata_size = sizeof(AXP806_ALDO2_NAME),
+	},
+	{
+		.of_compatible = "xpower-vregulator,aldo3",
+		.name = "reg-virt-consumer",
+		.id = 8,
+		.platform_data = AXP806_ALDO3_NAME,
+		.pdata_size = sizeof(AXP806_ALDO3_NAME),
+	},
+	{
+		.of_compatible = "xpower-vregulator,bldo1",
+		.name = "reg-virt-consumer",
+		.id = 9,
+		.platform_data = AXP806_BLDO1_NAME,
+		.pdata_size = sizeof(AXP806_BLDO1_NAME),
+	},
+	{
+		.of_compatible = "xpower-vregulator,bldo2",
+		.name = "reg-virt-consumer",
+		.id = 10,
+		.platform_data = AXP806_BLDO2_NAME,
+		.pdata_size = sizeof(AXP806_BLDO2_NAME),
+	},
+	{
+		.of_compatible = "xpower-vregulator,bldo3",
+		.name = "reg-virt-consumer",
+		.id = 11,
+		.platform_data = AXP806_BLDO3_NAME,
+		.pdata_size = sizeof(AXP806_BLDO3_NAME),
+	},
+	{
+		.of_compatible = "xpower-vregulator,bldo4",
+		.name = "reg-virt-consumer",
+		.id = 12,
+		.platform_data = AXP806_BLDO4_NAME,
+		.pdata_size = sizeof(AXP806_BLDO4_NAME),
+	},
+	{
+		.of_compatible = "xpower-vregulator,cldo1",
+		.name = "reg-virt-consumer",
+		.id = 13,
+		.platform_data = AXP806_CLDO1_NAME,
+		.pdata_size = sizeof(AXP806_CLDO1_NAME),
+	},
+	{
+		.of_compatible = "xpower-vregulator,cldo2",
+		.name = "reg-virt-consumer",
+		.id = 14,
+		.platform_data = AXP806_CLDO2_NAME,
+		.pdata_size = sizeof(AXP806_CLDO2_NAME),
+	},
+	{
+		.of_compatible = "xpower-vregulator,cldo3",
+		.name = "reg-virt-consumer",
+		.id = 15,
+		.platform_data = AXP806_CLDO3_NAME,
+		.pdata_size = sizeof(AXP806_CLDO3_NAME),
+	},
+};
+
+static struct mfd_cell axp809_cells[] = {
+	{
+		.name			= "axp20x-pek",
+		.num_resources		= ARRAY_SIZE(axp809_pek_resources),
+		.resources		= axp809_pek_resources,
+	}, {
+		.id			= 1,
+		.name			= "axp20x-regulator",
+	},
+};
+
+
+#define AXP2101_DCDC1 "dcdc1"
+#define AXP2101_DCDC2 "dcdc2"
+#define AXP2101_DCDC3 "dcdc3"
+#define AXP2101_DCDC4 "dcdc4"
+#define AXP2101_DCDC5 "dcdc5"
+#define AXP2101_ALDO1 "aldo1"
+#define AXP2101_ALDO2 "aldo2"
+#define AXP2101_ALDO3 "aldo3"
+#define AXP2101_ALDO4 "aldo4"
+#define AXP2101_BLDO1 "bldo1"
+#define AXP2101_BLDO2 "bldo2"
+#define AXP2101_DLDO1 "dldo1"
+#define AXP2101_DLDO2 "dldo2"
+
+static struct mfd_cell axp2101_cells[] = {
+	/*{
+.name		= "axp2101-gpio",
+.of_compatible	= "x-powers,axp2101-gpio",
+}, */
+	{
+		.name = "axp2101-pek",
+		.num_resources = ARRAY_SIZE(axp2101_pek_resources),
+		.resources = axp2101_pek_resources,
+		.of_compatible = "x-powers,axp2101-pek",
+	},
+	{
+		.name = "axp2101-regulator",
+	},
+	{
+		.name = "axp2101-power-supply",
+		.of_compatible = "x-powers,axp2101-power-supply",
+		.num_resources = ARRAY_SIZE(axp2101_power_supply_resources),
+		.resources = axp2101_power_supply_resources,
+	},
+	{
+		.name = "axp2xx-watchdog",
+		.of_compatible = "x-powers,axp2xx-watchdog",
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc1",
+		.name = "reg-virt-consumer",
+		.id = 1,
+		.platform_data = AXP2101_DCDC1,
+		.pdata_size = sizeof(AXP2101_DCDC1),
+
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc2",
+		.name = "reg-virt-consumer",
+		.id = 2,
+		.platform_data = AXP2101_DCDC2,
+		.pdata_size = sizeof(AXP2101_DCDC2),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc3",
+		.name = "reg-virt-consumer",
+		.id = 3,
+		.platform_data = AXP2101_DCDC3,
+		.pdata_size = sizeof(AXP2101_DCDC3),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc4",
+		.name = "reg-virt-consumer",
+		.id = 4,
+		.platform_data = AXP2101_DCDC4,
+		.pdata_size = sizeof(AXP2101_DCDC4),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc5",
+		.name = "reg-virt-consumer",
+		.id = 5,
+		.platform_data = AXP2101_DCDC5,
+		.pdata_size = sizeof(AXP2101_DCDC5),
+	},
+
+	{
+		.of_compatible = "xpower-vregulator,aldo1",
+		.name = "reg-virt-consumer",
+		.id = 8,
+		.platform_data = AXP2101_ALDO1,
+		.pdata_size = sizeof(AXP2101_ALDO1),
+	},
+	{
+		.of_compatible = "xpower-vregulator,aldo2",
+		.name = "reg-virt-consumer",
+		.id = 9,
+		.platform_data = AXP2101_ALDO2,
+		.pdata_size = sizeof(AXP2101_ALDO2),
+	},
+	{
+		.of_compatible = "xpower-vregulator,aldo3",
+		.name = "reg-virt-consumer",
+		.id = 10,
+		.platform_data = AXP2101_ALDO3,
+		.pdata_size = sizeof(AXP2101_ALDO3),
+	},
+	{
+		.of_compatible = "xpower-vregulator,aldo4",
+		.name = "reg-virt-consumer",
+		.id = 11,
+		.platform_data = AXP2101_ALDO4,
+		.pdata_size = sizeof(AXP2101_ALDO4),
+	},
+
+	{
+		.of_compatible = "xpower-vregulator,bldo1",
+		.name = "reg-virt-consumer",
+		.id = 12,
+		.platform_data = AXP2101_BLDO1,
+		.pdata_size = sizeof(AXP2101_BLDO1),
+	},
+	{
+		.of_compatible = "xpower-vregulator,bldo2",
+		.name = "reg-virt-consumer",
+		.id = 13,
+		.platform_data = AXP2101_BLDO2,
+		.pdata_size = sizeof(AXP2101_BLDO2),
+	},
+
+	{
+		.of_compatible = "xpower-vregulator,dldo1",
+		.name = "reg-virt-consumer",
+		.id = 14,
+		.platform_data = AXP2101_DLDO1,
+		.pdata_size = sizeof(AXP2101_DLDO1),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dldo2",
+		.name = "reg-virt-consumer",
+		.id = 15,
+		.platform_data = AXP2101_DLDO2,
+		.pdata_size = sizeof(AXP2101_DLDO2),
+	},
+};
+/***************************************/
+#define AXP15_DCDC1 "dcdc1"
+#define AXP15_DCDC2 "dcdc2"
+#define AXP15_DCDC3 "dcdc3"
+#define AXP15_DCDC4 "dcdc4"
+#define AXP15_DCDC5 "dcdc5"
+#define AXP15_ALDO1 "aldo1"
+#define AXP15_ALDO2 "aldo2"
+#define AXP15_ALDO3 "aldo3"
+#define AXP15_ALDO4 "aldo4"
+#define AXP15_BLDO1 "bldo1"
+#define AXP15_BLDO2 "bldo2"
+#define AXP15_DLDO1 "dldo1"
+#define AXP15_DLDO2 "dldo2"
+
+static struct mfd_cell axp15_cells[] = {
+	{
+		.name		= "axp15-gpio",
+		.of_compatible	= "x-powers,axp15-gpio",
+		.num_resources = ARRAY_SIZE(axp15_gpio_resources),
+		.resources = axp15_gpio_resources,
+	},
+	{
+		.name = "axp15-pek",
+		.num_resources = ARRAY_SIZE(axp15_pek_resources),
+		.resources = axp15_pek_resources,
+		.of_compatible = "x-powers,axp15-pek",
+	},
+	{
+		.name = "axp15-regulator",
+	},
+/*	{
+		.name = "axp15-power-supply",
+		.of_compatible = "x-powers,axp15-power-supply",
+	},*/
+	{
+		.of_compatible = "xpower-vregulator,dcdc1",
+		.name = "reg-virt-consumer",
+		.id = 1,
+		.platform_data = AXP15_DCDC1,
+		.pdata_size = sizeof(AXP15_DCDC1),
+
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc2",
+		.name = "reg-virt-consumer",
+		.id = 2,
+		.platform_data = AXP15_DCDC2,
+		.pdata_size = sizeof(AXP15_DCDC2),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc3",
+		.name = "reg-virt-consumer",
+		.id = 3,
+		.platform_data = AXP15_DCDC3,
+		.pdata_size = sizeof(AXP15_DCDC3),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc4",
+		.name = "reg-virt-consumer",
+		.id = 4,
+		.platform_data = AXP15_DCDC4,
+		.pdata_size = sizeof(AXP15_DCDC4),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc5",
+		.name = "reg-virt-consumer",
+		.id = 5,
+		.platform_data = AXP15_DCDC5,
+		.pdata_size = sizeof(AXP15_DCDC5),
+	},
+
+	{
+		.of_compatible = "xpower-vregulator,aldo1",
+		.name = "reg-virt-consumer",
+		.id = 8,
+		.platform_data = AXP15_ALDO1,
+		.pdata_size = sizeof(AXP15_ALDO1),
+	},
+	{
+		.of_compatible = "xpower-vregulator,aldo2",
+		.name = "reg-virt-consumer",
+		.id = 9,
+		.platform_data = AXP15_ALDO2,
+		.pdata_size = sizeof(AXP15_ALDO2),
+	},
+	{
+		.of_compatible = "xpower-vregulator,aldo3",
+		.name = "reg-virt-consumer",
+		.id = 10,
+		.platform_data = AXP15_ALDO3,
+		.pdata_size = sizeof(AXP15_ALDO3),
+	},
+	{
+		.of_compatible = "xpower-vregulator,aldo4",
+		.name = "reg-virt-consumer",
+		.id = 11,
+		.platform_data = AXP15_ALDO4,
+		.pdata_size = sizeof(AXP15_ALDO4),
+	},
+
+	{
+		.of_compatible = "xpower-vregulator,bldo1",
+		.name = "reg-virt-consumer",
+		.id = 12,
+		.platform_data = AXP15_BLDO1,
+		.pdata_size = sizeof(AXP15_BLDO1),
+	},
+	{
+		.of_compatible = "xpower-vregulator,bldo2",
+		.name = "reg-virt-consumer",
+		.id = 13,
+		.platform_data = AXP15_BLDO2,
+		.pdata_size = sizeof(AXP15_BLDO2),
+	},
+
+	{
+		.of_compatible = "xpower-vregulator,dldo1",
+		.name = "reg-virt-consumer",
+		.id = 14,
+		.platform_data = AXP15_DLDO1,
+		.pdata_size = sizeof(AXP15_DLDO1),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dldo2",
+		.name = "reg-virt-consumer",
+		.id = 15,
+		.platform_data = AXP15_DLDO2,
+		.pdata_size = sizeof(AXP15_DLDO2),
+	},
+};
+/***************************************/
+#define AXP1530_DCDC1 "dcdc1"
+#define AXP1530_DCDC2 "dcdc2"
+#define AXP1530_DCDC3 "dcdc3"
+#define AXP1530_ALDO1 "aldo1"
+#define AXP1530_DLDO1 "dldo1"
+
+static struct mfd_cell axp1530_cells[] = {
+	{
+		.name		= "axp1530-gpio",
+		.of_compatible	= "x-powers,axp1530-gpio",
+/*		.num_resources = ARRAY_SIZE(axp1530_gpio_resources),
+		.resources = axp1530_gpio_resources,*/
+	},
+	{
+		.name = "axp2101-pek",
+		.num_resources = ARRAY_SIZE(axp1530_pek_resources),
+		.resources = axp1530_pek_resources,
+		.of_compatible = "x-powers,axp2101-pek",
+	},
+	{
+		/* match drivers/regulator/axp2101.c */
+		.name = "axp2101-regulator",
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc1",
+		.name = "reg-virt-consumer",
+		.id = 1,
+		.platform_data = AXP1530_DCDC1,
+		.pdata_size = sizeof(AXP1530_DCDC1),
+
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc2",
+		.name = "reg-virt-consumer",
+		.id = 2,
+		.platform_data = AXP1530_DCDC2,
+		.pdata_size = sizeof(AXP1530_DCDC2),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc3",
+		.name = "reg-virt-consumer",
+		.id = 3,
+		.platform_data = AXP1530_DCDC3,
+		.pdata_size = sizeof(AXP1530_DCDC3),
+	},
+	{
+		.of_compatible = "xpower-vregulator,aldo1",
+		.name = "reg-virt-consumer",
+		.id = 4,
+		.platform_data = AXP1530_ALDO1,
+		.pdata_size = sizeof(AXP1530_ALDO1),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dldo1",
+		.name = "reg-virt-consumer",
+		.id = 5,
+		.platform_data = AXP1530_DLDO1,
+		.pdata_size = sizeof(AXP1530_DLDO1),
+	},
+};
+/**************************************/
+#define AXP858_DCDC1 "dcdc1"
+#define AXP858_DCDC2 "dcdc2"
+#define AXP858_DCDC3 "dcdc3"
+#define AXP858_DCDC4 "dcdc4"
+#define AXP858_DCDC5 "dcdc5"
+#define AXP858_DCDC6 "dcdc6"
+#define AXP858_ALDO1 "aldo1"
+#define AXP858_ALDO2 "aldo2"
+#define AXP858_ALDO3 "aldo3"
+#define AXP858_ALDO4 "aldo4"
+#define AXP858_ALDO5 "aldo5"
+#define AXP858_BLDO1 "bldo1"
+#define AXP858_BLDO2 "bldo2"
+#define AXP858_BLDO3 "bldo3"
+#define AXP858_BLDO4 "bldo4"
+#define AXP858_BLDO5 "bldo5"
+#define AXP858_CLDO1 "cldo1"
+#define AXP858_CLDO2 "cldo2"
+#define AXP858_CLDO3 "cldo3"
+#define AXP858_CLDO4 "cldo4"
+#define AXP858_CPUSLDO "cpusldo"
+#define AXP858_SWOUT "swout"
+
+static struct mfd_cell axp858_cells[] = {
+	{
+		.name		= "axp858-gpio",
+		.of_compatible	= "x-powers,axp858-gpio",
+/*		.num_resources = ARRAY_SIZE(axp1530_gpio_resources),
+		.resources = axp1530_gpio_resources,*/
+	},
+	{
+		.name = "axp2101-pek",
+		.num_resources = ARRAY_SIZE(axp858_pek_resources),
+		.resources = axp858_pek_resources,
+		.of_compatible = "x-powers,axp2101-pek",
+	},
+	{
+		.name = "axp2101-regulator",
+	},
+/*	{
+		.name = "axp15-power-supply",
+		.of_compatible = "x-powers,axp15-power-supply",
+	},*/
+	{
+		.of_compatible = "xpower-vregulator,dcdc1",
+		.name = "reg-virt-consumer",
+		.id = 1,
+		.platform_data = AXP858_DCDC1,
+		.pdata_size = sizeof(AXP858_DCDC1),
+
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc2",
+		.name = "reg-virt-consumer",
+		.id = 2,
+		.platform_data = AXP858_DCDC2,
+		.pdata_size = sizeof(AXP858_DCDC2),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc3",
+		.name = "reg-virt-consumer",
+		.id = 3,
+		.platform_data = AXP858_DCDC3,
+		.pdata_size = sizeof(AXP858_DCDC3),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc4",
+		.name = "reg-virt-consumer",
+		.id = 4,
+		.platform_data = AXP858_DCDC4,
+		.pdata_size = sizeof(AXP858_DCDC4),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc5",
+		.name = "reg-virt-consumer",
+		.id = 5,
+		.platform_data = AXP858_DCDC5,
+		.pdata_size = sizeof(AXP858_DCDC5),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc6",
+		.name = "reg-virt-consumer",
+		.id = 6,
+		.platform_data = AXP858_DCDC6,
+		.pdata_size = sizeof(AXP858_DCDC6),
+	},
+	{
+		.of_compatible = "xpower-vregulator,aldo1",
+		.name = "reg-virt-consumer",
+		.id = 7,
+		.platform_data = AXP858_ALDO1,
+		.pdata_size = sizeof(AXP858_ALDO1),
+	},
+	{
+		.of_compatible = "xpower-vregulator,aldo2",
+		.name = "reg-virt-consumer",
+		.id = 8,
+		.platform_data = AXP858_ALDO2,
+		.pdata_size = sizeof(AXP858_ALDO2),
+	},
+	{
+		.of_compatible = "xpower-vregulator,aldo3",
+		.name = "reg-virt-consumer",
+		.id = 9,
+		.platform_data = AXP858_ALDO3,
+		.pdata_size = sizeof(AXP858_ALDO3),
+	},
+	{
+		.of_compatible = "xpower-vregulator,aldo4",
+		.name = "reg-virt-consumer",
+		.id = 10,
+		.platform_data = AXP858_ALDO4,
+		.pdata_size = sizeof(AXP858_ALDO4),
+	},
+	{
+		.of_compatible = "xpower-vregulator,aldo5",
+		.name = "reg-virt-consumer",
+		.id = 11,
+		.platform_data = AXP858_ALDO5,
+		.pdata_size = sizeof(AXP858_ALDO5),
+	},
+	{
+		.of_compatible = "xpower-vregulator,bldo1",
+		.name = "reg-virt-consumer",
+		.id = 12,
+		.platform_data = AXP858_BLDO1,
+		.pdata_size = sizeof(AXP858_BLDO1),
+	},
+	{
+		.of_compatible = "xpower-vregulator,bldo2",
+		.name = "reg-virt-consumer",
+		.id = 13,
+		.platform_data = AXP858_BLDO2,
+		.pdata_size = sizeof(AXP858_BLDO2),
+	},
+	{
+		.of_compatible = "xpower-vregulator,bldo3",
+		.name = "reg-virt-consumer",
+		.id = 14,
+		.platform_data = AXP858_BLDO3,
+		.pdata_size = sizeof(AXP858_BLDO3),
+	},
+	{
+		.of_compatible = "xpower-vregulator,bldo4",
+		.name = "reg-virt-consumer",
+		.id = 15,
+		.platform_data = AXP858_BLDO4,
+		.pdata_size = sizeof(AXP858_BLDO4),
+	},
+	{
+		.of_compatible = "xpower-vregulator,bldo5",
+		.name = "reg-virt-consumer",
+		.id = 16,
+		.platform_data = AXP858_BLDO5,
+		.pdata_size = sizeof(AXP858_BLDO5),
+	},
+	{
+		.of_compatible = "xpower-vregulator,cldo1",
+		.name = "reg-virt-consumer",
+		.id = 17,
+		.platform_data = AXP858_CLDO1,
+		.pdata_size = sizeof(AXP858_CLDO1),
+	},
+	{
+		.of_compatible = "xpower-vregulator,cldo2",
+		.name = "reg-virt-consumer",
+		.id = 18,
+		.platform_data = AXP858_CLDO2,
+		.pdata_size = sizeof(AXP858_CLDO2),
+	},
+	{
+		.of_compatible = "xpower-vregulator,cldo3",
+		.name = "reg-virt-consumer",
+		.id = 19,
+		.platform_data = AXP858_CLDO3,
+		.pdata_size = sizeof(AXP858_CLDO3),
+	},
+	{
+		.of_compatible = "xpower-vregulator,cldo4",
+		.name = "reg-virt-consumer",
+		.id = 20,
+		.platform_data = AXP858_CLDO4,
+		.pdata_size = sizeof(AXP858_CLDO4),
+	},
+	{
+		.of_compatible = "xpower-vregulator,cpusldo",
+		.name = "reg-virt-consumer",
+		.id = 21,
+		.platform_data = AXP858_CPUSLDO,
+		.pdata_size = sizeof(AXP858_CPUSLDO),
+	},
+	{
+		.of_compatible = "xpower-vregulator,swout",
+		.name = "reg-virt-consumer",
+		.id = 22,
+		.platform_data = AXP858_SWOUT,
+		.pdata_size = sizeof(AXP858_SWOUT),
+	},
+
+};
+
+#define AXP803_DCDC1 "dcdc1"
+#define AXP803_DCDC2 "dcdc2"
+#define AXP803_DCDC3 "dcdc3"
+#define AXP803_DCDC4 "dcdc4"
+#define AXP803_DCDC5 "dcdc5"
+#define AXP803_DCDC6 "dcdc6"
+#define AXP803_DCDC7 "dcdc7"
+#define AXP803_RTCLDO "rtcldo"
+#define AXP803_ALDO1 "aldo1"
+#define AXP803_ALDO2 "aldo2"
+#define AXP803_ALDO3 "aldo3"
+#define AXP803_DLDO1 "dldo1"
+#define AXP803_DLDO2 "dldo2"
+#define AXP803_DLDO3 "dldo3"
+#define AXP803_DLDO4 "dldo4"
+#define AXP803_ELDO1 "eldo1"
+#define AXP803_ELDO2 "eldo2"
+#define AXP803_ELDO3 "eldo3"
+#define AXP803_FLDO1 "fldo1"
+#define AXP803_FLDO2 "fldo2"
+#define AXP803_LDOIO0 "ldoio0"
+#define AXP803_LDOIO1 "ldoio1"
+#define AXP803_DC1SW "dc1sw"
+#define AXP803_DRIVEVBUS "drivevbus"
+
+static struct mfd_cell axp803_cells[] = {
+	{
+		.name = "axp803-gpio",
+		.of_compatible = "x-powers,axp803-gpio",
+	},
+	{
+		.name = "axp2101-pek",
+		.num_resources = ARRAY_SIZE(axp803_pek_resources),
+		.resources = axp803_pek_resources,
+		.of_compatible = "x-powers,axp2101-pek",
+	},
+	{
+		.name = "axp2101-regulator",
+	},
+	{
+		.name		= "axp803-battery-power-supply",
+		.of_compatible	= "x-powers,axp803-battery-power-supply",
+		.num_resources	= ARRAY_SIZE(axp803_bat_power_supply_resources),
+		.resources	= axp803_bat_power_supply_resources,
+	},
+	{
+		.name		= "axp803-ac-power-supply",
+		.of_compatible	= "x-powers,axp803-ac-power-supply",
+		.num_resources	= ARRAY_SIZE(axp803_ac_power_supply_resources),
+		.resources	= axp803_ac_power_supply_resources,
+	},
+	{
+		.name		= "axp803-usb-power-supply",
+		.of_compatible	= "x-powers,axp803-usb-power-supply",
+		.num_resources	= ARRAY_SIZE(axp803_usb_power_supply_resources),
+		.resources	= axp803_usb_power_supply_resources,
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc1",
+		.name = "reg-virt-consumer",
+		.id = 1,
+		.platform_data = AXP803_DCDC1,
+		.pdata_size = sizeof(AXP803_DCDC1),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc2",
+		.name = "reg-virt-consumer",
+		.id = 2,
+		.platform_data = AXP803_DCDC2,
+		.pdata_size = sizeof(AXP803_DCDC2),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc3",
+		.name = "reg-virt-consumer",
+		.id = 3,
+		.platform_data = AXP803_DCDC3,
+		.pdata_size = sizeof(AXP803_DCDC3),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc4",
+		.name = "reg-virt-consumer",
+		.id = 4,
+		.platform_data = AXP803_DCDC4,
+		.pdata_size = sizeof(AXP803_DCDC4),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc5",
+		.name = "reg-virt-consumer",
+		.id = 5,
+		.platform_data = AXP803_DCDC5,
+		.pdata_size = sizeof(AXP803_DCDC5),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc6",
+		.name = "reg-virt-consumer",
+		.id = 6,
+		.platform_data = AXP803_DCDC6,
+		.pdata_size = sizeof(AXP803_DCDC6),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dcdc7",
+		.name = "reg-virt-consumer",
+		.id = 7,
+		.platform_data = AXP803_DCDC7,
+		.pdata_size = sizeof(AXP803_DCDC6),
+	},
+	{
+		.of_compatible = "xpower-vregulator,rtcldo",
+		.name = "reg-virt-consumer",
+		.id = 8,
+		.platform_data = AXP803_RTCLDO,
+		.pdata_size = sizeof(AXP803_RTCLDO),
+	},
+	{
+		.of_compatible = "xpower-vregulator,aldo1",
+		.name = "reg-virt-consumer",
+		.id = 9,
+		.platform_data = AXP803_ALDO1,
+		.pdata_size = sizeof(AXP803_ALDO1),
+	},
+	{
+		.of_compatible = "xpower-vregulator,aldo2",
+		.name = "reg-virt-consumer",
+		.id = 10,
+		.platform_data = AXP803_ALDO2,
+		.pdata_size = sizeof(AXP803_ALDO2),
+	},
+	{
+		.of_compatible = "xpower-vregulator,aldo3",
+		.name = "reg-virt-consumer",
+		.id = 11,
+		.platform_data = AXP803_ALDO3,
+		.pdata_size = sizeof(AXP803_ALDO3),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dldo1",
+		.name = "reg-virt-consumer",
+		.id = 12,
+		.platform_data = AXP803_DLDO1,
+		.pdata_size = sizeof(AXP803_DLDO1),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dldo2",
+		.name = "reg-virt-consumer",
+		.id = 13,
+		.platform_data = AXP803_DLDO2,
+		.pdata_size = sizeof(AXP803_DLDO2),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dldo3",
+		.name = "reg-virt-consumer",
+		.id = 14,
+		.platform_data = AXP803_DLDO3,
+		.pdata_size = sizeof(AXP803_DLDO3),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dldo4",
+		.name = "reg-virt-consumer",
+		.id = 15,
+		.platform_data = AXP803_DLDO4,
+		.pdata_size = sizeof(AXP803_DLDO4),
+	},
+	{
+		.of_compatible = "xpower-vregulator,eldo1",
+		.name = "reg-virt-consumer",
+		.id = 16,
+		.platform_data = AXP803_ELDO1,
+		.pdata_size = sizeof(AXP803_ELDO1),
+	},
+	{
+		.of_compatible = "xpower-vregulator,eldo2",
+		.name = "reg-virt-consumer",
+		.id = 17,
+		.platform_data = AXP803_ELDO2,
+		.pdata_size = sizeof(AXP803_ELDO2),
+	},
+	{
+		.of_compatible = "xpower-vregulator,eldo3",
+		.name = "reg-virt-consumer",
+		.id = 18,
+		.platform_data = AXP803_ELDO3,
+		.pdata_size = sizeof(AXP803_ELDO3),
+	},
+	{
+		.of_compatible = "xpower-vregulator,fldo1",
+		.name = "reg-virt-consumer",
+		.id = 19,
+		.platform_data = AXP803_FLDO1,
+		.pdata_size = sizeof(AXP803_FLDO1),
+	},
+	{
+		.of_compatible = "xpower-vregulator,fldo2",
+		.name = "reg-virt-consumer",
+		.id = 20,
+		.platform_data = AXP803_FLDO2,
+		.pdata_size = sizeof(AXP803_FLDO2),
+	},
+	{
+		.of_compatible = "xpower-vregulator,ldoio0",
+		.name = "reg-virt-consumer",
+		.id = 21,
+		.platform_data = AXP803_LDOIO0,
+		.pdata_size = sizeof(AXP803_LDOIO0),
+	},
+	{
+		.of_compatible = "xpower-vregulator,ldoio1",
+		.name = "reg-virt-consumer",
+		.id = 22,
+		.platform_data = AXP803_LDOIO1,
+		.pdata_size = sizeof(AXP803_LDOIO1),
+	},
+	{
+		.of_compatible = "xpower-vregulator,dc1sw",
+		.name = "reg-virt-consumer",
+		.id = 23,
+		.platform_data = AXP803_DC1SW,
+		.pdata_size = sizeof(AXP803_DC1SW),
+	},
+	{
+		.of_compatible = "xpower-vregulator,drivevbus",
+		.name = "reg-virt-consumer",
+		.id = 24,
+		.platform_data = AXP803_DRIVEVBUS,
+		.pdata_size = sizeof(AXP803_DRIVEVBUS),
+	},
+};
+
+static struct mfd_cell axp2202_cells[] = {
+	{
+		.name = "axp2202-gpio",
+		.of_compatible = "x-powers,axp2202-gpio",
+	},
+	{
+		.name = "axp2202-regulator",
+		.of_compatible = "x-powers,axp2202-regulator",
+	},
+	{
+		.name = "axp2202-pek",
+		.of_compatible = "x-powers,axp2202-pek",
+		.resources = axp2202_pek_resources,
+		.num_resources = ARRAY_SIZE(axp2202_pek_resources),
+
+	},
+	{
+		.name = "axp2202-power-supply",
+		.of_compatible = "x-powers.axp2202-power-supply",
+		.resources = axp2202_ps_resources,
+		.num_resources = ARRAY_SIZE(axp2202_ps_resources),
+	},
+};
+
+/*----------------------*/
+static struct axp20x_dev *axp20x_pm_power_off;
+static void axp20x_power_off(void)
+{
+	if (axp20x_pm_power_off->variant == AXP288_ID)
+		return;
+
+	regmap_write(axp20x_pm_power_off->regmap, AXP20X_OFF_CTRL,
+		     AXP20X_OFF);
+
+	/* Give capacitors etc. time to drain to avoid kernel panic msg. */
+	msleep(500);
+}
+
+/*
+ * axp2101_dts_parse - axp2101 device tree parse
+ */
+static void axp2101_dts_parse(struct axp20x_dev *axp20x)
+{
+	if (of_property_read_bool(axp20x->dev->of_node, "pmu_powerok_noreset")) {
+		regmap_update_bits(axp20x->regmap, AXP2101_COMM_CFG, BIT(3), 0);
+	} else {
+		regmap_update_bits(axp20x->regmap, AXP2101_COMM_CFG, BIT(3),
+				   BIT(3));
+	}
+}
+
+static void axp803_dts_parse(struct axp20x_dev *axp20x)
+{
+	struct device_node *node = axp20x->dev->of_node;
+	struct regmap *map = axp20x->regmap;
+	u32 val;
+
+	/* init 16's reset pmu en */
+	if (of_property_read_u32(node, "pmu_reset", &val))
+		val = 0;
+	if (val) {
+		regmap_update_bits(map, AXP803_HOTOVER_CTL, BIT(3), BIT(3));
+	} else {
+		regmap_update_bits(map, AXP803_HOTOVER_CTL, BIT(3), 0);
+	}
+
+	/* init irq wakeup en */
+	if (of_property_read_u32(node, "pmu_irq_wakeup", &val))
+		val = 0;
+	if (val) {
+		regmap_update_bits(map, AXP803_HOTOVER_CTL, BIT(7), BIT(7));
+	} else {
+		regmap_update_bits(map, AXP803_HOTOVER_CTL, BIT(7), 0);
+	}
+
+	/* init pmu over temperature protection */
+	if (of_property_read_u32(node, "pmu_hot_shutdown", &val))
+		val = 1;
+	if (val) {
+		regmap_update_bits(map, AXP803_HOTOVER_CTL, BIT(2), BIT(2));
+	} else {
+		regmap_update_bits(map, AXP803_HOTOVER_CTL, BIT(2), 0);
+	}
+
+	/* init inshort status */
+	if (of_property_read_u32(node, "pmu_inshort", &val))
+		val = 0;
+	if (val) {
+		regmap_update_bits(map, AXP803_HOTOVER_CTL,
+				BIT(5) | BIT(6), BIT(5) | BIT(6));
+	} else {
+		regmap_update_bits(map, AXP803_HOTOVER_CTL,
+				BIT(5) | BIT(6), 0);
+	}
+}
+
+int axp20x_match_device(struct axp20x_dev *axp20x)
+{
+	struct device *dev = axp20x->dev;
+	const struct acpi_device_id *acpi_id;
+	const struct of_device_id *of_id;
+
+	if (dev->of_node) {
+		of_id = of_match_device(dev->driver->of_match_table, dev);
+		if (!of_id) {
+			dev_err(dev, "Unable to match OF ID\n");
+			return -ENODEV;
+		}
+		axp20x->variant = (long)of_id->data;
+	} else {
+		acpi_id = acpi_match_device(dev->driver->acpi_match_table, dev);
+		if (!acpi_id || !acpi_id->driver_data) {
+			dev_err(dev, "Unable to match ACPI ID and data\n");
+			return -ENODEV;
+		}
+		axp20x->variant = (long)acpi_id->driver_data;
+	}
+
+	switch (axp20x->variant) {
+	case AXP152_ID:
+		axp20x->nr_cells = ARRAY_SIZE(axp152_cells);
+		axp20x->cells = axp152_cells;
+		axp20x->regmap_cfg = &axp152_regmap_config;
+		axp20x->regmap_irq_chip = &axp152_regmap_irq_chip;
+		break;
+	case AXP202_ID:
+	case AXP209_ID:
+		axp20x->nr_cells = ARRAY_SIZE(axp20x_cells);
+		axp20x->cells = axp20x_cells;
+		axp20x->regmap_cfg = &axp20x_regmap_config;
+		axp20x->regmap_irq_chip = &axp20x_regmap_irq_chip;
+		break;
+	case AXP221_ID:
+	case AXP223_ID:
+		axp20x->nr_cells = ARRAY_SIZE(axp22x_cells);
+		axp20x->cells = axp22x_cells;
+		axp20x->regmap_cfg = &axp22x_regmap_config;
+		axp20x->regmap_irq_chip = &axp22x_regmap_irq_chip;
+		break;
+	case AXP288_ID:
+		axp20x->cells = axp288_cells;
+		axp20x->nr_cells = ARRAY_SIZE(axp288_cells);
+		axp20x->regmap_cfg = &axp288_regmap_config;
+		axp20x->regmap_irq_chip = &axp288_regmap_irq_chip;
+		break;
+	case AXP806_ID:
+		axp20x->nr_cells = ARRAY_SIZE(axp806_cells);
+		axp20x->cells = axp806_cells;
+		axp20x->regmap_cfg = &axp806_regmap_config;
+		axp20x->regmap_irq_chip = &axp806_regmap_irq_chip;
+		break;
+	case AXP809_ID:
+		axp20x->nr_cells = ARRAY_SIZE(axp809_cells);
+		axp20x->cells = axp809_cells;
+		axp20x->regmap_cfg = &axp22x_regmap_config;
+		axp20x->regmap_irq_chip = &axp809_regmap_irq_chip;
+		break;
+	case AXP2101_ID:
+		axp20x->nr_cells = ARRAY_SIZE(axp2101_cells);
+		axp20x->cells = axp2101_cells;
+		axp20x->regmap_cfg = &axp2101_regmap_config;
+		axp20x->regmap_irq_chip = &axp2101_regmap_irq_chip;
+		axp20x->dts_parse = axp2101_dts_parse;
+		break;
+/**************************************/
+	case AXP15_ID:
+		axp20x->nr_cells = ARRAY_SIZE(axp15_cells);
+		axp20x->cells = axp15_cells;
+		axp20x->regmap_cfg = &axp15_regmap_config;
+		axp20x->regmap_irq_chip = &axp15_regmap_irq_chip;
+		break;
+/**************************************/
+	case AXP1530_ID:
+		axp20x->nr_cells = ARRAY_SIZE(axp1530_cells);
+		axp20x->cells = axp1530_cells;
+		axp20x->regmap_cfg = &axp1530_regmap_config;
+		axp20x->regmap_irq_chip = &axp1530_regmap_irq_chip;
+		break;
+/**************************************/
+	case AXP858_ID:
+		axp20x->nr_cells = ARRAY_SIZE(axp858_cells);
+		axp20x->cells = axp858_cells;
+		axp20x->regmap_cfg = &axp858_regmap_config;
+		axp20x->regmap_irq_chip = &axp858_regmap_irq_chip;
+		break;
+	case AXP803_ID:
+		axp20x->nr_cells = ARRAY_SIZE(axp803_cells);
+		axp20x->cells = axp803_cells;
+		axp20x->regmap_cfg = &axp803_regmap_config;
+		axp20x->regmap_irq_chip = &axp803_regmap_irq_chip;
+		axp20x->dts_parse = axp803_dts_parse;
+		break;
+	case AXP2202_ID:
+		axp20x->nr_cells = ARRAY_SIZE(axp2202_cells);
+		axp20x->cells = axp2202_cells;
+		axp20x->regmap_cfg = &axp2202_regmap_config;
+		axp20x->regmap_irq_chip = &axp2202_regmap_irq_chip;
+		break;
+/*-------------------*/
+	default:
+		dev_err(dev, "unsupported AXP20X ID %lu\n", axp20x->variant);
+		return -EINVAL;
+	}
+	dev_info(dev, "AXP20x variant %s found\n",
+		 axp20x_model_names[axp20x->variant]);
+
+	return 0;
+}
+EXPORT_SYMBOL(axp20x_match_device);
+
+
+int axp_debug_mask;
+EXPORT_SYMBOL(axp_debug_mask);
+
+static ssize_t debug_mask_store(struct class *class,
+				struct class_attribute *attr,
+				const char *buf, size_t count)
+{
+	int val, err;
+
+	err = kstrtoint(buf, 16, &val);
+	if (err)
+		return err;
+
+	axp_debug_mask = val;
+
+	return count;
+}
+
+static ssize_t debug_mask_show(struct class *class,
+				struct class_attribute *attr, char *buf)
+{
+	char *s = buf;
+	char *end = (char *)((ptrdiff_t)buf + (ptrdiff_t)PAGE_SIZE);
+
+	s += scnprintf(s, end - s, "%s\n", "1: SPLY 2: REGU 4: INT 8: CHG");
+	s += scnprintf(s, end - s, "debug_mask=%d\n", axp_debug_mask);
+
+	return s - buf;
+}
+static CLASS_ATTR_RW(debug_mask);
+
+static u32 axp_reg_addr;
+
+static ssize_t axp_reg_show(struct class *class,
+				struct class_attribute *attr, char *buf)
+{
+	u32 val;
+
+	regmap_read(axp20x_pm_power_off->regmap, axp_reg_addr, &val);
+	return sprintf(buf, "REG[0x%x]=0x%x\n",
+				axp_reg_addr, val);
+}
+
+static ssize_t axp_reg_store(struct class *class,
+				struct class_attribute *attr,
+				const char *buf, size_t count)
+{
+	s32 tmp;
+	u32 val;
+	int err;
+
+	err = kstrtoint(buf, 16, &tmp);
+	if (err)
+		return err;
+
+	if (tmp < 256) {
+		axp_reg_addr = tmp;
+	} else {
+		val = tmp & 0x00FF;
+		axp_reg_addr = (tmp >> 8) & 0x00FF;
+		regmap_write(axp20x_pm_power_off->regmap, axp_reg_addr, val);
+	}
+
+	return count;
+}
+static CLASS_ATTR_RW(axp_reg);
+
+static struct attribute *axp_class_attrs[] = {
+	&class_attr_axp_reg.attr,
+	&class_attr_debug_mask.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(axp_class);
+
+struct class axp_class = {
+	.name = "axp",
+	.class_groups = axp_class_groups,
+};
+
+static int axp_sysfs_init(void)
+{
+	int status;
+
+	status = class_register(&axp_class);
+	if (status < 0)
+		pr_err("%s,%d err, status:%d\n", __func__, __LINE__, status);
+
+	return status;
+}
+
+int axp20x_device_probe(struct axp20x_dev *axp20x)
+{
+	int ret;
+
+	/*
+	 * on some board ex. qaqc test board, there's no interrupt for axp20x
+	 */
+	if (axp20x->irq) {
+		ret = regmap_add_irq_chip(axp20x->regmap, axp20x->irq,
+					  IRQF_ONESHOT | IRQF_SHARED, -1,
+					  axp20x->regmap_irq_chip,
+					  &axp20x->regmap_irqc);
+		if (ret) {
+			dev_err(axp20x->dev, "failed to add irq chip: %d\n", ret);
+			return ret;
+		}
+	}
+
+	if (axp20x->dts_parse)
+		axp20x->dts_parse(axp20x);
+
+	ret = mfd_add_devices(axp20x->dev, 0, axp20x->cells,
+			      axp20x->nr_cells, NULL, 0, NULL);
+
+	if (ret) {
+		dev_err(axp20x->dev, "failed to add MFD devices: %d\n", ret);
+
+		if (axp20x->irq)
+			regmap_del_irq_chip(axp20x->irq, axp20x->regmap_irqc);
+
+		return ret;
+	}
+
+	axp20x_pm_power_off = axp20x;
+	axp_sysfs_init();
+	if (!pm_power_off) {
+		pm_power_off = axp20x_power_off;
+	}
+
+	dev_info(axp20x->dev, "AXP20X driver loaded\n");
+
+	return 0;
+}
+EXPORT_SYMBOL(axp20x_device_probe);
+
+int axp20x_device_remove(struct axp20x_dev *axp20x)
+{
+	if (axp20x == axp20x_pm_power_off) {
+		axp20x_pm_power_off = NULL;
+		pm_power_off = NULL;
+	}
+
+	mfd_remove_devices(axp20x->dev);
+
+	if (axp20x->irq)
+		regmap_del_irq_chip(axp20x->irq, axp20x->regmap_irqc);
+
+	return 0;
+}
+EXPORT_SYMBOL(axp20x_device_remove);
+
+MODULE_DESCRIPTION("PMIC MFD core driver for AXP20X");
+MODULE_AUTHOR("Carlo Caione <carlo@caione.org>");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/regulator/Makefile b/drivers/regulator/Makefile
index 8c27e077d..68662f5e1 100644
--- a/drivers/regulator/Makefile
+++ b/drivers/regulator/Makefile
@@ -28,7 +28,7 @@ obj-$(CONFIG_REGULATOR_ARM_SCMI) += scmi-regulator.o
 obj-$(CONFIG_REGULATOR_AS3711) += as3711-regulator.o
 obj-$(CONFIG_REGULATOR_AS3722) += as3722-regulator.o
 obj-$(CONFIG_REGULATOR_ATC260X) += atc260x-regulator.o
-obj-$(CONFIG_REGULATOR_AXP20X) += axp20x-regulator.o
+obj-$(CONFIG_REGULATOR_AXP20X) += axp2101-regulator.o
 obj-$(CONFIG_REGULATOR_BCM590XX) += bcm590xx-regulator.o
 obj-$(CONFIG_REGULATOR_BD71815)	+= bd71815-regulator.o
 obj-$(CONFIG_REGULATOR_BD71828) += bd71828-regulator.o
diff --git a/drivers/regulator/axp2101-regulator.c b/drivers/regulator/axp2101-regulator.c
new file mode 100644
index 000000000..bdf020e15
--- /dev/null
+++ b/drivers/regulator/axp2101-regulator.c
@@ -0,0 +1,1232 @@
+/*
+ * AXP20x regulators driver.
+ *
+ * Copyright (C) 2013 Carlo Caione <carlo@caione.org>
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License. See the file "COPYING" in the main directory of this
+ * archive for more details.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/mfd/axp2101.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/of_regulator.h>
+
+#define AXP20X_IO_ENABLED		0x03
+#define AXP20X_IO_DISABLED		0x07
+
+#define AXP22X_IO_ENABLED		0x03
+#define AXP22X_IO_DISABLED		0x04
+
+#define AXP20X_WORKMODE_DCDC2_MASK	BIT(2)
+#define AXP20X_WORKMODE_DCDC3_MASK	BIT(1)
+#define AXP22X_WORKMODE_DCDCX_MASK(x)	BIT(x)
+
+#define AXP20X_FREQ_DCDC_MASK		0x0f
+
+#define AXP22X_MISC_N_VBUSEN_FUNC	BIT(4)
+
+#define AXP803_MISC_N_VBUSEN_FUNC	BIT(4)
+
+#define AXP_DESC_IO(_family, _id, _match, _supply, _min, _max, _step, _vreg,	\
+		    _vmask, _ereg, _emask, _enable_val, _disable_val)		\
+	[_family##_##_id] = {							\
+		.name		= (_match),					\
+		.supply_name	= (_supply),					\
+		.of_match	= of_match_ptr(_match),				\
+		.regulators_node = of_match_ptr("regulators"),			\
+		.type		= REGULATOR_VOLTAGE,				\
+		.id		= _family##_##_id,				\
+		.n_voltages	= (((_max) - (_min)) / (_step) + 1),		\
+		.owner		= THIS_MODULE,					\
+		.min_uV		= (_min) * 1000,				\
+		.uV_step	= (_step) * 1000,				\
+		.vsel_reg	= (_vreg),					\
+		.vsel_mask	= (_vmask),					\
+		.enable_reg	= (_ereg),					\
+		.enable_mask	= (_emask),					\
+		.enable_val	= (_enable_val),				\
+		.disable_val	= (_disable_val),				\
+		.ops		= &axp20x_ops,					\
+	}
+
+#define AXP_DESC(_family, _id, _match, _supply, _min, _max, _step, _vreg,	\
+		 _vmask, _ereg, _emask) 					\
+	[_family##_##_id] = {							\
+		.name		= (_match),					\
+		.supply_name	= (_supply),					\
+		.of_match	= of_match_ptr(_match),				\
+		.regulators_node = of_match_ptr("regulators"),			\
+		.type		= REGULATOR_VOLTAGE,				\
+		.id		= _family##_##_id,				\
+		.n_voltages	= (((_max) - (_min)) / (_step) + 1),		\
+		.owner		= THIS_MODULE,					\
+		.min_uV		= (_min) * 1000,				\
+		.uV_step	= (_step) * 1000,				\
+		.vsel_reg	= (_vreg),					\
+		.vsel_mask	= (_vmask),					\
+		.enable_reg	= (_ereg),					\
+		.enable_mask	= (_emask),					\
+		.ops		= &axp20x_ops,					\
+	}
+
+#define AXP_DESC_SW(_family, _id, _match, _supply, _ereg, _emask)		\
+	[_family##_##_id] = {							\
+		.name		= (_match),					\
+		.supply_name	= (_supply),					\
+		.of_match	= of_match_ptr(_match),				\
+		.regulators_node = of_match_ptr("regulators"),			\
+		.type		= REGULATOR_VOLTAGE,				\
+		.id		= _family##_##_id,				\
+		.owner		= THIS_MODULE,					\
+		.enable_reg	= (_ereg),					\
+		.enable_mask	= (_emask),					\
+		.ops		= &axp20x_ops_sw,				\
+	}
+
+#define AXP_DESC_FIXED(_family, _id, _match, _supply, _volt)			\
+	[_family##_##_id] = {							\
+		.name		= (_match),					\
+		.supply_name	= (_supply),					\
+		.of_match	= of_match_ptr(_match),				\
+		.regulators_node = of_match_ptr("regulators"),			\
+		.type		= REGULATOR_VOLTAGE,				\
+		.id		= _family##_##_id,				\
+		.n_voltages	= 1,						\
+		.owner		= THIS_MODULE,					\
+		.min_uV		= (_volt) * 1000,				\
+		.ops		= &axp20x_ops_fixed				\
+	}
+
+#define AXP_DESC_RANGES(_family, _id, _match, _supply, _ranges, _n_voltages,	\
+			_vreg, _vmask, _ereg, _emask)				\
+	[_family##_##_id] = {							\
+		.name		= (_match),					\
+		.supply_name	= (_supply),					\
+		.of_match	= of_match_ptr(_match),				\
+		.regulators_node = of_match_ptr("regulators"),			\
+		.type		= REGULATOR_VOLTAGE,				\
+		.id		= _family##_##_id,				\
+		.n_voltages	= (_n_voltages),				\
+		.owner		= THIS_MODULE,					\
+		.vsel_reg	= (_vreg),					\
+		.vsel_mask	= (_vmask),					\
+		.enable_reg	= (_ereg),					\
+		.enable_mask	= (_emask),					\
+		.linear_ranges	= (_ranges),					\
+		.n_linear_ranges = ARRAY_SIZE(_ranges),				\
+		.ops		= &axp20x_ops_range,				\
+	}
+
+#define AXP_DESC_RANGES_VOL_DELAY(_family, _id, _match, _supply, _ranges, _n_voltages,	\
+			_vreg, _vmask, _ereg, _emask)				\
+	[_family##_##_id] = {							\
+		.name		= (_match),					\
+		.supply_name	= (_supply),					\
+		.of_match	= of_match_ptr(_match),				\
+		.regulators_node = of_match_ptr("regulators"),			\
+		.type		= REGULATOR_VOLTAGE,				\
+		.id		= _family##_##_id,				\
+		.n_voltages	= (_n_voltages),				\
+		.owner		= THIS_MODULE,					\
+		.vsel_reg	= (_vreg),					\
+		.vsel_mask	= (_vmask),					\
+		.enable_reg	= (_ereg),					\
+		.enable_mask	= (_emask),					\
+		.linear_ranges	= (_ranges),					\
+		.n_linear_ranges = ARRAY_SIZE(_ranges),				\
+		.ops		= &axp20x_ops_range_vol_delay,			\
+	}
+
+struct regulator_delay {
+	u32 step;
+	u32 final;
+};
+
+static int axp2101_set_voltage_time_sel(struct regulator_dev *rdev,
+		unsigned int old_selector, unsigned int new_selector)
+{
+	struct regulator_delay *delay = (struct regulator_delay *)rdev->reg_data;
+
+	return abs(new_selector - old_selector) * delay->step + delay->final;
+};
+
+static struct regulator_ops axp20x_ops_fixed = {
+	.list_voltage		= regulator_list_voltage_linear,
+};
+
+static struct regulator_ops axp20x_ops_range = {
+	.set_voltage_sel	= regulator_set_voltage_sel_regmap,
+	.get_voltage_sel	= regulator_get_voltage_sel_regmap,
+	.list_voltage		= regulator_list_voltage_linear_range,
+	.enable			= regulator_enable_regmap,
+	.disable		= regulator_disable_regmap,
+	.is_enabled		= regulator_is_enabled_regmap,
+	.set_voltage_time_sel = axp2101_set_voltage_time_sel,
+};
+
+static struct regulator_ops axp20x_ops_range_vol_delay = {
+	.set_voltage_sel	= regulator_set_voltage_sel_regmap,
+	.get_voltage_sel	= regulator_get_voltage_sel_regmap,
+	.list_voltage		= regulator_list_voltage_linear_range,
+	.enable			= regulator_enable_regmap,
+	.disable		= regulator_disable_regmap,
+	.is_enabled		= regulator_is_enabled_regmap,
+};
+
+static struct regulator_ops axp20x_ops = {
+	.set_voltage_sel	= regulator_set_voltage_sel_regmap,
+	.get_voltage_sel	= regulator_get_voltage_sel_regmap,
+	.list_voltage		= regulator_list_voltage_linear,
+	.enable			= regulator_enable_regmap,
+	.disable		= regulator_disable_regmap,
+	.is_enabled		= regulator_is_enabled_regmap,
+	.set_voltage_time_sel = axp2101_set_voltage_time_sel,
+};
+
+static struct regulator_ops axp20x_ops_sw = {
+	.enable			= regulator_enable_regmap,
+	.disable		= regulator_disable_regmap,
+	.is_enabled		= regulator_is_enabled_regmap,
+};
+
+static const struct linear_range axp152_dcdc1_ranges[] = {
+	REGULATOR_LINEAR_RANGE(1700000, 0x0, 0x4, 100000),
+	REGULATOR_LINEAR_RANGE(2400000, 0x5, 0x9, 100000),
+	REGULATOR_LINEAR_RANGE(3000000, 0xa, 0xf, 100000),
+};
+
+static const struct linear_range axp152_aldo1_ranges[] = {
+	REGULATOR_LINEAR_RANGE(1200000, 0x0, 0x8, 100000),
+	REGULATOR_LINEAR_RANGE(2500000, 0x9, 0x9, 0),
+	REGULATOR_LINEAR_RANGE(2700000, 0xa, 0xb, 100000),
+	REGULATOR_LINEAR_RANGE(3000000, 0xc, 0xf, 100000),
+};
+
+static const struct linear_range axp152_aldo2_ranges[] = {
+	REGULATOR_LINEAR_RANGE(1200000, 0x0, 0x8, 100000),
+	REGULATOR_LINEAR_RANGE(2500000, 0x9, 0x9, 0),
+	REGULATOR_LINEAR_RANGE(2700000, 0xa, 0xb, 100000),
+	REGULATOR_LINEAR_RANGE(3000000, 0xc, 0xf, 100000),
+};
+
+static const struct linear_range axp152_ldo0_ranges[] = {
+	REGULATOR_LINEAR_RANGE(5000000, 0x0, 0x0, 0),
+	REGULATOR_LINEAR_RANGE(3300000, 0x1, 0x1, 0),
+	REGULATOR_LINEAR_RANGE(2800000, 0x2, 0x2, 0),
+	REGULATOR_LINEAR_RANGE(2500000, 0x3, 0x3, 0),
+};
+
+static const struct regulator_desc axp152_regulators[] = {
+	AXP_DESC_RANGES(AXP152, DCDC1, "dcdc1", "vin1", axp152_dcdc1_ranges,
+			0x10, AXP152_DCDC1_V_OUT, 0xf, AXP152_LDO3456_DC1234_CTRL, BIT(7)),
+	AXP_DESC(AXP152, DCDC2, "dcdc2", "vin2", 700, 2275, 25,
+			AXP152_DCDC2_V_OUT, 0x3f, AXP152_LDO3456_DC1234_CTRL, BIT(6)),
+	AXP_DESC(AXP152, DCDC3, "dcdc3", "vin3", 700, 3500, 50,
+			AXP152_DCDC3_V_OUT, 0x3f, AXP152_LDO3456_DC1234_CTRL, BIT(5)),
+	AXP_DESC(AXP152, DCDC4, "dcdc4", "vin4", 700, 3500, 25,
+			AXP152_DCDC4_V_OUT, 0x7f, AXP152_LDO3456_DC1234_CTRL, BIT(4)),
+	AXP_DESC_RANGES(AXP152, ALDO1, "aldo1", "aldoin", axp152_aldo1_ranges,
+			0x10, AXP152_ALDO12_V_OUT, 0xf0, AXP152_LDO3456_DC1234_CTRL, BIT(3)),
+	AXP_DESC_RANGES(AXP152, ALDO2, "aldo2", "aldoin", axp152_aldo2_ranges,
+			0x10, AXP152_ALDO12_V_OUT, 0xf, AXP152_LDO3456_DC1234_CTRL, BIT(2)),
+	AXP_DESC(AXP152, DLDO1, "dldo1", "dldoin", 700, 3500, 100,
+			AXP152_DLDO1_V_OUT, 0x1f, AXP152_LDO3456_DC1234_CTRL, BIT(1)),
+	AXP_DESC(AXP152, DLDO2, "dldo2", "dldoin", 700, 3500, 100,
+			AXP152_DLDO2_V_OUT, 0x1f, AXP152_LDO3456_DC1234_CTRL, BIT(0)),
+	AXP_DESC_RANGES(AXP152, LDO0, "ldo0", "ldoin", axp152_ldo0_ranges,
+			0x4, AXP152_LDO0_CTRL, 0x30, AXP152_LDO0_CTRL, BIT(7)),
+	AXP_DESC_IO(AXP152, GPIO2_LDO, "gpio2_ldo", "gpio_ldo", 1800, 3300, 100,
+			AXP152_LDOGPIO2_V_OUT, 0xf, AXP152_GPIO2_CTRL, 0x7, 0x2, 0x7),
+	AXP_DESC_FIXED(AXP152, RTC13, "rtcldo13", "rtcldo13in", 1300),
+	AXP_DESC_FIXED(AXP152, RTC18, "rtcldo18", "rtcldo18in", 1800),
+};
+
+static const struct linear_range axp20x_ldo4_ranges[] = {
+	REGULATOR_LINEAR_RANGE(1250000, 0x0, 0x0, 0),
+	REGULATOR_LINEAR_RANGE(1300000, 0x1, 0x8, 100000),
+	REGULATOR_LINEAR_RANGE(2500000, 0x9, 0x9, 0),
+	REGULATOR_LINEAR_RANGE(2700000, 0xa, 0xb, 100000),
+	REGULATOR_LINEAR_RANGE(3000000, 0xc, 0xf, 100000),
+};
+
+static const struct regulator_desc axp20x_regulators[] = {
+	AXP_DESC(AXP20X, DCDC2, "dcdc2", "vin2", 700, 2275, 25,
+		 AXP20X_DCDC2_V_OUT, 0x3f, AXP20X_PWR_OUT_CTRL, 0x10),
+	AXP_DESC(AXP20X, DCDC3, "dcdc3", "vin3", 700, 3500, 25,
+		 AXP20X_DCDC3_V_OUT, 0x7f, AXP20X_PWR_OUT_CTRL, 0x02),
+	AXP_DESC_FIXED(AXP20X, LDO1, "ldo1", "acin", 1300),
+	AXP_DESC(AXP20X, LDO2, "ldo2", "ldo24in", 1800, 3300, 100,
+		 AXP20X_LDO24_V_OUT, 0xf0, AXP20X_PWR_OUT_CTRL, 0x04),
+	AXP_DESC(AXP20X, LDO3, "ldo3", "ldo3in", 700, 3500, 25,
+		 AXP20X_LDO3_V_OUT, 0x7f, AXP20X_PWR_OUT_CTRL, 0x40),
+	AXP_DESC_RANGES(AXP20X, LDO4, "ldo4", "ldo24in", axp20x_ldo4_ranges,
+			16, AXP20X_LDO24_V_OUT, 0x0f, AXP20X_PWR_OUT_CTRL,
+			0x08),
+	AXP_DESC_IO(AXP20X, LDO5, "ldo5", "ldo5in", 1800, 3300, 100,
+		    AXP20X_LDO5_V_OUT, 0xf0, AXP20X_GPIO0_CTRL, 0x07,
+		    AXP20X_IO_ENABLED, AXP20X_IO_DISABLED),
+};
+
+static const struct regulator_desc axp22x_regulators[] = {
+	AXP_DESC(AXP22X, DCDC1, "dcdc1", "vin1", 1600, 3400, 100,
+		 AXP22X_DCDC1_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL1, BIT(1)),
+	AXP_DESC(AXP22X, DCDC2, "dcdc2", "vin2", 600, 1540, 20,
+		 AXP22X_DCDC2_V_OUT, 0x3f, AXP22X_PWR_OUT_CTRL1, BIT(2)),
+	AXP_DESC(AXP22X, DCDC3, "dcdc3", "vin3", 600, 1860, 20,
+		 AXP22X_DCDC3_V_OUT, 0x3f, AXP22X_PWR_OUT_CTRL1, BIT(3)),
+	AXP_DESC(AXP22X, DCDC4, "dcdc4", "vin4", 600, 1540, 20,
+		 AXP22X_DCDC4_V_OUT, 0x3f, AXP22X_PWR_OUT_CTRL1, BIT(4)),
+	AXP_DESC(AXP22X, DCDC5, "dcdc5", "vin5", 1000, 2550, 50,
+		 AXP22X_DCDC5_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL1, BIT(5)),
+	/* secondary switchable output of DCDC1 */
+	AXP_DESC_SW(AXP22X, DC1SW, "dc1sw", NULL, AXP22X_PWR_OUT_CTRL2,
+		    BIT(7)),
+	/* LDO regulator internally chained to DCDC5 */
+	AXP_DESC(AXP22X, DC5LDO, "dc5ldo", NULL, 700, 1400, 100,
+		 AXP22X_DC5LDO_V_OUT, 0x7, AXP22X_PWR_OUT_CTRL1, BIT(0)),
+	AXP_DESC(AXP22X, ALDO1, "aldo1", "aldoin", 700, 3300, 100,
+		 AXP22X_ALDO1_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL1, BIT(6)),
+	AXP_DESC(AXP22X, ALDO2, "aldo2", "aldoin", 700, 3300, 100,
+		 AXP22X_ALDO2_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL1, BIT(7)),
+	AXP_DESC(AXP22X, ALDO3, "aldo3", "aldoin", 700, 3300, 100,
+		 AXP22X_ALDO3_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL3, BIT(7)),
+	AXP_DESC(AXP22X, DLDO1, "dldo1", "dldoin", 700, 3300, 100,
+		 AXP22X_DLDO1_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(3)),
+	AXP_DESC(AXP22X, DLDO2, "dldo2", "dldoin", 700, 3300, 100,
+		 AXP22X_DLDO2_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(4)),
+	AXP_DESC(AXP22X, DLDO3, "dldo3", "dldoin", 700, 3300, 100,
+		 AXP22X_DLDO3_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(5)),
+	AXP_DESC(AXP22X, DLDO4, "dldo4", "dldoin", 700, 3300, 100,
+		 AXP22X_DLDO4_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(6)),
+	AXP_DESC(AXP22X, ELDO1, "eldo1", "eldoin", 700, 3300, 100,
+		 AXP22X_ELDO1_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(0)),
+	AXP_DESC(AXP22X, ELDO2, "eldo2", "eldoin", 700, 3300, 100,
+		 AXP22X_ELDO2_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(1)),
+	AXP_DESC(AXP22X, ELDO3, "eldo3", "eldoin", 700, 3300, 100,
+		 AXP22X_ELDO3_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(2)),
+	/* Note the datasheet only guarantees reliable operation up to
+	 * 3.3V, this needs to be enforced via dts provided constraints */
+	AXP_DESC_IO(AXP22X, LDO_IO0, "ldo_io0", "ips", 700, 3800, 100,
+		    AXP22X_LDO_IO0_V_OUT, 0x1f, AXP20X_GPIO0_CTRL, 0x07,
+		    AXP22X_IO_ENABLED, AXP22X_IO_DISABLED),
+	/* Note the datasheet only guarantees reliable operation up to
+	 * 3.3V, this needs to be enforced via dts provided constraints */
+	AXP_DESC_IO(AXP22X, LDO_IO1, "ldo_io1", "ips", 700, 3800, 100,
+		    AXP22X_LDO_IO1_V_OUT, 0x1f, AXP20X_GPIO1_CTRL, 0x07,
+		    AXP22X_IO_ENABLED, AXP22X_IO_DISABLED),
+	AXP_DESC_FIXED(AXP22X, RTC_LDO, "rtc_ldo", "ips", 3000),
+};
+
+static const struct regulator_desc axp22x_drivevbus_regulator = {
+	.name		= "drivevbus",
+	.supply_name	= "drivevbusin",
+	.of_match	= of_match_ptr("drivevbus"),
+	.regulators_node = of_match_ptr("regulators"),
+	.type		= REGULATOR_VOLTAGE,
+	.owner		= THIS_MODULE,
+	.enable_reg	= AXP20X_VBUS_IPSOUT_MGMT,
+	.enable_mask	= BIT(2),
+	.ops		= &axp20x_ops_sw,
+};
+
+static const struct linear_range axp806_dcdca_ranges[] = {
+	REGULATOR_LINEAR_RANGE(600000, 0x0, 0x32, 10000),
+	REGULATOR_LINEAR_RANGE(1120000, 0x33, 0x47, 20000),
+};
+
+static const struct linear_range axp806_dcdcd_ranges[] = {
+	REGULATOR_LINEAR_RANGE(600000, 0x0, 0x2d, 20000),
+	REGULATOR_LINEAR_RANGE(1600000, 0x2e, 0x3f, 100000),
+};
+
+static const struct linear_range axp806_cldo2_ranges[] = {
+	REGULATOR_LINEAR_RANGE(700000, 0x0, 0x1a, 100000),
+	REGULATOR_LINEAR_RANGE(3400000, 0x1b, 0x1f, 200000),
+};
+
+static const struct regulator_desc axp806_regulators[] = {
+	AXP_DESC_RANGES(AXP806, DCDCA, "dcdca", "vina", axp806_dcdca_ranges,
+			72, AXP806_DCDCA_V_CTRL, 0x7f, AXP806_PWR_OUT_CTRL1,
+			BIT(0)),
+	AXP_DESC(AXP806, DCDCB, "dcdcb", "vinb", 1000, 2550, 50,
+		 AXP806_DCDCB_V_CTRL, 0x1f, AXP806_PWR_OUT_CTRL1, BIT(1)),
+	AXP_DESC_RANGES(AXP806, DCDCC, "dcdcc", "vinc", axp806_dcdca_ranges,
+			72, AXP806_DCDCC_V_CTRL, 0x7f, AXP806_PWR_OUT_CTRL1,
+			BIT(2)),
+	AXP_DESC_RANGES(AXP806, DCDCD, "dcdcd", "vind", axp806_dcdcd_ranges,
+			64, AXP806_DCDCD_V_CTRL, 0x3f, AXP806_PWR_OUT_CTRL1,
+			BIT(3)),
+	AXP_DESC(AXP806, DCDCE, "dcdce", "vine", 1100, 3400, 100,
+		 AXP806_DCDCE_V_CTRL, 0x1f, AXP806_PWR_OUT_CTRL1, BIT(4)),
+	AXP_DESC(AXP806, ALDO1, "aldo1", "aldoin", 700, 3300, 100,
+		 AXP806_ALDO1_V_CTRL, 0x1f, AXP806_PWR_OUT_CTRL1, BIT(5)),
+	AXP_DESC(AXP806, ALDO2, "aldo2", "aldoin", 700, 3400, 100,
+		 AXP806_ALDO2_V_CTRL, 0x1f, AXP806_PWR_OUT_CTRL1, BIT(6)),
+	AXP_DESC(AXP806, ALDO3, "aldo3", "aldoin", 700, 3300, 100,
+		 AXP806_ALDO3_V_CTRL, 0x1f, AXP806_PWR_OUT_CTRL1, BIT(7)),
+	AXP_DESC(AXP806, BLDO1, "bldo1", "bldoin", 700, 1900, 100,
+		 AXP806_BLDO1_V_CTRL, 0x0f, AXP806_PWR_OUT_CTRL2, BIT(0)),
+	AXP_DESC(AXP806, BLDO2, "bldo2", "bldoin", 700, 1900, 100,
+		 AXP806_BLDO2_V_CTRL, 0x0f, AXP806_PWR_OUT_CTRL2, BIT(1)),
+	AXP_DESC(AXP806, BLDO3, "bldo3", "bldoin", 700, 1900, 100,
+		 AXP806_BLDO3_V_CTRL, 0x0f, AXP806_PWR_OUT_CTRL2, BIT(2)),
+	AXP_DESC(AXP806, BLDO4, "bldo4", "bldoin", 700, 1900, 100,
+		 AXP806_BLDO4_V_CTRL, 0x0f, AXP806_PWR_OUT_CTRL2, BIT(3)),
+	AXP_DESC(AXP806, CLDO1, "cldo1", "cldoin", 700, 3300, 100,
+		 AXP806_CLDO1_V_CTRL, 0x1f, AXP806_PWR_OUT_CTRL2, BIT(4)),
+	AXP_DESC_RANGES(AXP806, CLDO2, "cldo2", "cldoin", axp806_cldo2_ranges,
+			32, AXP806_CLDO2_V_CTRL, 0x1f, AXP806_PWR_OUT_CTRL2,
+			BIT(5)),
+	AXP_DESC(AXP806, CLDO3, "cldo3", "cldoin", 700, 3300, 100,
+		 AXP806_CLDO3_V_CTRL, 0x1f, AXP806_PWR_OUT_CTRL2, BIT(6)),
+	AXP_DESC_SW(AXP806, SW, "sw", "swin", AXP806_PWR_OUT_CTRL2, BIT(7)),
+};
+
+static const struct linear_range axp809_dcdc4_ranges[] = {
+	REGULATOR_LINEAR_RANGE(600000, 0x0, 0x2f, 20000),
+	REGULATOR_LINEAR_RANGE(1800000, 0x30, 0x38, 100000),
+};
+
+static const struct regulator_desc axp809_regulators[] = {
+	AXP_DESC(AXP809, DCDC1, "dcdc1", "vin1", 1600, 3400, 100,
+		 AXP22X_DCDC1_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL1, BIT(1)),
+	AXP_DESC(AXP809, DCDC2, "dcdc2", "vin2", 600, 1540, 20,
+		 AXP22X_DCDC2_V_OUT, 0x3f, AXP22X_PWR_OUT_CTRL1, BIT(2)),
+	AXP_DESC(AXP809, DCDC3, "dcdc3", "vin3", 600, 1860, 20,
+		 AXP22X_DCDC3_V_OUT, 0x3f, AXP22X_PWR_OUT_CTRL1, BIT(3)),
+	AXP_DESC_RANGES(AXP809, DCDC4, "dcdc4", "vin4", axp809_dcdc4_ranges,
+			57, AXP22X_DCDC4_V_OUT, 0x3f, AXP22X_PWR_OUT_CTRL1,
+			BIT(4)),
+	AXP_DESC(AXP809, DCDC5, "dcdc5", "vin5", 1000, 2550, 50,
+		 AXP22X_DCDC5_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL1, BIT(5)),
+	/* secondary switchable output of DCDC1 */
+	AXP_DESC_SW(AXP809, DC1SW, "dc1sw", NULL, AXP22X_PWR_OUT_CTRL2,
+		    BIT(7)),
+	/* LDO regulator internally chained to DCDC5 */
+	AXP_DESC(AXP809, DC5LDO, "dc5ldo", NULL, 700, 1400, 100,
+		 AXP22X_DC5LDO_V_OUT, 0x7, AXP22X_PWR_OUT_CTRL1, BIT(0)),
+	AXP_DESC(AXP809, ALDO1, "aldo1", "aldoin", 700, 3300, 100,
+		 AXP22X_ALDO1_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL1, BIT(6)),
+	AXP_DESC(AXP809, ALDO2, "aldo2", "aldoin", 700, 3300, 100,
+		 AXP22X_ALDO2_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL1, BIT(7)),
+	AXP_DESC(AXP809, ALDO3, "aldo3", "aldoin", 700, 3300, 100,
+		 AXP22X_ALDO3_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(5)),
+	AXP_DESC_RANGES(AXP809, DLDO1, "dldo1", "dldoin", axp806_cldo2_ranges,
+			32, AXP22X_DLDO1_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2,
+			BIT(3)),
+	AXP_DESC(AXP809, DLDO2, "dldo2", "dldoin", 700, 3300, 100,
+		 AXP22X_DLDO2_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(4)),
+	AXP_DESC(AXP809, ELDO1, "eldo1", "eldoin", 700, 3300, 100,
+		 AXP22X_ELDO1_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(0)),
+	AXP_DESC(AXP809, ELDO2, "eldo2", "eldoin", 700, 3300, 100,
+		 AXP22X_ELDO2_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(1)),
+	AXP_DESC(AXP809, ELDO3, "eldo3", "eldoin", 700, 3300, 100,
+		 AXP22X_ELDO3_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(2)),
+	/*
+	 * Note the datasheet only guarantees reliable operation up to
+	 * 3.3V, this needs to be enforced via dts provided constraints
+	 */
+	AXP_DESC_IO(AXP809, LDO_IO0, "ldo_io0", "ips", 700, 3800, 100,
+		    AXP22X_LDO_IO0_V_OUT, 0x1f, AXP20X_GPIO0_CTRL, 0x07,
+		    AXP22X_IO_ENABLED, AXP22X_IO_DISABLED),
+	/*
+	 * Note the datasheet only guarantees reliable operation up to
+	 * 3.3V, this needs to be enforced via dts provided constraints
+	 */
+	AXP_DESC_IO(AXP809, LDO_IO1, "ldo_io1", "ips", 700, 3800, 100,
+		    AXP22X_LDO_IO1_V_OUT, 0x1f, AXP20X_GPIO1_CTRL, 0x07,
+		    AXP22X_IO_ENABLED, AXP22X_IO_DISABLED),
+	AXP_DESC_FIXED(AXP809, RTC_LDO, "rtc_ldo", "ips", 1800),
+	AXP_DESC_SW(AXP809, SW, "sw", "swin", AXP22X_PWR_OUT_CTRL2, BIT(6)),
+};
+
+static const struct linear_range axp2101_dcdc2_ranges[] = {
+	REGULATOR_LINEAR_RANGE(500000, 0x0, 0x46, 10000),
+	REGULATOR_LINEAR_RANGE(1220000, 0x47, 0x57, 20000),
+};
+
+static const struct linear_range axp2101_dcdc3_ranges[] = {
+	REGULATOR_LINEAR_RANGE(500000, 0x0, 0x46, 10000),
+	REGULATOR_LINEAR_RANGE(1220000, 0x47, 0x57, 20000),
+	REGULATOR_LINEAR_RANGE(1600000, 0x58, 0x6a, 100000),
+};
+
+static const struct linear_range axp2101_dcdc4_ranges[] = {
+	REGULATOR_LINEAR_RANGE(500000, 0x0, 0x46, 10000),
+	REGULATOR_LINEAR_RANGE(1220000, 0x47, 0x66, 20000),
+};
+
+static const struct linear_range axp2101_rtcldo_ranges[] = {
+	REGULATOR_LINEAR_RANGE(1800000, 0x0, 0x0, 0),
+	REGULATOR_LINEAR_RANGE(2500000, 0x1, 0x1, 0),
+	REGULATOR_LINEAR_RANGE(2800000, 0x2, 0x2, 0),
+	REGULATOR_LINEAR_RANGE(3300000, 0x3, 0x3, 0),
+};
+
+static const struct linear_range axp2101_dcdc5_ranges[] = {
+	REGULATOR_LINEAR_RANGE(1400000, 0x0, 0x17, 100000),
+	REGULATOR_LINEAR_RANGE(1200000, 0x19, 0x19, 0),
+};
+
+static const struct regulator_desc axp2101_regulators[] = {
+	AXP_DESC(AXP2101, DCDC1, "dcdc1", "vin1", 1500, 3400, 100,
+		 AXP2101_DCDC1_CFG, 0x1f, AXP2101_DCDC_CFG0, BIT(0)),
+	AXP_DESC_RANGES(AXP2101, DCDC2, "dcdc2", "vin2", axp2101_dcdc2_ranges,
+			0x58, AXP2101_DCDC2_CFG, 0x7f, AXP2101_DCDC_CFG0,
+			BIT(1)),
+	AXP_DESC_RANGES(AXP2101, DCDC3, "dcdc3", "vin3", axp2101_dcdc3_ranges,
+			0x6b, AXP2101_DCDC3_CFG, 0x7f, AXP2101_DCDC_CFG0,
+			BIT(2)),
+	AXP_DESC_RANGES(AXP2101, DCDC4, "dcdc4", "vin4", axp2101_dcdc4_ranges,
+			0x67, AXP2101_DCDC4_CFG, 0x7f, AXP2101_DCDC_CFG0,
+			BIT(3)),
+	AXP_DESC_RANGES(AXP2101, DCDC5, "dcdc5", "vin5", axp2101_dcdc5_ranges,
+			0x19, AXP2101_DCDC5_CFG, 0x1f, AXP2101_DCDC_CFG0,
+			BIT(4)),
+	AXP_DESC_FIXED(AXP2101, LDO1, "rtcldo", "rtcldoin", 1800),
+	AXP_DESC_FIXED(AXP2101, LDO2, "rtcldo1", "rtcldo1in", 1800),
+	AXP_DESC(AXP2101, LDO3, "aldo1", "aldoin", 500, 3500, 100,
+		 AXP2101_ALDO1_CFG, 0x1f, AXP2101_LDO_EN_CFG0, BIT(0)),
+	AXP_DESC(AXP2101, LDO4, "aldo2", "aldoin", 500, 3500, 100,
+		 AXP2101_ALDO2_CFG, 0x1f, AXP2101_LDO_EN_CFG0, BIT(1)),
+	AXP_DESC(AXP2101, LDO5, "aldo3", "aldoin", 500, 3500, 100,
+		 AXP2101_ALDO3_CFG, 0x1f, AXP2101_LDO_EN_CFG0, BIT(2)),
+	AXP_DESC(AXP2101, LDO6, "aldo4", "aldoin", 500, 3500, 100,
+		 AXP2101_ALDO4_CFG, 0x1f, AXP2101_LDO_EN_CFG0, BIT(3)),
+	AXP_DESC(AXP2101, LDO7, "bldo1", "bldoin", 500, 3500, 100,
+		 AXP2101_BLDO1_CFG, 0x1f, AXP2101_LDO_EN_CFG0, BIT(4)),
+	AXP_DESC(AXP2101, LDO8, "bldo2", "bldoin", 500, 3500, 100,
+		 AXP2101_BLDO2_CFG, 0x1f, AXP2101_LDO_EN_CFG0, BIT(5)),
+	AXP_DESC(AXP2101, LDO9, "dldo1", "dldoin", 500, 3500, 100,
+		 AXP2101_DLDO1_CFG, 0x1f, AXP2101_LDO_EN_CFG0, BIT(7)),
+	AXP_DESC(AXP2101, LDO10, "dldo2", "dldoin", 500, 1400, 50,
+		 AXP2101_DLDO2_CFG, 0x1f, AXP2101_LDO_EN_CFG1, BIT(0)),
+	AXP_DESC(AXP2101, LDO11, "cpusldo", "cpusldoin", 500, 1400, 50,
+		 AXP2101_CPUSLD_CFG, 0x1f, AXP2101_LDO_EN_CFG0, BIT(6)),
+};
+
+static const struct linear_range axp15_dcdc1_ranges[] = {
+	REGULATOR_LINEAR_RANGE(1700000, 0x0, 0x4, 100000),
+	REGULATOR_LINEAR_RANGE(2400000, 0x5, 0x9, 100000),
+	REGULATOR_LINEAR_RANGE(3000000, 0xA, 0xF, 100000),
+};
+
+static const struct linear_range axp15_aldo2_ranges[] = {
+	REGULATOR_LINEAR_RANGE(1200000, 0x0, 0x8, 100000),
+	REGULATOR_LINEAR_RANGE(2500000, 0x9, 0x9, 0),
+	REGULATOR_LINEAR_RANGE(2700000, 0xA, 0xB, 100000),
+	REGULATOR_LINEAR_RANGE(3000000, 0xC, 0xF, 100000),
+};
+
+static const struct linear_range axp15_ldo0_ranges[] = {
+	REGULATOR_LINEAR_RANGE(5000000, 0x0, 0x0, 0),
+	REGULATOR_LINEAR_RANGE(3300000, 0x1, 0x1, 0),
+	REGULATOR_LINEAR_RANGE(2800000, 0x2, 0x2, 0),
+	REGULATOR_LINEAR_RANGE(2500000, 0x3, 0x3, 0),
+};
+
+static const struct regulator_desc axp15_regulators[] = {
+	AXP_DESC_RANGES(AXP15, DCDC1, "dcdc1", "vin1", axp15_dcdc1_ranges,
+			0x10, AXP15_DC1OUT_VOL, 0xf, AXP15_LDO3456_DC1234_CTL, BIT(7)),
+	AXP_DESC(AXP15, DCDC2, "dcdc2", "vin2", 700, 2275, 25,
+		AXP15_DC2OUT_VOL, 0x3f, AXP15_LDO3456_DC1234_CTL, BIT(6)),
+	AXP_DESC(AXP15, DCDC3, "dcdc3", "vin3", 700, 3500, 25,
+		AXP15_DC3OUT_VOL, 0x3f, AXP15_LDO3456_DC1234_CTL, BIT(5)),
+	AXP_DESC(AXP15, DCDC4, "dcdc4", "vin4", 700, 3500, 50,
+		AXP15_DC4OUT_VOL, 0x7f, AXP15_LDO3456_DC1234_CTL, BIT(4)),
+
+	AXP_DESC_RANGES(AXP15, LDO1, "ldo0", "ldo0in", axp15_ldo0_ranges,
+			0x4, AXP15_LDO0OUT_VOL, 0x30, AXP15_LDO0OUT_VOL, BIT(7)),
+	AXP_DESC_FIXED(AXP15, LDO2, "rtcldo", "rtcldoin", 3100),
+	AXP_DESC(AXP15, LDO3, "aldo1", "aldoin", 1200, 3300, 100,
+		 AXP15_LDO34OUT_VOL, 0xf0, AXP15_LDO3456_DC1234_CTL, BIT(3)),
+	AXP_DESC_RANGES(AXP15, LDO4, "aldo2", "aldoin", axp15_aldo2_ranges,
+			0x10, AXP15_LDO34OUT_VOL, 0xf, AXP15_LDO3456_DC1234_CTL, BIT(3)),
+	AXP_DESC(AXP15, LDO5, "dldo1", "dldoin", 700, 3500, 100,
+		 AXP15_LDO5OUT_VOL, 0x1f, AXP15_LDO3456_DC1234_CTL, BIT(1)),
+	AXP_DESC(AXP15, LDO6, "dldo2", "dldoin", 700, 3500, 100,
+		 AXP15_LDO6OUT_VOL, 0x1f, AXP15_LDO3456_DC1234_CTL, BIT(0)),
+	AXP_DESC_IO(AXP15, LDO7, "gpio", "gpioin", 1800, 3300, 100,
+		 AXP15_GPIO0_VOL, 0xf, AXP15_GPIO2_CTL, 0x7, 0x2, 0x7),
+};
+
+static const struct linear_range axp1530_dcdc1_ranges[] = {
+	REGULATOR_LINEAR_RANGE(500000, 0x0, 0x46, 10000),
+	REGULATOR_LINEAR_RANGE(1220000, 0x47, 0x57, 20000),
+	REGULATOR_LINEAR_RANGE(1600000, 0x58, 0x6A, 100000),
+};
+
+static const struct linear_range axp1530_dcdc2_ranges[] = {
+	REGULATOR_LINEAR_RANGE(500000, 0x0, 0x46, 10000),
+	REGULATOR_LINEAR_RANGE(1220000, 0x47, 0x57, 20000),
+};
+
+static const struct linear_range axp1530_dcdc3_ranges[] = {
+	REGULATOR_LINEAR_RANGE(500000, 0x0, 0x46, 10000),
+	REGULATOR_LINEAR_RANGE(1220000, 0x47, 0x66, 20000),
+};
+
+static const struct regulator_desc axp1530_regulators[] = {
+	AXP_DESC_RANGES(AXP1530, DCDC1, "dcdc1", "vin1", axp1530_dcdc1_ranges,
+			0x6B, AXP1530_DCDC1_CONRTOL, 0x7f, AXP1530_OUTPUT_CONTROL, BIT(0)),
+	AXP_DESC_RANGES(AXP1530, DCDC2, "dcdc2", "vin2", axp1530_dcdc2_ranges,
+			0x58, AXP1530_DCDC2_CONRTOL, 0x7f, AXP1530_OUTPUT_CONTROL, BIT(1)),
+	AXP_DESC_RANGES(AXP1530, DCDC3, "dcdc3", "vin3", axp1530_dcdc3_ranges,
+			0x58, AXP1530_DCDC3_CONRTOL, 0x7f, AXP1530_OUTPUT_CONTROL, BIT(2)),
+	AXP_DESC(AXP1530, LDO1, "ldo1", "ldo1in", 500, 3500, 100,
+		AXP1530_ALDO1_CONRTOL, 0x1f, AXP1530_OUTPUT_CONTROL, BIT(3)),
+	AXP_DESC(AXP1530, LDO2, "ldo2", "ldo2in", 500, 3500, 100,
+		AXP1530_DLDO1_CONRTOL, 0x1f, AXP1530_OUTPUT_CONTROL, BIT(4)),
+};
+
+static const struct linear_range axp858_dcdc2_ranges[] = {
+	REGULATOR_LINEAR_RANGE(500000, 0x0, 0x46, 10000),
+	REGULATOR_LINEAR_RANGE(1220000, 0x47, 0x57, 20000),
+};
+
+static const struct linear_range axp858_dcdc3_ranges[] = {
+	REGULATOR_LINEAR_RANGE(500000, 0x0, 0x46, 10000),
+	REGULATOR_LINEAR_RANGE(1220000, 0x47, 0x57, 20000),
+};
+
+static const struct linear_range axp858_dcdc4_ranges[] = {
+	REGULATOR_LINEAR_RANGE(500000, 0x0, 0x46, 10000),
+	REGULATOR_LINEAR_RANGE(1220000, 0x47, 0x57, 20000),
+};
+
+static const struct linear_range axp858_dcdc5_ranges[] = {
+	REGULATOR_LINEAR_RANGE(800000, 0x0, 0x20, 10000),
+	REGULATOR_LINEAR_RANGE(1140000, 0x21, 0x44, 20000),
+};
+
+
+static const struct regulator_desc axp858_regulators[] = {
+	AXP_DESC(AXP858, DCDC1, "dcdc1", "vin1", 1500, 3400, 100,
+		 AXP858_DCDC1_CONTROL, 0x1f, AXP858_OUTPUT_CONTROL1, BIT(0)),
+	AXP_DESC_RANGES(AXP858, DCDC2, "dcdc2", "vin2", axp858_dcdc2_ranges,
+			0x58, AXP858_DCDC2_CONTROL, 0x7f, AXP858_OUTPUT_CONTROL1, BIT(1)),
+	AXP_DESC_RANGES(AXP858, DCDC3, "dcdc3", "vin3", axp858_dcdc3_ranges,
+			0x58, AXP858_DCDC3_CONTROL, 0x7f, AXP858_OUTPUT_CONTROL1, BIT(2)),
+	AXP_DESC_RANGES(AXP858, DCDC4, "dcdc4", "vin4", axp858_dcdc4_ranges,
+			0x58, AXP858_DCDC4_CONTROL, 0x7f, AXP858_OUTPUT_CONTROL1, BIT(3)),
+	AXP_DESC_RANGES(AXP858, DCDC5, "dcdc5", "vin5", axp858_dcdc5_ranges,
+			0x45, AXP858_DCDC5_CONTROL, 0x7f, AXP858_OUTPUT_CONTROL1, BIT(4)),
+	AXP_DESC(AXP858, DCDC6, "dcdc6", "vin6", 500, 3400, 100,
+		 AXP858_DCDC6_CONTROL, 0x1f, AXP858_OUTPUT_CONTROL1, BIT(5)),
+	AXP_DESC(AXP858, ALDO1, "aldo1", "aldoin", 700, 3300, 100,
+		 AXP858_ALDO1_CONTROL, 0x1f, AXP858_OUTPUT_CONTROL2, BIT(0)),
+	AXP_DESC(AXP858, ALDO2, "aldo2", "aldoin", 700, 3300, 100,
+		 AXP858_ALDO2_CTL, 0x1f, AXP858_OUTPUT_CONTROL2, BIT(1)),
+	AXP_DESC(AXP858, ALDO3, "aldo3", "aldoin", 700, 3300, 100,
+		 AXP858_ALDO3_CTL, 0x1f, AXP858_OUTPUT_CONTROL2, BIT(2)),
+	AXP_DESC(AXP858, ALDO4, "aldo4", "aldoin", 700, 3300, 100,
+		 AXP858_ALDO4_CTL, 0x1f, AXP858_OUTPUT_CONTROL2, BIT(3)),
+	AXP_DESC(AXP858, ALDO5, "aldo5", "aldoin", 700, 3300, 100,
+		 AXP858_ALDO5_CTL, 0x1f, AXP858_OUTPUT_CONTROL2, BIT(4)),
+	AXP_DESC(AXP858, BLDO1, "bldo1", "bldoin", 700, 3300, 100,
+		 AXP858_BLDO1_CTL, 0x1f, AXP858_OUTPUT_CONTROL2, BIT(5)),
+	AXP_DESC(AXP858, BLDO2, "bldo2", "bldoin", 700, 3300, 100,
+		 AXP858_BLDO2_CTL, 0x1f, AXP858_OUTPUT_CONTROL2, BIT(6)),
+	AXP_DESC(AXP858, BLDO3, "bldo3", "bldoin", 700, 3300, 100,
+		 AXP858_BLDO3_CTL, 0x1f, AXP858_OUTPUT_CONTROL2, BIT(7)),
+	AXP_DESC(AXP858, BLDO4, "bldo4", "bldoin", 700, 3300, 100,
+		 AXP858_BLDO4_CTL, 0x1f, AXP858_OUTPUT_CONTROL3, BIT(0)),
+	AXP_DESC(AXP858, BLDO5, "bldo5", "bldoin", 700, 3300, 100,
+		 AXP858_BLDO5_CTL, 0x1f, AXP858_OUTPUT_CONTROL3, BIT(1)),
+	AXP_DESC(AXP858, CLDO1, "cldo1", "cldoin", 700, 3300, 100,
+		 AXP858_CLDO1_CTL, 0x1f, AXP858_OUTPUT_CONTROL3, BIT(2)),
+	AXP_DESC(AXP858, CLDO2, "cldo2", "cldoin", 700, 3300, 100,
+		 AXP858_CLDO2_CTL, 0x1f, AXP858_OUTPUT_CONTROL3, BIT(3)),
+	AXP_DESC(AXP858, CLDO3, "cldo3", "cldoin", 700, 3300, 100,
+		 AXP858_CLDO3_GPIO1_CTL, 0x1f, AXP858_OUTPUT_CONTROL3, BIT(4)),
+	AXP_DESC(AXP858, CLDO4, "cldo4", "cldoin", 700, 4200, 100,
+		 AXP858_CLDO4_CTL, 0x3f, AXP858_OUTPUT_CONTROL3, BIT(5)),
+	AXP_DESC(AXP858, CPUSLDO, "cpusldo", "cpusldoin", 700, 1400, 50,
+		 AXP858_CPUSLDO_CTL, 0x1f, AXP858_OUTPUT_CONTROL3, BIT(6)),
+	AXP_DESC_SW(AXP858, DC1SW, "dc1sw", "swin", AXP858_OUTPUT_CONTROL3, BIT(7)),
+};
+
+static const struct linear_range axp803_dcdc1_ranges[] = {
+	REGULATOR_LINEAR_RANGE(1600000, 0x0, 0x12, 100000),
+};
+
+static const struct linear_range axp803_dcdc2_ranges[] = {
+	REGULATOR_LINEAR_RANGE(500000, 0x0, 0x46, 10000),
+	REGULATOR_LINEAR_RANGE(1220000, 0x47, 0x4b, 20000),
+};
+
+static const struct linear_range axp803_dcdc3_ranges[] = {
+	REGULATOR_LINEAR_RANGE(500000, 0x0, 0x46, 10000),
+	REGULATOR_LINEAR_RANGE(1220000, 0x47, 0x4b, 20000),
+};
+
+static const struct linear_range axp803_dcdc4_ranges[] = {
+	REGULATOR_LINEAR_RANGE(500000, 0x0, 0x46, 10000),
+	REGULATOR_LINEAR_RANGE(1220000, 0x47, 0x4b, 20000),
+};
+
+static const struct linear_range axp803_dcdc5_ranges[] = {
+	REGULATOR_LINEAR_RANGE(800000, 0x0, 0x20, 10000),
+	REGULATOR_LINEAR_RANGE(1140000, 0x21, 0x44, 20000),
+};
+
+static const struct linear_range axp803_dcdc6_ranges[] = {
+	REGULATOR_LINEAR_RANGE(600000, 0x0, 0x32, 10000),
+	REGULATOR_LINEAR_RANGE(1120000, 0x33, 0x47, 20000),
+};
+
+static const struct linear_range axp803_dcdc7_ranges[] = {
+	REGULATOR_LINEAR_RANGE(600000, 0x0, 0x32, 10000),
+	REGULATOR_LINEAR_RANGE(1120000, 0x33, 0x47, 20000),
+};
+
+static const struct linear_range axp803_aldo3_ranges[] = {
+	REGULATOR_LINEAR_RANGE(700000, 0x0, 0x1a, 100000),
+	REGULATOR_LINEAR_RANGE(3300000, 0x1b, 0x1f, 0),
+};
+
+static const struct linear_range axp803_dldo2_ranges[] = {
+	REGULATOR_LINEAR_RANGE(700000, 0x0, 0x1b, 100000),
+	REGULATOR_LINEAR_RANGE(3600000, 0x1c, 0x1f, 200000),
+};
+
+static const struct regulator_desc axp803_regulators[] = {
+	AXP_DESC_RANGES_VOL_DELAY
+		(AXP803, DCDC1, "dcdc1", "vin1", axp803_dcdc1_ranges,
+		 0x13, AXP803_DC1OUT_VOL, 0x1f, AXP803_LDO_DC_EN1, BIT(0)),
+	AXP_DESC_RANGES_VOL_DELAY
+		(AXP803, DCDC2, "dcdc2", "vin2", axp803_dcdc2_ranges,
+		 0x4c, AXP803_DC2OUT_VOL, 0x7f, AXP803_LDO_DC_EN1, BIT(1)),
+	AXP_DESC_RANGES_VOL_DELAY
+		(AXP803, DCDC3, "dcdc3", "vin3", axp803_dcdc3_ranges,
+		0x4c, AXP803_DC3OUT_VOL, 0x7f, AXP803_LDO_DC_EN1, BIT(2)),
+	AXP_DESC_RANGES_VOL_DELAY
+		(AXP803, DCDC4, "dcdc4", "vin4", axp803_dcdc4_ranges,
+		 0x4c, AXP803_DC4OUT_VOL, 0x7f, AXP803_LDO_DC_EN1, BIT(3)),
+	AXP_DESC_RANGES_VOL_DELAY
+		(AXP803, DCDC5, "dcdc5", "vin5", axp803_dcdc5_ranges,
+		0x45, AXP803_DC5OUT_VOL, 0x7f, AXP803_LDO_DC_EN1, BIT(4)),
+	AXP_DESC_RANGES_VOL_DELAY
+		(AXP803, DCDC6, "dcdc6", "vin6", axp803_dcdc6_ranges,
+		0x48, AXP803_DC6OUT_VOL, 0x7f, AXP803_LDO_DC_EN1, BIT(5)),
+	AXP_DESC_RANGES_VOL_DELAY
+		(AXP803, DCDC7, "dcdc7", "vin7", axp803_dcdc5_ranges,
+		0x48, AXP803_DC7OUT_VOL, 0x7f, AXP803_LDO_DC_EN1, BIT(6)),
+	AXP_DESC_FIXED(AXP803, RTCLDO, "rtcldo", "rtcldoin", 1800),
+	AXP_DESC(AXP803, ALDO1, "aldo1", "aldoin", 700, 3300, 100,
+		AXP803_ALDO1OUT_VOL, 0x1f, AXP803_LDO_DC_EN3, BIT(5)),
+	AXP_DESC(AXP803, ALDO2, "aldo2", "aldoin", 700, 3300, 100,
+		AXP803_ALDO2OUT_VOL, 0x1f, AXP803_LDO_DC_EN3, BIT(6)),
+	AXP_DESC_RANGES(AXP803, ALDO3, "aldo3", "aldoin", axp803_aldo3_ranges,
+			0x20, AXP803_ALDO3OUT_VOL, 0x1f, AXP803_LDO_DC_EN3, BIT(7)),
+	AXP_DESC(AXP803, DLDO1, "dldo1", "dldoin", 700, 3300, 100,
+		AXP803_DLDO1OUT_VOL, 0x1f, AXP803_LDO_DC_EN2, BIT(3)),
+	AXP_DESC_RANGES(AXP803, DLDO2, "dldo2", "dldoin", axp803_dldo2_ranges,
+			0x20, AXP803_DLDO2OUT_VOL, 0x1f, AXP803_LDO_DC_EN2, BIT(4)),
+	AXP_DESC(AXP803, DLDO3, "dldo3", "dldoin", 700, 3300, 100,
+		AXP803_DLDO3OUT_VOL, 0x1f, AXP803_LDO_DC_EN2, BIT(5)),
+	AXP_DESC(AXP803, DLDO4, "dldo4", "dldoin", 700, 3300, 100,
+		AXP803_DLDO4OUT_VOL, 0x1f, AXP803_LDO_DC_EN2, BIT(6)),
+	AXP_DESC(AXP803, ELDO1, "eldo1", "eldoin", 700, 1900, 50,
+		 AXP803_ELDO1OUT_VOL, 0x1f, AXP803_LDO_DC_EN2, BIT(0)),
+	AXP_DESC(AXP803, ELDO2, "eldo2", "eldoin", 700, 1900, 50,
+		 AXP803_ELDO2OUT_VOL, 0x1f, AXP803_LDO_DC_EN2, BIT(1)),
+	AXP_DESC(AXP803, ELDO3, "eldo3", "eldoin", 700, 1900, 50,
+		 AXP803_ELDO3OUT_VOL, 0x1f, AXP803_LDO_DC_EN2, BIT(2)),
+	AXP_DESC(AXP803, FLDO1, "fldo1", "fldoin", 700, 1450, 50,
+		 AXP803_FLDO1OUT_VOL, 0x0f, AXP803_LDO_DC_EN3, BIT(2)),
+	AXP_DESC(AXP803, FLDO2, "fldo2", "fldoin", 700, 1450, 50,
+		 AXP803_FLDO2OUT_VOL, 0x0f, AXP803_LDO_DC_EN3, BIT(3)),
+	AXP_DESC_IO(AXP803, LDOIO0, "ldoio0", "ips", 700, 3300, 100,
+		    AXP803_GPIO0LDOOUT_VOL, 0x1f, AXP803_GPIO0_CTL, 0x07,
+		    0x3, 0x4),
+	AXP_DESC_IO(AXP803, LDOIO1, "ldoio1", "ips", 700, 3300, 100,
+		    AXP803_GPIO1LDOOUT_VOL, 0x1f, AXP803_GPIO1_CTL, 0x07,
+		    0x3, 0x4),
+	AXP_DESC_SW(AXP803, DC1SW, "dc1sw", "swin", AXP803_LDO_DC_EN2, BIT(7)),
+};
+
+static struct linear_range axp2202_dcdc1_ranger[] = {
+	REGULATOR_LINEAR_RANGE(500000, 0x0, 0x46, 10000),
+	REGULATOR_LINEAR_RANGE(1220000, 0x47, 0x57, 20000),
+};
+
+static struct linear_range axp2202_dcdc2_ranger[] = {
+	REGULATOR_LINEAR_RANGE(500000, 0, 0x46, 10000),
+	REGULATOR_LINEAR_RANGE(1220000, 0x47, 0x57, 20000),
+	REGULATOR_LINEAR_RANGE(1600000, 0x58, 0x6b, 100000),
+};
+
+static struct linear_range axp2202_dcdc3_ranger[] = {
+	REGULATOR_LINEAR_RANGE(500000, 0, 0x46, 10000),
+	REGULATOR_LINEAR_RANGE(1220000, 0x47, 0x66, 20000),
+};
+
+static const struct regulator_desc axp2202_regulators[] = {
+	AXP_DESC_RANGES(AXP2202, DCDC1, "dcdc1", "vin-ps", axp2202_dcdc1_ranger,
+			0x58, AXP2202_DCDC1_CFG, GENMASK(6, 0),
+			AXP2202_DCDC_CFG0, BIT(0)),
+	AXP_DESC_RANGES(AXP2202, DCDC2, "dcdc2", "vin-ps", axp2202_dcdc2_ranger,
+			0x6c, AXP2202_DCDC2_CFG, GENMASK(6, 0),
+			AXP2202_DCDC_CFG0, BIT(1)),
+	AXP_DESC_RANGES(AXP2202, DCDC3, "dcdc3", "vin-ps", axp2202_dcdc3_ranger,
+			0x67, AXP2202_DCDC3_CFG, GENMASK(6, 0),
+			AXP2202_DCDC_CFG0, BIT(2)),
+	AXP_DESC(AXP2202, CPUSLDO, "cpusldo", "vin-ps", 500, 1400, 50,
+		 AXP2202_CPUSLDO_CFG, GENMASK(4, 0), AXP2202_LDO_EN_CFG1,
+		 BIT(4)),
+	AXP_DESC(AXP2202, ALDO1, "aldo1", "aldo", 500, 3500, 100,
+		 AXP2202_ALDO1_CFG, GENMASK(4, 0), AXP2202_LDO_EN_CFG0,
+		 BIT(0)),
+	AXP_DESC(AXP2202, ALDO2, "aldo2", "aldo", 500, 3500, 100,
+		 AXP2202_ALDO2_CFG, GENMASK(4, 0), AXP2202_LDO_EN_CFG0,
+		 BIT(1)),
+	AXP_DESC(AXP2202, ALDO3, "aldo3", "aldo", 500, 3500, 100,
+		 AXP2202_ALDO3_CFG, GENMASK(4, 0), AXP2202_LDO_EN_CFG0,
+		 BIT(2)),
+	AXP_DESC(AXP2202, ALDO4, "aldo4", "aldo", 500, 3500, 100,
+		 AXP2202_ALDO4_CFG, GENMASK(4, 0), AXP2202_LDO_EN_CFG0,
+		 BIT(3)),
+	AXP_DESC(AXP2202, BLDO1, "bldo1", "bldo", 500, 3500, 100,
+		 AXP2202_BLDO1_CFG, GENMASK(4, 0), AXP2202_LDO_EN_CFG0,
+		 BIT(4)),
+	AXP_DESC(AXP2202, BLDO2, "bldo2", "bldo", 500, 3500, 100,
+		 AXP2202_BLDO2_CFG, GENMASK(4, 0), AXP2202_LDO_EN_CFG0,
+		 BIT(5)),
+	AXP_DESC(AXP2202, BLDO3, "bldo3", "bldo", 500, 3500, 100,
+		 AXP2202_BLDO3_CFG, GENMASK(4, 0), AXP2202_LDO_EN_CFG0,
+		 BIT(6)),
+	AXP_DESC(AXP2202, BLDO4, "bldo4", "bldo", 500, 1400, 50,
+		 AXP2202_BLDO4_CFG, GENMASK(4, 0), AXP2202_LDO_EN_CFG0,
+		 BIT(7)),
+	AXP_DESC(AXP2202, CLDO1, "cldo1", "cldo", 500, 1400, 50,
+		 AXP2202_CLDO1_CFG, GENMASK(4, 0), AXP2202_LDO_EN_CFG1,
+		 BIT(0)),
+	AXP_DESC(AXP2202, CLDO2, "cldo2", "cldo", 500, 1400, 50,
+		 AXP2202_CLDO2_CFG, GENMASK(4, 0), AXP2202_LDO_EN_CFG1,
+		 BIT(1)),
+	AXP_DESC(AXP2202, CLDO3, "cldo3", "cldo", 500, 1400, 50,
+		 AXP2202_CLDO3_CFG, GENMASK(4, 0), AXP2202_LDO_EN_CFG1,
+		 BIT(2)),
+	AXP_DESC(AXP2202, CLDO4, "cldo4", "cldo", 500, 1400, 50,
+		 AXP2202_CLDO4_CFG, GENMASK(4, 0), AXP2202_LDO_EN_CFG1,
+		 BIT(3)),
+};
+
+static const struct regulator_desc axp803_drivevbus_regulator = {
+	.name		= "drivevbus",
+	.supply_name	= "drivevbusin",
+	.of_match	= of_match_ptr("drivevbus"),
+	.regulators_node = of_match_ptr("regulators"),
+	.type		= REGULATOR_VOLTAGE,
+	.owner		= THIS_MODULE,
+	.enable_reg	= AXP803_IPS_SET,
+	.enable_mask	= BIT(2),
+	.ops		= &axp20x_ops_sw,
+};
+
+static int axp20x_set_dcdc_freq(struct platform_device *pdev, u32 dcdcfreq)
+{
+	struct axp20x_dev *axp20x = dev_get_drvdata(pdev->dev.parent);
+	unsigned int reg = AXP20X_DCDC_FREQ;
+	u32 min, max, def, step;
+
+	switch (axp20x->variant) {
+	case AXP202_ID:
+	case AXP209_ID:
+		min = 750;
+		max = 1875;
+		def = 1500;
+		step = 75;
+		break;
+	case AXP806_ID:
+		/*
+		 * AXP806 DCDC work frequency setting has the same range and
+		 * step as AXP22X, but at a different register.
+		 * Fall through to the check below.
+		 * (See include/linux/mfd/axp20x.h)
+		 */
+		reg = AXP806_DCDC_FREQ_CTRL;
+	case AXP221_ID:
+	case AXP223_ID:
+	case AXP809_ID:
+		min = 1800;
+		max = 4050;
+		def = 3000;
+		step = 150;
+		break;
+	default:
+		dev_err(&pdev->dev,
+			"Setting DCDC frequency for unsupported AXP variant\n");
+		return -EINVAL;
+	}
+
+	if (dcdcfreq == 0)
+		dcdcfreq = def;
+
+	if (dcdcfreq < min) {
+		dcdcfreq = min;
+		dev_warn(&pdev->dev, "DCDC frequency too low. Set to %ukHz\n",
+			 min);
+	}
+
+	if (dcdcfreq > max) {
+		dcdcfreq = max;
+		dev_warn(&pdev->dev, "DCDC frequency too high. Set to %ukHz\n",
+			 max);
+	}
+
+	dcdcfreq = (dcdcfreq - min) / step;
+
+	return regmap_update_bits(axp20x->regmap, reg,
+				  AXP20X_FREQ_DCDC_MASK, dcdcfreq);
+}
+
+static int axp20x_regulator_parse_dt(struct platform_device *pdev)
+{
+	struct device_node *np, *regulators;
+	int ret;
+	u32 dcdcfreq = 0;
+
+	np = of_node_get(pdev->dev.parent->of_node);
+	if (!np)
+		return 0;
+
+	regulators = of_get_child_by_name(np, "regulators");
+	if (!regulators) {
+		dev_warn(&pdev->dev, "regulators node not found\n");
+	} else {
+		of_property_read_u32(regulators, "x-powers,dcdc-freq", &dcdcfreq);
+		ret = axp20x_set_dcdc_freq(pdev, dcdcfreq);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "Error setting dcdc frequency: %d\n", ret);
+			return ret;
+		}
+
+		of_node_put(regulators);
+	}
+
+	return 0;
+}
+
+static int axp20x_set_dcdc_workmode(struct regulator_dev *rdev, int id, u32 workmode)
+{
+	struct axp20x_dev *axp20x = rdev_get_drvdata(rdev);
+	unsigned int reg = AXP20X_DCDC_MODE;
+	unsigned int mask;
+
+	switch (axp20x->variant) {
+	case AXP202_ID:
+	case AXP209_ID:
+		if ((id != AXP20X_DCDC2) && (id != AXP20X_DCDC3))
+			return -EINVAL;
+
+		mask = AXP20X_WORKMODE_DCDC2_MASK;
+		if (id == AXP20X_DCDC3)
+			mask = AXP20X_WORKMODE_DCDC3_MASK;
+
+		workmode <<= ffs(mask) - 1;
+		break;
+
+	case AXP806_ID:
+		reg = AXP806_DCDC_MODE_CTRL2;
+		/*
+		 * AXP806 DCDC regulator IDs have the same range as AXP22X.
+		 * Fall through to the check below.
+		 * (See include/linux/mfd/axp20x.h)
+		 */
+	case AXP221_ID:
+	case AXP223_ID:
+	case AXP809_ID:
+		if (id < AXP22X_DCDC1 || id > AXP22X_DCDC5)
+			return -EINVAL;
+
+		mask = AXP22X_WORKMODE_DCDCX_MASK(id - AXP22X_DCDC1);
+		workmode <<= id - AXP22X_DCDC1;
+		break;
+
+	default:
+		/* should not happen */
+		WARN_ON(1);
+		return -EINVAL;
+	}
+
+	return regmap_update_bits(rdev->regmap, reg, mask, workmode);
+}
+
+/*
+ * This function checks whether a regulator is part of a poly-phase
+ * output setup based on the registers settings. Returns true if it is.
+ */
+static bool axp20x_is_polyphase_slave(struct axp20x_dev *axp20x, int id)
+{
+	u32 reg = 0;
+
+	/* Only AXP806 has poly-phase outputs */
+	if (axp20x->variant != AXP806_ID)
+		return false;
+
+	regmap_read(axp20x->regmap, AXP806_DCDC_MODE_CTRL2, &reg);
+
+	switch (id) {
+	case AXP806_DCDCB:
+		return (((reg & GENMASK(7, 6)) == BIT(6)) ||
+			((reg & GENMASK(7, 6)) == BIT(7)));
+	case AXP806_DCDCC:
+		return ((reg & GENMASK(7, 6)) == BIT(7));
+	case AXP806_DCDCE:
+		return !!(reg & BIT(5));
+	}
+
+	return false;
+}
+
+static int axp2101_regulator_probe(struct platform_device *pdev)
+{
+	struct regulator_dev *rdev;
+	struct axp20x_dev *axp20x = dev_get_drvdata(pdev->dev.parent);
+	const struct regulator_desc *regulators;
+	struct regulator_config config = {
+		.dev = pdev->dev.parent,
+		.regmap = axp20x->regmap,
+		.driver_data = axp20x,
+	};
+	int ret, i, nregulators;
+	u32 workmode;
+	const char *dcdc1_name = axp22x_regulators[AXP22X_DCDC1].name;
+	const char *dcdc5_name = axp22x_regulators[AXP22X_DCDC5].name;
+	bool drivevbus = false;
+	u32 dval;
+	struct regulator_delay *rdev_delay;
+
+	switch (axp20x->variant) {
+	case AXP152_ID:
+		regulators = axp152_regulators;
+		nregulators = AXP152_REG_ID_MAX;
+		break;
+	case AXP202_ID:
+	case AXP209_ID:
+		regulators = axp20x_regulators;
+		nregulators = AXP20X_REG_ID_MAX;
+		break;
+	case AXP221_ID:
+	case AXP223_ID:
+		regulators = axp22x_regulators;
+		nregulators = AXP22X_REG_ID_MAX;
+		drivevbus = of_property_read_bool(pdev->dev.parent->of_node,
+						  "x-powers,drive-vbus-en");
+		break;
+	case AXP806_ID:
+		regulators = axp806_regulators;
+		nregulators = AXP806_REG_ID_MAX;
+		break;
+	case AXP809_ID:
+		regulators = axp809_regulators;
+		nregulators = AXP809_REG_ID_MAX;
+		break;
+	case AXP2101_ID:
+		regulators = axp2101_regulators;
+		nregulators = AXP2101_REG_ID_MAX;
+		break;
+	case AXP15_ID:
+		regulators = axp15_regulators;
+		nregulators = AXP15_REG_ID_MAX;
+		break;
+	case AXP1530_ID:
+		regulators = axp1530_regulators;
+		nregulators = AXP1530_REG_ID_MAX;
+		break;
+	case AXP858_ID:
+		regulators = axp858_regulators;
+		nregulators = AXP858_REG_ID_MAX;
+		break;
+	case AXP803_ID:
+		regulators = axp803_regulators;
+		nregulators = AXP803_REG_ID_MAX;
+		drivevbus = of_property_read_bool(pdev->dev.parent->of_node,
+						  "x-powers,drive-vbus-en");
+		break;
+	case AXP2202_ID:
+		regulators = axp2202_regulators;
+		nregulators = AXP2202_REG_ID_MAX;
+		break;
+	default:
+		dev_err(&pdev->dev, "Unsupported AXP variant: %ld\n",
+			axp20x->variant);
+		return -EINVAL;
+	}
+
+	/* This only sets the dcdc freq. Ignore any errors */
+	axp20x_regulator_parse_dt(pdev);
+
+	for (i = 0; i < nregulators; i++) {
+		const struct regulator_desc *desc = &regulators[i];
+		struct regulator_desc *new_desc;
+
+		/*
+		 * If this regulator is a slave in a poly-phase setup,
+		 * skip it, as its controls are bound to the master
+		 * regulator and won't work.
+		 */
+		if (axp20x_is_polyphase_slave(axp20x, i))
+			continue;
+
+		/*
+		 * Regulators DC1SW and DC5LDO are connected internally,
+		 * so we have to handle their supply names separately.
+		 *
+		 * We always register the regulators in proper sequence,
+		 * so the supply names are correctly read. See the last
+		 * part of this loop to see where we save the DT defined
+		 * name.
+		 */
+		if ((regulators == axp22x_regulators && i == AXP22X_DC1SW) ||
+		    (regulators == axp809_regulators && i == AXP809_DC1SW)) {
+			new_desc = devm_kzalloc(&pdev->dev, sizeof(*desc),
+						GFP_KERNEL);
+			*new_desc = regulators[i];
+			new_desc->supply_name = dcdc1_name;
+			desc = new_desc;
+		}
+
+		if ((regulators == axp22x_regulators && i == AXP22X_DC5LDO) ||
+		    (regulators == axp809_regulators && i == AXP809_DC5LDO)) {
+			new_desc = devm_kzalloc(&pdev->dev, sizeof(*desc),
+						GFP_KERNEL);
+			*new_desc = regulators[i];
+			new_desc->supply_name = dcdc5_name;
+			desc = new_desc;
+		}
+
+		rdev = devm_regulator_register(&pdev->dev, desc, &config);
+		if (IS_ERR(rdev)) {
+			dev_err(&pdev->dev, "Failed to register %s\n",
+				regulators[i].name);
+
+			return PTR_ERR(rdev);
+		}
+
+		rdev_delay = devm_kzalloc(&pdev->dev, sizeof(*rdev_delay), GFP_KERNEL);
+		if (!of_property_read_u32(rdev->dev.of_node,
+				"regulator-step-delay-us", &dval))
+			rdev_delay->step = dval;
+		else
+			rdev_delay->step = 0;
+
+		if (!of_property_read_u32(rdev->dev.of_node,
+				"regulator-final-delay-us", &dval))
+			rdev_delay->final = dval;
+		else
+			rdev_delay->final = 0;
+
+		rdev->reg_data = rdev_delay;
+
+		ret = of_property_read_u32(rdev->dev.of_node,
+					   "x-powers,dcdc-workmode",
+					   &workmode);
+		if (!ret) {
+			if (axp20x_set_dcdc_workmode(rdev, i, workmode))
+				dev_err(&pdev->dev, "Failed to set workmode on %s\n",
+					rdev->desc->name);
+		}
+
+		/*
+		 * Save AXP22X DCDC1 / DCDC5 regulator names for later.
+		 */
+		if ((regulators == axp22x_regulators && i == AXP22X_DCDC1) ||
+		    (regulators == axp809_regulators && i == AXP809_DCDC1))
+			of_property_read_string(rdev->dev.of_node,
+						"regulator-name",
+						&dcdc1_name);
+
+		if ((regulators == axp22x_regulators && i == AXP22X_DCDC5) ||
+		    (regulators == axp809_regulators && i == AXP809_DCDC5))
+			of_property_read_string(rdev->dev.of_node,
+						"regulator-name",
+						&dcdc5_name);
+	}
+
+	if (drivevbus) {
+		switch (axp20x->variant) {
+		case AXP221_ID:
+		case AXP223_ID:
+			/* Change N_VBUSEN sense pin to DRIVEVBUS output pin */
+			regmap_update_bits(axp20x->regmap, AXP20X_OVER_TMP,
+					   AXP22X_MISC_N_VBUSEN_FUNC, 0);
+			rdev = devm_regulator_register(&pdev->dev,
+						       &axp22x_drivevbus_regulator,
+						       &config);
+			break;
+		case AXP803_ID:
+			/* Change N_VBUSEN sense pin to DRIVEVBUS output pin */
+			regmap_update_bits(axp20x->regmap, AXP803_HOTOVER_CTL,
+					   AXP803_MISC_N_VBUSEN_FUNC, 0);
+			rdev = devm_regulator_register(&pdev->dev,
+						       &axp803_drivevbus_regulator,
+						       &config);
+			break;
+		default:
+			dev_err(&pdev->dev, "AXP variant: %ld unsupported drivevbus\n",
+				axp20x->variant);
+			return -EINVAL;
+		}
+
+		if (IS_ERR(rdev)) {
+			dev_err(&pdev->dev, "Failed to register drivevbus\n");
+			return PTR_ERR(rdev);
+		}
+	}
+
+	return 0;
+}
+
+static int axp2101_regulator_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct of_device_id axp_regulator_id_tab[] = {
+	{ .compatible = "x-powers,axp2202-regulator" },
+	{ /* sentinel */ },
+};
+
+static struct platform_driver axp2101_regulator_driver = {
+	.probe	= axp2101_regulator_probe,
+	.remove	= axp2101_regulator_remove,
+	.driver	= {
+		.of_match_table = axp_regulator_id_tab,
+		.name		= "axp2101-regulator",
+	},
+};
+
+static int __init axp2101_regulator_init(void)
+{
+	return platform_driver_register(&axp2101_regulator_driver);
+}
+
+static void __exit axp2101_regulator_exit(void)
+{
+	platform_driver_unregister(&axp2101_regulator_driver);
+}
+
+subsys_initcall(axp2101_regulator_init);
+module_exit(axp2101_regulator_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Carlo Caione <carlo@caione.org>");
+MODULE_DESCRIPTION("Regulator Driver for AXP20X PMIC");
+MODULE_ALIAS("platform:axp20x-regulator");
+
diff --git a/include/linux/mfd/axp2101.h b/include/linux/mfd/axp2101.h
new file mode 100644
index 000000000..7ac7753ed
--- /dev/null
+++ b/include/linux/mfd/axp2101.h
@@ -0,0 +1,1685 @@
+/*
+ * Functions and registers to access AXP20X power management chip.
+ *
+ * Copyright (C) 2013, Carlo Caione <carlo@caione.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __LINUX_MFD_AXP20X_H
+#define __LINUX_MFD_AXP20X_H
+
+#include <linux/regmap.h>
+
+enum {
+	AXP152_ID = 0,
+	AXP202_ID,
+	AXP209_ID,
+	AXP221_ID,
+	AXP223_ID,
+	AXP288_ID,
+	AXP806_ID,
+	AXP809_ID,
+	AXP2101_ID,
+	AXP15_ID,
+	AXP1530_ID,
+	AXP858_ID,
+	AXP803_ID,
+	AXP2202_ID,
+	AXP2585_ID,
+	NR_AXP20X_VARIANTS,
+};
+
+enum {
+	AXP_SPLY = 1U << 0,
+	AXP_REGU = 1U << 1,
+	AXP_INT  = 1U << 2,
+	AXP_CHG  = 1U << 3,
+	AXP_MISC = 1U << 4,
+};
+
+extern int axp_debug_mask;
+
+#define AXP20X_DATACACHE(m)		(0x04 + (m))
+
+/* Power supply */
+#define AXP152_PWR_OP_MODE		0x01
+#define AXP152_LDO3456_DC1234_CTRL	0x12
+#define AXP152_ALDO_OP_MODE		0x13
+#define AXP152_LDO0_CTRL		0x15
+#define AXP152_DCDC2_V_OUT		0x23
+#define AXP152_DCDC2_V_SCAL		0x25
+#define AXP152_DCDC1_V_OUT		0x26
+#define AXP152_DCDC3_V_OUT		0x27
+#define AXP152_ALDO12_V_OUT		0x28
+#define AXP152_DLDO1_V_OUT		0x29
+#define AXP152_DLDO2_V_OUT		0x2a
+#define AXP152_DCDC4_V_OUT		0x2b
+#define AXP152_V_OFF			0x31
+#define AXP152_OFF_CTRL			0x32
+#define AXP152_PEK_KEY			0x36
+#define AXP152_DCDC_FREQ		0x37
+#define AXP152_DCDC_MODE		0x80
+
+#define AXP20X_PWR_INPUT_STATUS		0x00
+#define AXP20X_PWR_OP_MODE		0x01
+#define AXP20X_USB_OTG_STATUS		0x02
+#define AXP20X_PWR_OUT_CTRL		0x12
+#define AXP20X_DCDC2_V_OUT		0x23
+#define AXP20X_DCDC2_LDO3_V_SCAL	0x25
+#define AXP20X_DCDC3_V_OUT		0x27
+#define AXP20X_LDO24_V_OUT		0x28
+#define AXP20X_LDO3_V_OUT		0x29
+#define AXP20X_VBUS_IPSOUT_MGMT		0x30
+#define AXP20X_V_OFF			0x31
+#define AXP20X_OFF_CTRL			0x32
+#define AXP20X_CHRG_CTRL1		0x33
+#define AXP20X_CHRG_CTRL2		0x34
+#define AXP20X_CHRG_BAK_CTRL		0x35
+#define AXP20X_PEK_KEY			0x36
+#define AXP20X_DCDC_FREQ		0x37
+#define AXP20X_V_LTF_CHRG		0x38
+#define AXP20X_V_HTF_CHRG		0x39
+#define AXP20X_APS_WARN_L1		0x3a
+#define AXP20X_APS_WARN_L2		0x3b
+#define AXP20X_V_LTF_DISCHRG		0x3c
+#define AXP20X_V_HTF_DISCHRG		0x3d
+
+#define AXP22X_PWR_OUT_CTRL1		0x10
+#define AXP22X_PWR_OUT_CTRL2		0x12
+#define AXP22X_PWR_OUT_CTRL3		0x13
+#define AXP22X_DLDO1_V_OUT		0x15
+#define AXP22X_DLDO2_V_OUT		0x16
+#define AXP22X_DLDO3_V_OUT		0x17
+#define AXP22X_DLDO4_V_OUT		0x18
+#define AXP22X_ELDO1_V_OUT		0x19
+#define AXP22X_ELDO2_V_OUT		0x1a
+#define AXP22X_ELDO3_V_OUT		0x1b
+#define AXP22X_DC5LDO_V_OUT		0x1c
+#define AXP22X_DCDC1_V_OUT		0x21
+#define AXP22X_DCDC2_V_OUT		0x22
+#define AXP22X_DCDC3_V_OUT		0x23
+#define AXP22X_DCDC4_V_OUT		0x24
+#define AXP22X_DCDC5_V_OUT		0x25
+#define AXP22X_DCDC23_V_RAMP_CTRL	0x27
+#define AXP22X_ALDO1_V_OUT		0x28
+#define AXP22X_ALDO2_V_OUT		0x29
+#define AXP22X_ALDO3_V_OUT		0x2a
+#define AXP22X_CHRG_CTRL3		0x35
+
+#define AXP806_STARTUP_SRC		0x00
+#define AXP806_CHIP_ID			0x03
+#define AXP806_PWR_OUT_CTRL1		0x10
+#define AXP806_PWR_OUT_CTRL2		0x11
+#define AXP806_DCDCA_V_CTRL		0x12
+#define AXP806_DCDCB_V_CTRL		0x13
+#define AXP806_DCDCC_V_CTRL		0x14
+#define AXP806_DCDCD_V_CTRL		0x15
+#define AXP806_DCDCE_V_CTRL		0x16
+#define AXP806_ALDO1_V_CTRL		0x17
+#define AXP806_ALDO2_V_CTRL		0x18
+#define AXP806_ALDO3_V_CTRL		0x19
+#define AXP806_DCDC_MODE_CTRL1		0x1a
+#define AXP806_DCDC_MODE_CTRL2		0x1b
+#define AXP806_DCDC_FREQ_CTRL		0x1c
+#define AXP806_BLDO1_V_CTRL		0x20
+#define AXP806_BLDO2_V_CTRL		0x21
+#define AXP806_BLDO3_V_CTRL		0x22
+#define AXP806_BLDO4_V_CTRL		0x23
+#define AXP806_CLDO1_V_CTRL		0x24
+#define AXP806_CLDO2_V_CTRL		0x25
+#define AXP806_CLDO3_V_CTRL		0x26
+#define AXP806_VREF_TEMP_WARN_L		0xf3
+
+#define AXP806_STARTUP_SOURCE      (0x00)
+#define AXP806_IC_TYPE             (0x03)
+#define AXP806_DATA_BUFFER1        (0x04)
+#define AXP806_DATA_BUFFER2        (0x05)
+#define AXP806_DATA_BUFFER3        (0x06)
+#define AXP806_DATA_BUFFER4        (0x07)
+#define AXP806_ONOFF_CTRL1         (0x10)
+#define AXP806_ONOFF_CTRL2         (0x11)
+#define AXP806_DCAOUT_VOL          (0x12)
+#define AXP806_DCBOUT_VOL          (0x13)
+#define AXP806_DCCOUT_VOL          (0x14)
+#define AXP806_DCDOUT_VOL          (0x15)
+#define AXP806_DCEOUT_VOL          (0x16)
+#define AXP806_ALDO1OUT_VOL        (0x17)
+#define AXP806_ALDO2OUT_VOL        (0x18)
+#define AXP806_ALDO3OUT_VOL        (0x19)
+#define AXP806_DCDC_DVM_CTRL       (0x1A)
+#define AXP806_DCDC_MODE_CTRL      (0x1B)
+#define AXP806_DCDC_FREQSET        (0x1C)
+#define AXP806_DCDC_MON_CTRL       (0x1D)
+#define AXP806_IFQ_PWROK_SET       (0x1F)
+#define AXP806_BLDO1OUT_VOL        (0x20)
+#define AXP806_BLDO2OUT_VOL        (0x21)
+#define AXP806_BLDO3OUT_VOL        (0x22)
+#define AXP806_BLDO4OUT_VOL        (0x23)
+#define AXP806_CLDO1OUT_VOL        (0x24)
+#define AXP806_CLDO2OUT_VOL        (0x25)
+#define AXP806_CLDO3OUT_VOL        (0x26)
+#define AXP806_VOFF_SET            (0x31)
+#define AXP806_OFF_CTL             (0x32)
+#define AXP806_WAKEUP_PIN_CTRL     (0x35)
+#define AXP806_POK_SET             (0x36)
+#define AXP806_INTERFACE_MODE      (0x3E)
+#define AXP806_SPECIAL_CTRL        (0x3F)
+
+#define AXP806_INTEN1              (0x40)
+#define AXP806_INTEN2              (0x41)
+#define AXP806_INTSTS1             (0x48)
+#define AXP806_INTSTS2             (0x49)
+#define AXP806_REG_ADDR_EXT		0xFF
+
+/* Interrupt */
+#define AXP152_IRQ1_EN			0x40
+#define AXP152_IRQ2_EN			0x41
+#define AXP152_IRQ3_EN			0x42
+#define AXP152_IRQ1_STATE		0x48
+#define AXP152_IRQ2_STATE		0x49
+#define AXP152_IRQ3_STATE		0x4a
+
+#define AXP20X_IRQ1_EN			0x40
+#define AXP20X_IRQ2_EN			0x41
+#define AXP20X_IRQ3_EN			0x42
+#define AXP20X_IRQ4_EN			0x43
+#define AXP20X_IRQ5_EN			0x44
+#define AXP20X_IRQ6_EN			0x45
+#define AXP20X_IRQ1_STATE		0x48
+#define AXP20X_IRQ2_STATE		0x49
+#define AXP20X_IRQ3_STATE		0x4a
+#define AXP20X_IRQ4_STATE		0x4b
+#define AXP20X_IRQ5_STATE		0x4c
+#define AXP20X_IRQ6_STATE		0x4d
+
+/* ADC */
+#define AXP20X_ACIN_V_ADC_H		0x56
+#define AXP20X_ACIN_V_ADC_L		0x57
+#define AXP20X_ACIN_I_ADC_H		0x58
+#define AXP20X_ACIN_I_ADC_L		0x59
+#define AXP20X_VBUS_V_ADC_H		0x5a
+#define AXP20X_VBUS_V_ADC_L		0x5b
+#define AXP20X_VBUS_I_ADC_H		0x5c
+#define AXP20X_VBUS_I_ADC_L		0x5d
+#define AXP20X_TEMP_ADC_H		0x5e
+#define AXP20X_TEMP_ADC_L		0x5f
+#define AXP20X_TS_IN_H			0x62
+#define AXP20X_TS_IN_L			0x63
+#define AXP20X_GPIO0_V_ADC_H		0x64
+#define AXP20X_GPIO0_V_ADC_L		0x65
+#define AXP20X_GPIO1_V_ADC_H		0x66
+#define AXP20X_GPIO1_V_ADC_L		0x67
+#define AXP20X_PWR_BATT_H		0x70
+#define AXP20X_PWR_BATT_M		0x71
+#define AXP20X_PWR_BATT_L		0x72
+#define AXP20X_BATT_V_H			0x78
+#define AXP20X_BATT_V_L			0x79
+#define AXP20X_BATT_CHRG_I_H		0x7a
+#define AXP20X_BATT_CHRG_I_L		0x7b
+#define AXP20X_BATT_DISCHRG_I_H		0x7c
+#define AXP20X_BATT_DISCHRG_I_L		0x7d
+#define AXP20X_IPSOUT_V_HIGH_H		0x7e
+#define AXP20X_IPSOUT_V_HIGH_L		0x7f
+
+/* Power supply */
+#define AXP20X_DCDC_MODE		0x80
+#define AXP20X_ADC_EN1			0x82
+#define AXP20X_ADC_EN2			0x83
+#define AXP20X_ADC_RATE			0x84
+#define AXP20X_GPIO10_IN_RANGE		0x85
+#define AXP20X_GPIO1_ADC_IRQ_RIS	0x86
+#define AXP20X_GPIO1_ADC_IRQ_FAL	0x87
+#define AXP20X_TIMER_CTRL		0x8a
+#define AXP20X_VBUS_MON			0x8b
+#define AXP20X_OVER_TMP			0x8f
+
+#define AXP22X_PWREN_CTRL1		0x8c
+#define AXP22X_PWREN_CTRL2		0x8d
+
+/* GPIO */
+#define AXP152_GPIO0_CTRL		0x90
+#define AXP152_GPIO1_CTRL		0x91
+#define AXP152_GPIO2_CTRL		0x92
+#define AXP152_GPIO3_CTRL		0x93
+#define AXP152_LDOGPIO2_V_OUT		0x96
+#define AXP152_GPIO_INPUT		0x97
+#define AXP152_PWM0_FREQ_X		0x98
+#define AXP152_PWM0_FREQ_Y		0x99
+#define AXP152_PWM0_DUTY_CYCLE		0x9a
+#define AXP152_PWM1_FREQ_X		0x9b
+#define AXP152_PWM1_FREQ_Y		0x9c
+#define AXP152_PWM1_DUTY_CYCLE		0x9d
+
+#define AXP20X_GPIO0_CTRL		0x90
+#define AXP20X_LDO5_V_OUT		0x91
+#define AXP20X_GPIO1_CTRL		0x92
+#define AXP20X_GPIO2_CTRL		0x93
+#define AXP20X_GPIO20_SS		0x94
+#define AXP20X_GPIO3_CTRL		0x95
+
+#define AXP22X_LDO_IO0_V_OUT		0x91
+#define AXP22X_LDO_IO1_V_OUT		0x93
+#define AXP22X_GPIO_STATE		0x94
+#define AXP22X_GPIO_PULL_DOWN		0x95
+
+/* Battery */
+#define AXP20X_CHRG_CC_31_24		0xb0
+#define AXP20X_CHRG_CC_23_16		0xb1
+#define AXP20X_CHRG_CC_15_8		0xb2
+#define AXP20X_CHRG_CC_7_0		0xb3
+#define AXP20X_DISCHRG_CC_31_24		0xb4
+#define AXP20X_DISCHRG_CC_23_16		0xb5
+#define AXP20X_DISCHRG_CC_15_8		0xb6
+#define AXP20X_DISCHRG_CC_7_0		0xb7
+#define AXP20X_CC_CTRL			0xb8
+#define AXP20X_FG_RES			0xb9
+
+/* OCV */
+#define AXP20X_RDC_H			0xba
+#define AXP20X_RDC_L			0xbb
+#define AXP20X_OCV(m)			(0xc0 + (m))
+#define AXP20X_OCV_MAX			0xf
+
+/* AXP22X specific registers */
+#define AXP22X_BATLOW_THRES1		0xe6
+
+/* AXP288 specific registers */
+#define AXP288_PMIC_ADC_H               0x56
+#define AXP288_PMIC_ADC_L               0x57
+#define AXP288_ADC_TS_PIN_CTRL          0x84
+#define AXP288_PMIC_ADC_EN              0x84
+
+/* Fuel Gauge */
+#define AXP288_FG_RDC1_REG          0xba
+#define AXP288_FG_RDC0_REG          0xbb
+#define AXP288_FG_OCVH_REG          0xbc
+#define AXP288_FG_OCVL_REG          0xbd
+#define AXP288_FG_OCV_CURVE_REG     0xc0
+#define AXP288_FG_DES_CAP1_REG      0xe0
+#define AXP288_FG_DES_CAP0_REG      0xe1
+#define AXP288_FG_CC_MTR1_REG       0xe2
+#define AXP288_FG_CC_MTR0_REG       0xe3
+#define AXP288_FG_OCV_CAP_REG       0xe4
+#define AXP288_FG_CC_CAP_REG        0xe5
+#define AXP288_FG_LOW_CAP_REG       0xe6
+#define AXP288_FG_TUNE0             0xe8
+#define AXP288_FG_TUNE1             0xe9
+#define AXP288_FG_TUNE2             0xea
+#define AXP288_FG_TUNE3             0xeb
+#define AXP288_FG_TUNE4             0xec
+#define AXP288_FG_TUNE5             0xed
+
+#define AXP2101_COMM_STAT0      (0x00)
+#define AXP2101_COMM_STAT1      (0x01)
+#define AXP2101_CHIP_ID         (0x03)
+#define AXP2101_DATA_BUFFER0    (0x04)
+#define AXP2101_DATA_BUFFER1    (0x05)
+#define AXP2101_DATA_BUFFER2    (0x06)
+#define AXP2101_DATA_BUFFER3    (0x07)
+#define AXP2101_COMM_FAULT      (0x08)
+#define AXP2101_COMM_CFG        (0X10)
+#define AXP2101_BATFET_CTRL     (0X12)
+#define AXP2101_DIE_TEMP_CFG    (0X13)
+#define AXP2101_VSYS_MIN        (0x14)
+#define AXP2101_VINDPM_CFG      (0x15)
+#define AXP2101_IIN_LIM         (0x16)
+#define AXP2101_RESET_CFG       (0x17)
+#define AXP2101_MODULE_EN       (0x18)
+#define AXP2101_WATCHDOG_CFG    (0x19)
+#define AXP2101_GAUGE_THLD      (0x1A)
+#define AXP2101_GPIO12_CTRL     (0x1B)
+#define AXP2101_GPIO34_CTRL     (0x1C)
+#define AXP2101_BUS_MODE_SEL    (0x1D)
+#define AXP2101_PWRON_STAT      (0x20)
+#define AXP2101_PWROFF_STAT     (0x21)
+#define AXP2101_PWROFF_EN       (0x22)
+#define AXP2101_DCDC_PWROFF_EN  (0x23)
+#define AXP2101_VOFF_THLD       (0x24)
+#define AXP2101_PWR_TIME_CTRL   (0x25)
+#define AXP2101_SLEEP_CFG       (0x26)
+#define AXP2101_PONLEVEL        (0x27)
+#define AXP2101_FAST_PWRON_CFG0 (0x28)
+#define AXP2101_FAST_PWRON_CFG1 (0x29)
+#define AXP2101_FAST_PWRON_CFG2 (0x2A)
+#define AXP2101_FAST_PWRON_CFG3 (0x2B)
+#define AXP2101_ADC_CH_EN0      (0x30)
+#define AXP2101_ADC_CH_EN1      (0x31)
+#define AXP2101_ADC_CH_EN2      (0x32)
+#define AXP2101_ADC_CH_EN3      (0x33)
+#define AXP2101_VBAT_H          (0x34)
+#define AXP2101_VBAT_L          (0x35)
+#define AXP2101_TS_H            (0x36)
+#define AXP2101_TS_L            (0x37)
+#define AXP2101_VBUS_H          (0x38)
+#define AXP2101_VBUS_L          (0x39)
+#define AXP2101_VSYS_H          (0x3A)
+#define AXP2101_VSYS_L          (0x3B)
+#define AXP2101_TDIE_H          (0x3C)
+#define AXP2101_TDIE_L          (0x3D)
+#define AXP2101_GPADC_H         (0x3E)
+#define AXP2101_GPADC_L         (0x3F)
+#define AXP2101_INTEN1          (0x40)
+#define AXP2101_INTEN2          (0x41)
+#define AXP2101_INTEN3          (0x42)
+#define AXP2101_INTSTS1         (0x48)
+#define AXP2101_INTSTS2         (0x49)
+#define AXP2101_INTSTS3         (0x4A)
+#define AXP2101_TS_CFG          (0x50)
+
+#define AXP2101_TS_HYSHL2H      (0x52)
+#define AXP2101_TS_HYSH21       (0x53)
+#define AXP2101_VLTF_CHG        (0x54)
+#define AXP2101_VHTF_CHG        (0x55)
+#define AXP2101_VLTF_WORK       (0x56)
+#define AXP2101_VHTF_WORK       (0x57)
+#define AXP2101_JEITA_CFG       (0x58)
+#define AXP2101_JEITA_CV_CFG    (0x59)
+#define AXP2101_JEITA_COOL      (0x5A)
+#define AXP2101_JEITA_WARM      (0x5B)
+#define AXP2101_TS_CFG_DATA_H   (0x5C)
+#define AXP2101_TS_CFG_DATA_L   (0x5D)
+#define AXP2101_CHG_CFG         (0x60)
+#define AXP2101_IPRECHG_CFG     (0x61)
+#define AXP2101_ICC_CFG         (0x62)
+#define AXP2101_ITERM_CFG       (0x63)
+#define AXP2101_CHG_V_CFG       (0x64)
+#define AXP2101_TREGU_THLD      (0x65)
+#define AXP2101_CHG_FREQ        (0x66)
+#define AXP2101_CHG_TMR_CFG     (0x67)
+#define AXP2101_BAT_DET         (0x68)
+#define AXP2101_CHGLED_CFG      (0x69)
+#define AXP2101_BTN_CHG_CFG     (0x6A)
+#define AXP2101_SW_TEST_CFG     (0x7B)
+#define AXP2101_DCDC_CFG0       (0x80)
+#define AXP2101_DCDC_CFG1       (0x81)
+#define AXP2101_DCDC1_CFG       (0x82)
+#define AXP2101_DCDC2_CFG       (0x83)
+#define AXP2101_DCDC3_CFG       (0x84)
+#define AXP2101_DCDC4_CFG       (0x85)
+#define AXP2101_DCDC5_CFG       (0x86)
+#define AXP2101_DCDC_OC_CFG     (0x87)
+#define AXP2101_LDO_EN_CFG0     (0x90)
+#define AXP2101_LDO_EN_CFG1     (0x91)
+#define AXP2101_ALDO1_CFG       (0x92)
+#define AXP2101_ALDO2_CFG       (0x93)
+#define AXP2101_ALDO3_CFG       (0x94)
+#define AXP2101_ALDO4_CFG       (0x95)
+#define AXP2101_BLDO1_CFG       (0x96)
+#define AXP2101_BLDO2_CFG       (0x97)
+#define AXP2101_CPUSLD_CFG      (0x98)
+#define AXP2101_DLDO1_CFG       (0x99)
+#define AXP2101_DLDO2_CFG       (0x9A)
+#define AXP2101_IP_VER          (0xA0)
+#define AXP2101_BROM            (0xA1)
+#define AXP2101_CONFIG          (0xA2)
+#define AXP2101_TEMPERATURE     (0xA3)
+#define AXP2101_SOC             (0xA4)
+#define AXP2101_TIME2EMPTY_H    (0xA6)
+#define AXP2101_TIME2EMPTY_L    (0xA7)
+#define AXP2101_TIME2FULL_H     (0xA8)
+#define AXP2101_TIME2FULL_L     (0xA9)
+#define AXP2101_FW_VERSION      (0xAB)
+#define AXP2101_INT0_FLAG       (0xAC)
+#define AXP2101_COUTER_PERIOD   (0xAD)
+#define AXP2101_BG_TRIM         (0xAE)
+#define AXP2101_OSC_TRIM        (0xAF)
+#define AXP2101_FG_ADDR         (0xB0)
+#define AXP2101_FG_DATA_H       (0xB2)
+#define AXP2101_FG_DATA_L       (0xB3)
+#define AXP2101_RAM_MBIST       (0xB4)
+#define AXP2101_ROM_TEST        (0xB5)
+#define AXP2101_ROM_TEST_RT0    (0xB6)
+#define AXP2101_ROM_TEST_RT1    (0xB7)
+#define AXP2101_ROM_TEST_RT2    (0xB8)
+#define AXP2101_ROM_TEST_RT3    (0xB9)
+#define AXP2101_WD_CLR_DIS      (0xBA)
+
+#define AXP2101_BUFFERC         (0xff)
+#define AXP2101_COMM_CFG0       (0x100)
+
+/* For AXP15 */
+#define AXP15_STATUS              (0x00)
+#define AXP15_MODE_CHGSTATUS      (0x01)
+#define AXP15_OTG_STATUS          (0x02)
+#define AXP15_IC_TYPE             (0x03)
+#define AXP15_DATA_BUFFER1        (0x04)
+#define AXP15_DATA_BUFFER2        (0x05)
+#define AXP15_DATA_BUFFER3        (0x06)
+#define AXP15_DATA_BUFFER4        (0x07)
+#define AXP15_DATA_BUFFER5        (0x08)
+#define AXP15_DATA_BUFFER6        (0x09)
+#define AXP15_DATA_BUFFER7        (0x0A)
+#define AXP15_DATA_BUFFER8        (0x0B)
+#define AXP15_DATA_BUFFER9        (0x0C)
+#define AXP15_DATA_BUFFERA        (0x0D)
+#define AXP15_DATA_BUFFERB        (0x0E)
+#define AXP15_DATA_BUFFERC        (0x0F)
+#define AXP15_LDO3456_DC1234_CTL  (0x12)
+#define AXP15_LDO0OUT_VOL         (0x15)
+#define AXP15_DC2OUT_VOL          (0x23)
+#define AXP15_DCDC2_DVM_CTRL      (0x25)
+#define AXP15_DC1OUT_VOL          (0x26)
+#define AXP15_DC3OUT_VOL          (0x27)
+#define AXP15_LDO34OUT_VOL        (0x28)
+#define AXP15_LDO5OUT_VOL         (0x29)
+#define AXP15_LDO6OUT_VOL         (0x2A)
+#define AXP15_DC4OUT_VOL          (0x2B)
+#define AXP15_IPS_SET             (0x30)
+#define AXP15_VOFF_SET            (0x31)
+#define AXP15_OFF_CTL             (0x32)
+#define AXP15_CHARGE1             (0x33)
+#define AXP15_CHARGE2             (0x34)
+#define AXP15_BACKUP_CHG          (0x35)
+#define AXP15_POK_SET             (0x36)
+#define AXP15_DCDC_FREQSET        (0x37)
+#define AXP15_VLTF_CHGSET         (0x38)
+#define AXP15_VHTF_CHGSET         (0x39)
+#define AXP15_APS_WARNING1        (0x3A)
+#define AXP15_APS_WARNING2        (0x3B)
+#define AXP15_TLTF_DISCHGSET      (0x3C)
+#define AXP15_THTF_DISCHGSET      (0x3D)
+#define AXP15_INTEN1              (0x40)
+#define AXP15_INTEN2              (0x41)
+#define AXP15_INTEN3              (0x42)
+#define AXP15_INTSTS1             (0x48)
+#define AXP15_INTSTS2             (0x49)
+#define AXP15_INTSTS3             (0x4A)
+#define AXP15_DCDC_MODESET        (0x80)
+#define AXP15_ADC_EN1             (0x82)
+#define AXP15_ADC_EN2             (0x83)
+#define AXP15_ADC_SPEED           (0x84)
+#define AXP15_ADC_INPUTRANGE      (0x85)
+#define AXP15_ADC_IRQ_RETFSET     (0x86)
+#define AXP15_ADC_IRQ_FETFSET     (0x87)
+#define AXP15_TIMER_CTL           (0x8A)
+#define AXP15_VBUS_DET_SRP        (0x8B)
+#define AXP15_HOTOVER_CTL         (0x8F)
+#define AXP15_GPIO0_CTL           (0x90)
+#define AXP15_GPIO1_CTL           (0x91)
+#define AXP15_GPIO2_CTL           (0x92)
+#define AXP15_GPIO3_CTL           (0x93)
+#define AXP15_GPIO012_SIGNAL      (0x94)
+#define AXP15_GPIO0_VOL           (0x96)
+#define AXP15_GPIO0123_SIGNAL     (0x97)
+
+/* For AXP1530 */
+#define AXP1530_ON_INDICATE          (0x00)
+#define AXP1530_OFF_INDICATE         (0x01)
+#define AXP1530_IC_TYPE              (0x03)
+#define AXP1530_OUTPUT_CONTROL       (0x10)
+#define AXP1530_DCDC_DVM_PWM         (0x12)
+#define AXP1530_DCDC1_CONRTOL        (0x13)
+#define AXP1530_DCDC2_CONRTOL        (0x14)
+#define AXP1530_DCDC3_CONRTOL        (0x15)
+#define AXP1530_ALDO1_CONRTOL        (0x16)
+#define AXP1530_DLDO1_CONRTOL        (0x17)
+#define AXP1530_POWER_STATUS         (0x1A)
+#define AXP1530_PWROK_SET            (0x1B)
+#define AXP1530_WAKEUP_CONRTOL       (0x1C)
+#define AXP1530_OUTOUT_MONITOR       (0x1D)
+#define AXP1530_POK_CONRTOL          (0x1E)
+#define AXP1530_IRQ_ENABLE1          (0x20)
+#define AXP1530_IRQ_STATUS1          (0x21)
+#define AXP1530_LOCK_REG71           (0x70)
+#define AXP1530_EPROM_SET            (0x71)
+#define AXP1530_DCDC12_DEFAULT       (0x80)
+#define AXP1530_DCDC3_A1D1_DEFAULT   (0x81)
+#define AXP1530_STARTUP_SEQ          (0x82)
+#define AXP1530_STARTUP_RTCLDO       (0x83)
+#define AXP1530_BIAS_I2C_ADDR        (0x84)
+#define AXP1530_VREF_VRPN            (0x85)
+#define AXP1530_VREF_VOL             (0x86)
+#define AXP1530_FREQUENCY            (0x87)
+
+/* For AXP858 */
+#define AXP858_ON_INDICATE          (0x00)
+#define AXP858_OFF_INDICATE         (0x01)
+#define AXP858_IC_TYPE              (0x03)
+#define AXP858_DATA_BUFFER1        (0x04)
+#define AXP858_DATA_BUFFER2        (0x05)
+#define AXP858_DATA_BUFFER3        (0x06)
+#define AXP858_DATA_BUFFER4        (0x07)
+
+#define AXP858_OUTPUT_CONTROL1       (0x10)
+#define AXP858_OUTPUT_CONTROL2      (0x11)
+#define AXP858_OUTPUT_CONTROL3        (0x12)
+#define AXP858_DCDC1_CONTROL        (0x13)
+#define AXP858_DCDC2_CONTROL        (0x14)
+#define AXP858_DCDC3_CONTROL        (0x15)
+#define AXP858_DCDC4_CONTROL        (0x16)
+#define AXP858_DCDC5_CONTROL         (0x17)
+#define AXP858_DCDC6_CONTROL            (0x18)
+#define AXP858_ALDO1_CONTROL       (0x19)
+#define AXP858_DCDC_MODE1       (0x1A)
+#define AXP858_DCDC_MODE2          (0x1B)
+#define AXP858_DCDC_MODE3          (0x1C)
+#define AXP858_DCDC_FREQUENCY          (0x1D)
+#define AXP858_OUTPUT_MONITOR           (0x1E)
+#define AXP858_IRQ_PWROK_VOFF            (0x1F)
+#define AXP858_ALDO2_CTL       (0x20)
+#define AXP858_ALDO3_CTL   (0x21)
+#define AXP858_ALDO4_CTL          (0x22)
+#define AXP858_ALDO5_CTL       (0x23)
+#define AXP858_BLDO1_CTL        (0x24)
+#define AXP858_BLDO2_CTL            (0x25)
+#define AXP858_BLDO3_CTL             (0x26)
+#define AXP858_BLDO4_CTL            (0x27)
+#define AXP858_BLDO5_CTL            (0x28)
+#define AXP858_CLDO1_CTL            (0x29)
+#define AXP858_CLDO2_CTL            (0x2A)
+#define AXP858_CLDO3_GPIO1_CTL            (0x2B)
+#define AXP858_CLDO4_GPIO2_CTL            (0x2C)
+#define AXP858_CLDO4_CTL            (0x2D)
+#define AXP858_CPUSLDO_CTL            (0x2E)
+#define AXP858_WKP_CTL_OC_IRQ            (0x31)
+#define AXP858_POWER_DOWN_DIS            (0x32)
+#define AXP858_POK_SET            (0x36)
+#define AXP858_TWI_OR_RSB            (0x3E)
+#define AXP858_IRQ_EN1            (0x40)
+#define AXP858_IRQ_EN2            (0x41)
+#define AXP858_IRQ_STS1            (0x48)
+#define AXP858_IRQ_STS2            (0x49)
+#define AXP858_DIGITAL_PAT1            (0xF0)
+#define AXP858_DIGITAL_PAT2            (0xF1)
+#define AXP858_EPROM_SET            (0xF2)
+#define AXP858_VREF_TEM_SET            (0xF3)
+#define AXP858_LOCK_F0125            (0xF4)
+#define AXP858_EPROM_TUNE            (0xF5)
+#define AXP858_ADDR_EXTEN            (0xFF)
+#define AXP858_DCDC1_PWRON_DEF          (0x100)
+#define AXP858_DCDC2_DEF          (0x101)
+#define AXP858_DCDC3_DEF          (0x102)
+#define AXP858_DCDC4_DEF          (0x103)
+#define AXP858_DCDC5_DEF          (0x104)
+#define AXP858_DCDC6_DEF          (0x105)
+#define AXP858_ALDO12_DEF          (0x106)
+#define AXP858_ALDO23_DEF          (0x107)
+#define AXP858_ALDO45_DEF          (0x108)
+#define AXP858_ALDO5_BLDO1_DEF          (0x109)
+#define AXP858_BLDO12_DEF          (0x10A)
+#define AXP858_BLDO23_DEF          (0x10B)
+#define AXP858_BLDO45_DEF          (0x10C)
+#define AXP858_BLDO5_CLDO1_DEF          (0x10D)
+#define AXP858_CLDO23_DEF          (0x10E)
+#define AXP858_CLDO34_DEF          (0x10F)
+#define AXP858_START_DCDC123          (0x110)
+#define AXP858_START_DCDC456          (0x111)
+#define AXP858_START_ALDO12          (0x112)
+#define AXP858_START_ALDO345          (0x113)
+#define AXP858_START_BLDO123          (0x114)
+#define AXP858_START_BLDO45          (0x115)
+#define AXP858_START_CLDO123          (0x116)
+#define AXP858_START_CLDO34_CPUS          (0x117)
+#define AXP858_TWI_RSB_SET1          (0x118)
+#define AXP858_TWI_RSB_SET2          (0x119)
+#define AXP858_TWI_SET          (0x11A)
+#define AXP858_VREF_TC_ALDO3          (0x140)
+#define AXP858_VREF_VOL          (0x141)
+#define AXP858_INTERNAL_ALDO2          (0x142)
+#define AXP858_FREQUENCY_ALDO2          (0x143)
+
+/* For AXP803 */
+#define AXP803_STATUS              (0x00)
+#define AXP803_MODE_CHGSTATUS      (0x01)
+#define AXP803_IC_TYPE             (0x03)
+#define AXP803_BUFFER1             (0x04)
+#define AXP803_BUFFER2             (0x05)
+#define AXP803_BUFFER3             (0x06)
+#define AXP803_BUFFER4             (0x07)
+#define AXP803_BUFFER5             (0x08)
+#define AXP803_BUFFER6             (0x09)
+#define AXP803_BUFFER7             (0x0A)
+#define AXP803_BUFFER8             (0x0B)
+#define AXP803_BUFFER9             (0x0C)
+#define AXP803_BUFFERA             (0x0D)
+#define AXP803_BUFFERB             (0x0E)
+#define AXP803_BUFFERC             (0x0F)
+#define AXP803_LDO_DC_EN1          (0X10)
+#define AXP803_LDO_DC_EN2          (0X12)
+#define AXP803_LDO_DC_EN3          (0X13)
+#define AXP803_DLDO1OUT_VOL        (0x15)
+#define AXP803_DLDO2OUT_VOL        (0x16)
+#define AXP803_DLDO3OUT_VOL        (0x17)
+#define AXP803_DLDO4OUT_VOL        (0x18)
+#define AXP803_ELDO1OUT_VOL        (0x19)
+#define AXP803_ELDO2OUT_VOL        (0x1A)
+#define AXP803_ELDO3OUT_VOL        (0x1B)
+#define AXP803_FLDO1OUT_VOL        (0x1C)
+#define AXP803_FLDO2OUT_VOL        (0x1D)
+#define AXP803_DC1OUT_VOL          (0x20)
+#define AXP803_DC2OUT_VOL          (0x21)
+#define AXP803_DC3OUT_VOL          (0x22)
+#define AXP803_DC4OUT_VOL          (0x23)
+#define AXP803_DC5OUT_VOL          (0x24)
+#define AXP803_DC6OUT_VOL          (0x25)
+#define AXP803_DC7OUT_VOL          (0x26)
+#define AXP803_DCDC_DVM_CTL        (0x27)
+#define AXP803_ALDO1OUT_VOL        (0x28)
+#define AXP803_ALDO2OUT_VOL        (0x29)
+#define AXP803_ALDO3OUT_VOL        (0x2A)
+#define AXP803_BC_CTL              (0X2C)
+#define AXP803_IPS_SET             (0x30)
+#define AXP803_VOFF_SET            (0x31)
+#define AXP803_OFF_CTL             (0x32)
+#define AXP803_CHARGE1             (0x33)
+#define AXP803_CHARGE2             (0x34)
+#define AXP803_CHARGE3             (0x35)
+#define AXP803_POK_SET             (0x36)
+#define AXP803_VLTF_CHARGE         (0x38)
+#define AXP803_VHTF_CHARGE         (0x39)
+#define AXP803_CHARGE_AC_SET       (0x3A)
+#define AXP803_DCDC_FREQSET        (0x3B)
+#define AXP803_VLTF_WORK           (0x3C)
+#define AXP803_VHTF_WORK           (0x3D)
+#define AXP803_INTEN1              (0x40)
+#define AXP803_INTEN2              (0x41)
+#define AXP803_INTEN3              (0x42)
+#define AXP803_INTEN4              (0x43)
+#define AXP803_INTEN5              (0x44)
+#define AXP803_INTEN6              (0x45)
+#define AXP803_INTSTS1             (0x48)
+#define AXP803_INTSTS2             (0x49)
+#define AXP803_INTSTS3             (0x4A)
+#define AXP803_INTSTS4             (0x4B)
+#define AXP803_INTSTS5             (0x4C)
+#define AXP803_INTSTS6             (0x4D)
+#define AXP803_INTTEMP             (0x56)
+#define AXP803_VTS_RES             (0x58)
+#define AXP803_VBATH_RES           (0x78)
+#define AXP803_VBATL_RES           (0x79)
+#define AXP803_IBATH_REG           (0x7A)
+#define AXP803_DISIBATH_REG        (0x7C)
+#define AXP803_DCDC_MODESET        (0x80)
+#define AXP803_ADC_EN              (0x82)
+#define AXP803_ADC_SPEED_SET       (0x85)
+#define AXP803_HOTOVER_CTL         (0x8F)
+#define AXP803_GPIO0_CTL           (0x90)
+#define AXP803_GPIO0LDOOUT_VOL     (0x91)
+#define AXP803_GPIO1_CTL           (0x92)
+#define AXP803_GPIO1LDOOUT_VOL     (0x93)
+#define AXP803_GPIO01_SIGNAL       (0x94)
+#define AXP803_BAT_CHGCOULOMB3     (0xB0)
+#define AXP803_BAT_CHGCOULOMB2     (0xB1)
+#define AXP803_BAT_CHGCOULOMB1     (0xB2)
+#define AXP803_BAT_CHGCOULOMB0     (0xB3)
+#define AXP803_BAT_DISCHGCOULOMB3  (0xB4)
+#define AXP803_BAT_DISCHGCOULOMB2  (0xB5)
+#define AXP803_BAT_DISCHGCOULOMB1  (0xB6)
+#define AXP803_BAT_DISCHGCOULOMB0  (0xB7)
+#define AXP803_COULOMB_CTL         (0xB8)
+#define AXP803_CAP                 (0xB9)
+#define AXP803_RDC0                (0xBA)
+#define AXP803_RDC1                (0xBB)
+#define AXP803_OCVBATH_RES         (0xBC)
+#define AXP803_OCVBATL_RES         (0xBD)
+#define AXP803_OCVCAP              (0xC0)
+#define AXP803_BATCAP0             (0xE0)
+#define AXP803_BATCAP1             (0xE1)
+#define AXP803_COUCNT0             (0xE2)
+#define AXP803_COUCNT1             (0xE3)
+#define AXP803_OCV_PERCENT         (0xE4)
+#define AXP803_COU_PERCENT         (0xE5)
+#define AXP803_WARNING_LEVEL       (0xE6)
+#define AXP803_ADJUST_PARA         (0xE8)
+#define AXP803_ADJUST_PARA1        (0xE9)
+#define AXP803_REG_ADDR_EXT        (0xFF)
+
+/*
+ * axp2202 define
+ */
+#define AXP2202_COMM_STAT0          (0x00)
+#define AXP2202_COMM_STAT1          (0x01)
+#define AXP2202_CHIP_ID             (0x03)
+#define AXP2202_CHIP_VER            (0x04)
+#define AXP2202_BC_DECT             (0x05)
+#define AXP2202_ILIM_TYPE           (0x06)
+#define AXP2202_COMM_FAULT          (0x08)
+#define AXP2202_ICO_CFG             (0x0a)
+#define AXP2202_CLK_EN              (0x0b)
+
+#define AXP2202_COMM_CFG            (0x10)
+#define AXP2202_BATFET_CTRL         (0x12)
+#define AXP2202_RBFET_CTRL          (0x13)
+#define AXP2202_DIE_TEMP_CFG        (0x14)
+#define AXP2202_VSYS_MIN            (0x15)
+#define AXP2202_VIMDPM_CFG          (0x16)
+#define AXP2202_IIN_LIM             (0x17)
+#define AXP2202_RESET_CFG           (0x18)
+#define AXP2202_MODULE_EN           (0x19)
+#define AXP2202_WATCHDOG_CFG        (0x1a)
+#define AXP2202_GAUGE_THLD          (0x1b)
+#define AXP2202_GPIO_CTRL           (0x1c)
+#define AXP2202_LOW_POWER_CFG       (0x1d)
+#define AXP2202_BST_CFG0            (0x1e)
+#define AXP2202_BST_CFG1            (0x1f)
+
+#define AXP2202_PWRON_STAT          (0x20)
+#define AXP2202_PWROFF_STAT         (0x21)
+#define AXP2202_PWROFF_EN           (0x22)
+#define AXP2202_DCDC_PWROFF_EN      (0x23)
+#define AXP2202_PWR_TIME_CTRL       (0x24)
+#define AXP2202_SLEEP_CFG           (0x25)
+#define AXP2202_PONLEVEL            (0x26)
+#define AXP2202_SOFT_PWROFF         (0x27)
+#define AXP2202_AUTO_SLP_MAP0       (0x28)
+#define AXP2202_AUTOSLP_MAP1        (0x29)
+#define AXP2202_AUTOSLP_MAP2        (0x2a)
+#define AXP2202_FAST_PWRON_CFG0     (0x2b)
+#define AXP2202_FAST_PWRON_CFG1     (0x2c)
+#define AXP2202_FAST_PWRON_CFG2     (0x2d)
+#define AXP2202_FAST_PWRON_CFG3     (0x2e)
+#define AXP2202_FAST_PWRON_CFG4     (0x2f)
+#define AXP2202_I2C_CFG             (0x30)
+#define AXP2202_BUS_MODE_SEL        (0x3e)
+
+#define AXP2202_IRQ_EN0             (0x40)
+#define AXP2202_IRQ_EN1             (0x41)
+#define AXP2202_IRQ_EN2             (0x42)
+#define AXP2202_IRQ_EN3             (0x43)
+#define AXP2202_IRQ_EN4             (0x44)
+#define AXP2202_IRQ0                (0x48)
+#define AXP2202_IRQ1                (0x49)
+#define AXP2202_IRQ2                (0x4a)
+#define AXP2202_IRQ3                (0x4b)
+#define AXP2202_IRQ4                (0x4c)
+
+#define AXP2202_TS_CFG              (0x50)
+#define AXP2202_TS_HYSL2H           (0x52)
+#define AXP2202_TS_HYSH2L           (0x53)
+#define AXP2202_VLTF_CHG            (0x54)
+#define AXP2202_VHTF_CHG            (0x55)
+#define AXP2202_VLTF_WORK           (0x56)
+#define AXP2202_VHTF_WORK           (0x57)
+#define AXP2202_JEITA_CFG           (0x58)
+#define AXP2202_JEITA_CV_CFG        (0x59)
+#define AXP2202_JEITA_COOL          (0x5a)
+#define AXP2202_JEITA_WARM          (0x5b)
+#define AXP2202_TS_CFG_DATA_H       (0x5c)
+#define AXP2202_TS_CFG_DATA_L       (0x5d)
+
+#define AXP2202_RECHG_CFG           (0x60)
+#define AXP2202_IPRECHG_CFG         (0x61)
+#define AXP2202_ICC_CFG             (0x62)
+#define AXP2202_ITERM_CFG           (0x63)
+#define AXP2202_VTERM_CFG           (0x64)
+#define AXP2202_TREGU_THLD          (0x65)
+#define AXP2202_CHG_FREQ            (0x66)
+#define AXP2202_CHG_TMR_CFG         (0x67)
+#define AXP2202_BAT_DET             (0x68)
+#define AXP2202_IR_COMP             (0x69)
+#define AXP2202_BTN_CHG_CFG         (0x6a)
+#define AXP2202_SW_TEST_CFG         (0x6b)
+
+#define AXP2202_CHGLED_CFG          (0x70)
+#define AXP2202_LOW_NUM             (0x72)
+#define AXP2202_HIGH_NUM            (0x73)
+#define AXP2202_TRANS_NUM           (0x74)
+#define AXP2202_DUTY_STEP           (0x76)
+#define AXP2202_DUTY_MIN            (0x77)
+#define AXP2202_PWN_PERIOD          (0x78)
+
+#define AXP2202_DCDC_CFG0           (0x80)
+#define AXP2202_DCDC_CFG1           (0x81)
+#define AXP2202_DCDC_CFG2           (0x82)
+#define AXP2202_DCDC1_CFG           (0x83)
+#define AXP2202_DCDC2_CFG           (0x84)
+#define AXP2202_DCDC3_CFG           (0x85)
+#define AXP2202_DCDC4_CFG           (0x86)
+#define AXP2202_DVM_STAT            (0x87)
+#define AXP2202_DCDC_OC_CFG         (0x88)
+#define AXP2202_DCDC_VDSDT_ADJ      (0x89)
+
+#define AXP2202_LDO_EN_CFG0         (0x90)
+#define AXP2202_LDO_EN_CFG1         (0x91)
+#define AXP2202_ALDO1_CFG           (0x93)
+#define AXP2202_ALDO2_CFG           (0x94)
+#define AXP2202_ALDO3_CFG           (0x95)
+#define AXP2202_ALDO4_CFG           (0x96)
+#define AXP2202_BLDO1_CFG           (0x97)
+#define AXP2202_BLDO2_CFG           (0x98)
+#define AXP2202_BLDO3_CFG           (0x99)
+#define AXP2202_BLDO4_CFG           (0x9a)
+#define AXP2202_CLDO1_CFG           (0x9b)
+#define AXP2202_CLDO2_CFG           (0x9c)
+#define AXP2202_CLDO3_CFG           (0x9d)
+#define AXP2202_CLDO4_CFG           (0x9e)
+#define AXP2202_CPUSLDO_CFG         (0x9f)
+
+#define AXP2202_GAUGE_IP_VER        (0xa0)
+#define AXP2202_GAUGE_BROM          (0xa1)
+#define AXP2202_GAUGE_CONFIG        (0xa2)
+#define AXP2202_GAUGE_TEMPERATURE   (0xa3)
+#define AXP2202_GAUGE_SOC           (0xa4)
+#define AXP2202_GAUGE_TIME2EMPTY_H  (0xa6)
+#define AXP2202_GAUGE_TIME2EMPTY_L  (0xa7)
+#define AXP2202_GAUGE_TIME2FULL_H   (0xa8)
+#define AXP2202_GAUGE_TIME2FULL_L   (0xa9)
+#define AXP2202_GAUGE_FW_VERSION    (0xab)
+#define AXP2202_GAUGE_INT0_FLAG     (0xac)
+#define AXP2202_GAUGE_COUTER_PERIOD (0xad)
+#define AXP2202_GAUGE_FG_ADDR       (0xb0)
+#define AXP2202_GAUGE_FG_DATA_H     (0xb2)
+#define AXP2202_GAUGE_FG_DATA_L     (0xb3)
+#define AXP2202_GAUGE_RAM_MBIST     (0xb4)
+#define AXP2202_GAUGE_ROM_TEST      (0xb5)
+#define AXP2202_GAUGE_ROM_TEST_RT0  (0xb6)
+#define AXP2202_GAUGE_ROM_TEST_RT1  (0xb7)
+#define AXP2202_GAUGE_ROM_TEST_RT2  (0xb8)
+#define AXP2202_GAUGE_ROM_TEST_RT3  (0xb9)
+#define AXP2202_GAUGE_WD_CLR_DIS    (0xba)
+
+#define AXP2202_ADC_CH_EN0          (0xc0)
+#define AXP2202_ADC_CH_EN1          (0xc1)
+#define AXP2202_ADC_CH_EN2          (0xc2)
+#define AXP2202_ADC_CH_EN3          (0xc3)
+#define AXP2202_VBAT_H              (0xc4)
+#define AXP2202_VBAT_L              (0xc5)
+#define AXP2202_VBUS_H              (0xc6)
+#define AXP2202_VBUS_L              (0xc7)
+#define AXP2202_VSYS_H              (0xc8)
+#define AXP2202_VSYS_L              (0xc9)
+#define AXP2202_ICHG_H              (0xca)
+#define AXP2202_ICHG_L              (0xcb)
+#define AXP2202_CH_DBG_SEL          (0xcc)
+#define AXP2202_ADC_DATA_SEL        (0xcd)
+#define AXP2202_ADC_DATA_H          (0xce)
+#define AXP2202_ADC_DATA_L          (0xcf)
+
+#define AXP2202_BC_CFG0             (0xd0)
+#define AXP2202_BC_CFG1             (0xd1)
+#define AXP2202_BC_CFG2             (0xd2)
+#define AXP2202_BC_CFG3             (0xd3)
+
+#define AXP2202_CC_VERSION          (0xe0)
+#define AXP2202_CC_GLB_CTRL         (0xe1)
+#define AXP2202_CC_LP_CTRL          (0xe2)
+#define AXP2202_CC_MODE_CTRL        (0xe3)
+#define AXP2202_CC_TGL_CTRL0        (0xe4)
+#define AXP2202_CC_TGL_CTRL1        (0xe5)
+#define AXP2202_CC_ANA_CTRL         (0xe6)
+#define AXP2202_CC_STAT0            (0xe7)
+#define AXP2202_CC_STAT1            (0xe8)
+#define AXP2202_CC_STAT2            (0xe9)
+#define AXP2202_CC_STAT3            (0xea)
+#define AXP2202_CC_STAT4            (0xeb)
+#define AXP2202_CC_ANA_STAT0        (0xec)
+#define AXP2202_CC_ANA_STAT1        (0xed)
+#define AXP2202_CC_ANA_STAT2        (0xee)
+
+#define AXP2202_EFUS_OP_CFG         (0xf0)
+#define AXP2202_EFREG_CTRL          (0xf1)
+#define AXP2202_TWI_ADDR_EXT        (0xff)
+/*
+ * end of define axp2202
+ */
+
+/* For axp2585 */
+#define AXP2585_STATUS              (0x00)
+#define AXP2585_IC_TYPE             (0x03)
+#define AXP2585_ILIMIT              (0x10)
+#define AXP2585_RBFET_SET           (0x11)
+#define AXP2585_POK_SET             (0x15)
+#define AXP2585_GPIO1_CTL           (0x18)
+#define AXP2585_GPIO2_CTL           (0x19)
+#define AXP2585_GPIO1_SIGNAL        (0x1A)
+#define AXP2585_CC_EN               (0x22)
+#define AXP2585_ADC_EN              (0x24)
+#define AXP2585_OFF_CTL             (0x28)
+#define AXP2585_CC_LOW_POWER_CTRL   (0x32)
+#define AXP2585_CC_MODE_CTRL        (0x33)
+#define AXP2585_CC_STATUS0          (0x37)
+#define AXP2585_INTEN1              (0x40)
+#define AXP2585_INTEN2              (0x41)
+#define AXP2585_INTEN3              (0x42)
+#define AXP2585_INTEN4              (0x43)
+#define AXP2585_INTEN5              (0x44)
+#define AXP2585_INTEN6              (0x45)
+#define AXP2585_INTSTS1             (0x48)
+#define AXP2585_INTSTS2             (0x49)
+#define AXP2585_INTSTS3             (0x4A)
+#define AXP2585_INTSTS4             (0x4B)
+#define AXP2585_INTSTS5             (0x4C)
+#define AXP2585_INTSTS6             (0x4D)
+#define AXP2585_VBATH_REG           (0x78)
+#define AXP2585_IBATH_REG           (0x7A)
+#define AXP2585_DISIBATH_REG        (0x7c)
+#define AXP2585_ADC_CONTROL         (0x80)
+#define AXP2585_TS_PIN_CONTROL      (0x81)
+#define AXP2585_VLTF_CHARGE         (0x84)
+#define AXP2585_VHTF_CHARGE         (0x85)
+#define AXP2585_VLTF_WORK           (0x86)
+#define AXP2585_VHTF_WORK           (0x87)
+#define AXP2585_ICC_CFG             (0x8B)
+#define AXP2585_CHARGE_CONTROL2     (0x8C)
+#define AXP2585_TIMER2_SET          (0x8E)
+#define AXP2585_COULOMB_CTL         (0xB8)
+#define AXP2585_CAP                 (0xB9)
+#define AXP2585_RDC0                (0xBA)
+#define AXP2585_RDC1               (0xBB)
+#define AXP2585_BATCAP0             (0xE0)
+#define AXP2585_BATCAP1             (0xE1)
+#define AXP2585_WARNING_LEVEL       (0xE6)
+#define AXP2585_ADJUST_PARA         (0xE8)
+#define AXP2585_ADJUST_PARA1        (0xE9)
+#define AXP2585_ADDR_EXTENSION      (0xFF)
+
+/* Regulators IDs */
+enum {
+	AXP152_DCDC1 = 0,
+	AXP152_DCDC2,
+	AXP152_DCDC3,
+	AXP152_DCDC4,
+	AXP152_ALDO1,
+	AXP152_ALDO2,
+	AXP152_DLDO1,
+	AXP152_DLDO2,
+	AXP152_LDO0,
+	AXP152_GPIO2_LDO,
+	AXP152_RTC13,
+	AXP152_RTC18,
+	AXP152_REG_ID_MAX,
+};
+
+enum {
+	AXP20X_LDO1 = 0,
+	AXP20X_LDO2,
+	AXP20X_LDO3,
+	AXP20X_LDO4,
+	AXP20X_LDO5,
+	AXP20X_DCDC2,
+	AXP20X_DCDC3,
+	AXP20X_REG_ID_MAX,
+};
+
+enum {
+	AXP22X_DCDC1 = 0,
+	AXP22X_DCDC2,
+	AXP22X_DCDC3,
+	AXP22X_DCDC4,
+	AXP22X_DCDC5,
+	AXP22X_DC1SW,
+	AXP22X_DC5LDO,
+	AXP22X_ALDO1,
+	AXP22X_ALDO2,
+	AXP22X_ALDO3,
+	AXP22X_ELDO1,
+	AXP22X_ELDO2,
+	AXP22X_ELDO3,
+	AXP22X_DLDO1,
+	AXP22X_DLDO2,
+	AXP22X_DLDO3,
+	AXP22X_DLDO4,
+	AXP22X_RTC_LDO,
+	AXP22X_LDO_IO0,
+	AXP22X_LDO_IO1,
+	AXP22X_REG_ID_MAX,
+};
+
+enum {
+	AXP806_DCDCA = 0,
+	AXP806_DCDCB,
+	AXP806_DCDCC,
+	AXP806_DCDCD,
+	AXP806_DCDCE,
+	AXP806_ALDO1,
+	AXP806_ALDO2,
+	AXP806_ALDO3,
+	AXP806_BLDO1,
+	AXP806_BLDO2,
+	AXP806_BLDO3,
+	AXP806_BLDO4,
+	AXP806_CLDO1,
+	AXP806_CLDO2,
+	AXP806_CLDO3,
+	AXP806_SW,
+	AXP806_REG_ID_MAX,
+};
+
+enum {
+	AXP809_DCDC1 = 0,
+	AXP809_DCDC2,
+	AXP809_DCDC3,
+	AXP809_DCDC4,
+	AXP809_DCDC5,
+	AXP809_DC1SW,
+	AXP809_DC5LDO,
+	AXP809_ALDO1,
+	AXP809_ALDO2,
+	AXP809_ALDO3,
+	AXP809_ELDO1,
+	AXP809_ELDO2,
+	AXP809_ELDO3,
+	AXP809_DLDO1,
+	AXP809_DLDO2,
+	AXP809_RTC_LDO,
+	AXP809_LDO_IO0,
+	AXP809_LDO_IO1,
+	AXP809_SW,
+	AXP809_REG_ID_MAX,
+};
+
+enum {
+	AXP2101_DCDC1 = 0,
+	AXP2101_DCDC2,
+	AXP2101_DCDC3,
+	AXP2101_DCDC4,
+	AXP2101_DCDC5,
+	AXP2101_LDO1,  /* RTCLDO */
+	AXP2101_LDO2,  /* RTCLDO1 */
+	AXP2101_LDO3,  /* ALDO1 */
+	AXP2101_LDO4,  /* ALDO2 */
+	AXP2101_LDO5,  /* ALDO3 */
+	AXP2101_LDO6,  /* ALDO4 */
+	AXP2101_LDO7,  /* BLDO1 */
+	AXP2101_LDO8,  /* BLDO2 */
+	AXP2101_LDO9,  /* DLDO1 */
+	AXP2101_LDO10, /* DLDO2 */
+	AXP2101_LDO11, /* CPULDOS */
+	AXP2101_REG_ID_MAX,
+};
+
+enum {
+	AXP15_DCDC1 = 0,
+	AXP15_DCDC2,
+	AXP15_DCDC3,
+	AXP15_DCDC4,
+	AXP15_DCDC5,
+	AXP15_LDO1,  /* RTCLDO */
+	AXP15_LDO2,  /* RTCLDO1 */
+	AXP15_LDO3,  /* ALDO1 */
+	AXP15_LDO4,  /* ALDO2 */
+	AXP15_LDO5,  /* ALDO3 */
+	AXP15_LDO6,  /* ALDO4 */
+	AXP15_LDO7,  /* BLDO1 */
+	AXP15_REG_ID_MAX,
+};
+
+enum {
+	AXP1530_DCDC1 = 0,
+	AXP1530_DCDC2,
+	AXP1530_DCDC3,
+	AXP1530_LDO1,  /* RTCLDO */
+	AXP1530_LDO2,  /* RTCLDO1 */
+	AXP1530_REG_ID_MAX,
+};
+
+enum {
+	AXP858_DCDC1 = 0,
+	AXP858_DCDC2,
+	AXP858_DCDC3,
+	AXP858_DCDC4,
+	AXP858_DCDC5,
+	AXP858_DCDC6,
+	AXP858_ALDO1,
+	AXP858_ALDO2,
+	AXP858_ALDO3,
+	AXP858_ALDO4,
+	AXP858_ALDO5,
+	AXP858_BLDO1,
+	AXP858_BLDO2,
+	AXP858_BLDO3,
+	AXP858_BLDO4,
+	AXP858_BLDO5,
+	AXP858_CLDO1,
+	AXP858_CLDO2,
+	AXP858_CLDO3,
+	AXP858_CLDO4,
+	AXP858_CPUSLDO,
+	AXP858_DC1SW,
+	AXP858_REG_ID_MAX,
+};
+
+enum {
+	AXP803_DCDC1 = 0,
+	AXP803_DCDC2,
+	AXP803_DCDC3,
+	AXP803_DCDC4,
+	AXP803_DCDC5,
+	AXP803_DCDC6,
+	AXP803_DCDC7,
+	AXP803_RTCLDO,
+	AXP803_ALDO1,
+	AXP803_ALDO2,
+	AXP803_ALDO3,
+	AXP803_DLDO1,
+	AXP803_DLDO2,
+	AXP803_DLDO3,
+	AXP803_DLDO4,
+	AXP803_ELDO1,
+	AXP803_ELDO2,
+	AXP803_ELDO3,
+	AXP803_FLDO1,
+	AXP803_FLDO2,
+	AXP803_LDOIO0,
+	AXP803_LDOIO1,
+	AXP803_DC1SW,
+	AXP803_REG_ID_MAX,
+};
+
+enum {
+	AXP2585_REG_ID_MAX = 0,
+};
+
+/* IRQs */
+enum {
+	AXP152_IRQ_LDO0IN_CONNECT = 1,
+	AXP152_IRQ_LDO0IN_REMOVAL,
+	AXP152_IRQ_ALDO0IN_CONNECT,
+	AXP152_IRQ_ALDO0IN_REMOVAL,
+	AXP152_IRQ_DCDC1_V_LOW,
+	AXP152_IRQ_DCDC2_V_LOW,
+	AXP152_IRQ_DCDC3_V_LOW,
+	AXP152_IRQ_DCDC4_V_LOW,
+	AXP152_IRQ_PEK_SHORT,
+	AXP152_IRQ_PEK_LONG,
+	AXP152_IRQ_TIMER,
+	AXP152_IRQ_PEK_RIS_EDGE,
+	AXP152_IRQ_PEK_FAL_EDGE,
+	AXP152_IRQ_GPIO3_INPUT,
+	AXP152_IRQ_GPIO2_INPUT,
+	AXP152_IRQ_GPIO1_INPUT,
+	AXP152_IRQ_GPIO0_INPUT,
+};
+
+enum {
+	AXP20X_IRQ_ACIN_OVER_V = 1,
+	AXP20X_IRQ_ACIN_PLUGIN,
+	AXP20X_IRQ_ACIN_REMOVAL,
+	AXP20X_IRQ_VBUS_OVER_V,
+	AXP20X_IRQ_VBUS_PLUGIN,
+	AXP20X_IRQ_VBUS_REMOVAL,
+	AXP20X_IRQ_VBUS_V_LOW,
+	AXP20X_IRQ_BATT_PLUGIN,
+	AXP20X_IRQ_BATT_REMOVAL,
+	AXP20X_IRQ_BATT_ENT_ACT_MODE,
+	AXP20X_IRQ_BATT_EXIT_ACT_MODE,
+	AXP20X_IRQ_CHARG,
+	AXP20X_IRQ_CHARG_DONE,
+	AXP20X_IRQ_BATT_TEMP_HIGH,
+	AXP20X_IRQ_BATT_TEMP_LOW,
+	AXP20X_IRQ_DIE_TEMP_HIGH,
+	AXP20X_IRQ_CHARG_I_LOW,
+	AXP20X_IRQ_DCDC1_V_LONG,
+	AXP20X_IRQ_DCDC2_V_LONG,
+	AXP20X_IRQ_DCDC3_V_LONG,
+	AXP20X_IRQ_PEK_SHORT = 22,
+	AXP20X_IRQ_PEK_LONG,
+	AXP20X_IRQ_N_OE_PWR_ON,
+	AXP20X_IRQ_N_OE_PWR_OFF,
+	AXP20X_IRQ_VBUS_VALID,
+	AXP20X_IRQ_VBUS_NOT_VALID,
+	AXP20X_IRQ_VBUS_SESS_VALID,
+	AXP20X_IRQ_VBUS_SESS_END,
+	AXP20X_IRQ_LOW_PWR_LVL1,
+	AXP20X_IRQ_LOW_PWR_LVL2,
+	AXP20X_IRQ_TIMER,
+	AXP20X_IRQ_PEK_RIS_EDGE,
+	AXP20X_IRQ_PEK_FAL_EDGE,
+	AXP20X_IRQ_GPIO3_INPUT,
+	AXP20X_IRQ_GPIO2_INPUT,
+	AXP20X_IRQ_GPIO1_INPUT,
+	AXP20X_IRQ_GPIO0_INPUT,
+};
+
+enum axp22x_irqs {
+	AXP22X_IRQ_ACIN_OVER_V = 1,
+	AXP22X_IRQ_ACIN_PLUGIN,
+	AXP22X_IRQ_ACIN_REMOVAL,
+	AXP22X_IRQ_VBUS_OVER_V,
+	AXP22X_IRQ_VBUS_PLUGIN,
+	AXP22X_IRQ_VBUS_REMOVAL,
+	AXP22X_IRQ_VBUS_V_LOW,
+	AXP22X_IRQ_BATT_PLUGIN,
+	AXP22X_IRQ_BATT_REMOVAL,
+	AXP22X_IRQ_BATT_ENT_ACT_MODE,
+	AXP22X_IRQ_BATT_EXIT_ACT_MODE,
+	AXP22X_IRQ_CHARG,
+	AXP22X_IRQ_CHARG_DONE,
+	AXP22X_IRQ_BATT_TEMP_HIGH,
+	AXP22X_IRQ_BATT_TEMP_LOW,
+	AXP22X_IRQ_DIE_TEMP_HIGH,
+	AXP22X_IRQ_PEK_SHORT,
+	AXP22X_IRQ_PEK_LONG,
+	AXP22X_IRQ_LOW_PWR_LVL1,
+	AXP22X_IRQ_LOW_PWR_LVL2,
+	AXP22X_IRQ_TIMER,
+	AXP22X_IRQ_PEK_RIS_EDGE,
+	AXP22X_IRQ_PEK_FAL_EDGE,
+	AXP22X_IRQ_GPIO1_INPUT,
+	AXP22X_IRQ_GPIO0_INPUT,
+};
+
+enum axp288_irqs {
+	AXP288_IRQ_VBUS_FALL     = 2,
+	AXP288_IRQ_VBUS_RISE,
+	AXP288_IRQ_OV,
+	AXP288_IRQ_FALLING_ALT,
+	AXP288_IRQ_RISING_ALT,
+	AXP288_IRQ_OV_ALT,
+	AXP288_IRQ_DONE          = 10,
+	AXP288_IRQ_CHARGING,
+	AXP288_IRQ_SAFE_QUIT,
+	AXP288_IRQ_SAFE_ENTER,
+	AXP288_IRQ_ABSENT,
+	AXP288_IRQ_APPEND,
+	AXP288_IRQ_QWBTU,
+	AXP288_IRQ_WBTU,
+	AXP288_IRQ_QWBTO,
+	AXP288_IRQ_WBTO,
+	AXP288_IRQ_QCBTU,
+	AXP288_IRQ_CBTU,
+	AXP288_IRQ_QCBTO,
+	AXP288_IRQ_CBTO,
+	AXP288_IRQ_WL2,
+	AXP288_IRQ_WL1,
+	AXP288_IRQ_GPADC,
+	AXP288_IRQ_OT            = 31,
+	AXP288_IRQ_GPIO0,
+	AXP288_IRQ_GPIO1,
+	AXP288_IRQ_POKO,
+	AXP288_IRQ_POKL,
+	AXP288_IRQ_POKS,
+	AXP288_IRQ_POKN,
+	AXP288_IRQ_POKP,
+	AXP288_IRQ_TIMER,
+	AXP288_IRQ_MV_CHNG,
+	AXP288_IRQ_BC_USB_CHNG,
+};
+
+enum axp806_irqs {
+	AXP806_IRQ_DIE_TEMP_HIGH_LV1,
+	AXP806_IRQ_DIE_TEMP_HIGH_LV2,
+	AXP806_IRQ_DCDCA_V_LOW = 3,
+	AXP806_IRQ_DCDCB_V_LOW,
+	AXP806_IRQ_DCDCC_V_LOW,
+	AXP806_IRQ_DCDCD_V_LOW,
+	AXP806_IRQ_DCDCE_V_LOW,
+	AXP806_IRQ_PWROK_LONG,
+	AXP806_IRQ_PWROK_SHORT,
+	AXP806_IRQ_WAKEUP = 12,
+	AXP806_IRQ_PWROK_FALL,
+	AXP806_IRQ_PWROK_RISE,
+};
+
+enum axp809_irqs {
+	AXP809_IRQ_ACIN_OVER_V = 1,
+	AXP809_IRQ_ACIN_PLUGIN,
+	AXP809_IRQ_ACIN_REMOVAL,
+	AXP809_IRQ_VBUS_OVER_V,
+	AXP809_IRQ_VBUS_PLUGIN,
+	AXP809_IRQ_VBUS_REMOVAL,
+	AXP809_IRQ_VBUS_V_LOW,
+	AXP809_IRQ_BATT_PLUGIN,
+	AXP809_IRQ_BATT_REMOVAL,
+	AXP809_IRQ_BATT_ENT_ACT_MODE,
+	AXP809_IRQ_BATT_EXIT_ACT_MODE,
+	AXP809_IRQ_CHARG,
+	AXP809_IRQ_CHARG_DONE,
+	AXP809_IRQ_BATT_CHG_TEMP_HIGH,
+	AXP809_IRQ_BATT_CHG_TEMP_HIGH_END,
+	AXP809_IRQ_BATT_CHG_TEMP_LOW,
+	AXP809_IRQ_BATT_CHG_TEMP_LOW_END,
+	AXP809_IRQ_BATT_ACT_TEMP_HIGH,
+	AXP809_IRQ_BATT_ACT_TEMP_HIGH_END,
+	AXP809_IRQ_BATT_ACT_TEMP_LOW,
+	AXP809_IRQ_BATT_ACT_TEMP_LOW_END,
+	AXP809_IRQ_DIE_TEMP_HIGH,
+	AXP809_IRQ_LOW_PWR_LVL1,
+	AXP809_IRQ_LOW_PWR_LVL2,
+	AXP809_IRQ_TIMER,
+	AXP809_IRQ_PEK_RIS_EDGE,
+	AXP809_IRQ_PEK_FAL_EDGE,
+	AXP809_IRQ_PEK_SHORT,
+	AXP809_IRQ_PEK_LONG,
+	AXP809_IRQ_PEK_OVER_OFF,
+	AXP809_IRQ_GPIO1_INPUT,
+	AXP809_IRQ_GPIO0_INPUT,
+};
+
+enum axp2101_irqs {
+	/* irq0 */
+	AXP2101_IRQ_BWUT,
+	AXP2101_IRQ_BWOT,
+	AXP2101_IRQ_BCUT,
+	AXP2101_IRQ_BCOT,
+	AXP2101_IRQ_NEWSOC,
+	AXP2101_IRQ_GWDT,
+	AXP2101_IRQ_SOCWL1,
+	AXP2101_IRQ_SOCWL2,
+	/* irq1 */
+	AXP2101_IRQ_PONP,
+	AXP2101_IRQ_PONN,
+	AXP2101_IRQ_PONL,
+	AXP2101_IRQ_PONS,
+	AXP2101_IRQ_BREMOV,
+	AXP2101_IRQ_BINSERT,
+	AXP2101_IRQ_VREMOV,
+	AXP2101_IRQ_VINSET,
+	/* irq2 */
+	AXP2101_IRQ_BOVP,
+	AXP2101_IRQ_CHGTE,
+	AXP2101_IRQ_DOTL1,
+	AXP2101_IRQ_CHGST,
+	AXP2101_IRQ_CHGDN,
+	AXP2101_IRQ_BOCP,
+	AXP2101_IRQ_LDOOC,
+	AXP2101_IRQ_WDEXP,
+};
+
+enum axp15_irqs {
+	/* irq0 */
+	AXP15_IRQ_ALDOIN_H2L = 2,
+	AXP15_IRQ_ALDOIN_L2H,
+	AXP15_IRQ_LDO0IN_H2L = 5,
+	AXP15_IRQ_LDO0IN_L2H,
+	/* irq1 */
+	AXP15_IRQ_PEKLO = 8,
+	AXP15_IRQ_PEKSH,
+	AXP15_IRQ_DCDC4_V_LOW,
+	AXP15_IRQ_DCDC3_V_LOW,
+	AXP15_IRQ_DCDC2_V_LOW,
+	AXP15_IRQ_DCDC1_V_LOW,
+
+	/* irq2 */
+	AXP15_IRQ_GPIO0 = 16,
+	AXP15_IRQ_GPIO1,
+	AXP15_IRQ_GPIO2,
+	AXP15_IRQ_GPIO3,
+	AXP15_IRQ_PEKFE = 21,
+	AXP15_IRQ_PEKRE,
+	AXP15_IRQ_EVENT_TIMEOUT,
+};
+
+enum axp1530_irqs {
+	/* irq0 */
+	AXP1530_IRQ_TEMP_OVER,
+	AXP1530_IRQ_DCDC2_UNDER = 2,
+	AXP1530_IRQ_DCDC3_UNDER,
+	AXP1530_IRQ_POKLIRQ_EN,
+	AXP1530_IRQ_POKSIRQ_EN,
+	AXP1530_IRQ_KEY_L2H_EN,
+	AXP1530_IRQ_KEY_H2L_EN,
+};
+
+enum axp858_irqs {
+	/* irq0 */
+	AXP858_IRQ_TEMP_OVER1 = 0,
+	AXP858_IRQ_TEMP_OVER2,
+	AXP858_IRQ_DCDC1_UNDER,
+	AXP858_IRQ_DCDC2_UNDER,
+	AXP858_IRQ_DCDC3_UNDER,
+	AXP858_IRQ_DCDC4_UNDER,
+	AXP858_IRQ_DCDC5_UNDER,
+	AXP858_IRQ_DCDC6_UNDER,
+	/* irq1 */
+	AXP858_IRQ_POKLIRQ_EN,
+	AXP858_IRQ_POKSIRQ_EN,
+	AXP858_IRQ_GPIO1_EN,
+	AXP858_IRQ_POKNIRQ_EN,
+	AXP858_IRQ_POKPIRQ_EN,
+	AXP858_IRQ_GPIO2_EN,
+	AXP858_IRQ_DCDC2_CUR_OVER,
+	AXP858_IRQ_DCDC3_CUR_OVER,
+};
+
+enum axp803_irqs {
+	/* irq0 */
+	AXP803_IRQ_USBRE = 2,
+	AXP803_IRQ_USBIN,
+	AXP803_IRQ_USBOV,
+	AXP803_IRQ_ACRE,
+	AXP803_IRQ_ACIN,
+	AXP803_IRQ_ACOV,
+	/* irq1 */
+	AXP803_IRQ_CHAOV = 10,
+	AXP803_IRQ_CHAST,
+	AXP803_IRQ_BATATOU,
+	AXP803_IRQ_BATATIN,
+	AXP803_IRQ_BATRE,
+	AXP803_IRQ_BATIN,
+	/* irq2 */
+	AXP803_IRQ_QBATINWORK,
+	AXP803_IRQ_BATINWORK,
+	AXP803_IRQ_QBATOVWORK,
+	AXP803_IRQ_BATOVWORK,
+	AXP803_IRQ_QBATINCHG,
+	AXP803_IRQ_BATINCHG,
+	AXP803_IRQ_QBATOVCHG,
+	AXP803_IRQ_BATOVCHG,
+	/* irq3 */
+	AXP803_IRQ_LOWN2,
+	AXP803_IRQ_LOWN1,
+	/* irq4 */
+	AXP803_IRQ_GPIO0 = 32,
+	AXP803_IRQ_GPIO1,
+	AXP803_IRQ_POKLO = 35,
+	AXP803_IRQ_POKSH,
+	AXP803_IRQ_PEKFE,
+	AXP803_IRQ_PEKRE,
+	AXP803_IRQ_TIMER,
+};
+
+enum {
+	AXP2202_DCDC1 = 0,
+	AXP2202_DCDC2,
+	AXP2202_DCDC3,
+	AXP2202_CPUSLDO,
+	AXP2202_ALDO1,
+	AXP2202_ALDO2,
+	AXP2202_ALDO3,
+	AXP2202_ALDO4,
+	AXP2202_BLDO1,
+	AXP2202_BLDO2,
+	AXP2202_BLDO3,
+	AXP2202_BLDO4,
+	AXP2202_CLDO1,
+	AXP2202_CLDO2,
+	AXP2202_CLDO3,
+	AXP2202_CLDO4,
+	AXP2202_REG_ID_MAX,
+	AXP2202_VBUS,
+};
+
+enum axp2202_irqs {
+	/* irq0 */
+	AXP2202_IRQ_SOCWL2,
+	AXP2202_IRQ_SOCWL1,
+	AXP2202_IRQ_GWDT,
+	AXP2202_IRQ_NEWSOC,
+	AXP2202_IRQ_BST_OV,
+	AXP2202_IRQ_VBUS_OV,
+	AXP2202_IRQ_VBUS_FAULT,
+	/* irq1 */
+	AXP2202_IRQ_VINSERT,
+	AXP2202_IRQ_VREMOVE,
+	AXP2202_IRQ_BINSERT,
+	AXP2202_IRQ_BREMOVE,
+	AXP2202_IRQ_PONS,
+	AXP2202_IRQ_PONL,
+	AXP2202_IRQ_PONN,
+	AXP2202_IRQ_PONP,
+	/* irq2 */
+	AXP2202_IRQ_WDEXP,
+	AXP2202_IRQ_LDOOC,
+	AXP2202_IRQ_BOCP,
+	AXP2202_IRQ_CHGDN,
+	AXP2202_IRQ_CHGST,
+	AXP2202_IRQ_DOTL1,
+	AXP2202_IRQ_CHGTE,
+	AXP2202_IRQ_BOVP,
+	/* irq3 */
+	AXP2202_IRQ_BC_DONE,
+	AXP2202_IRQ_BC_CHNG,
+	AXP2202_IRQ_RID_CHNG,
+	AXP2202_IRQ_BCOTQ,
+	AXP2202_IRQ_BCOT,
+	AXP2202_IRQ_BCUT,
+	AXP2202_IRQ_BWOT,
+	AXP2202_IRQ_BWUT,
+	/* irq4 */
+	AXP2202_IRQ_CREMOVE,
+	AXP2202_IRQ_CINSERT,
+	AXP2202_IRQ_TOGGLE_DONE,
+	AXP2202_IRQ_VBUS_SAFE5V,
+	AXP2202_IRQ_VBUS_SAFE0V,
+	AXP2202_IRQ_ERR_GEN,
+	AXP2202_IRQ_PWR_CHNG,
+
+};
+
+enum axp2585_irqs {
+	AXP2585_IRQ_Q_DROP2,  //7l2
+	AXP2585_IRQ_Q_DROP1,  //6l1
+	AXP2585_IRQ_Q_CHANGE,
+	AXP2585_IRQ_Q_GOOD,
+	AXP2585_IRQ_BAT_DECT,
+	AXP2585_IRQ_BOOST_OVP,
+	AXP2585_IRQ_BOOST_OCP,
+	AXP2585_IRQ_BAT_OCP,
+	AXP2585_IRQ_BCOT,       //15
+	AXP2585_IRQ_QBCOT,      //14
+	AXP2585_IRQ_BCUT,       //13
+	AXP2585_IRQ_QBCUT,
+	AXP2585_IRQ_BWOT,       //11
+	AXP2585_IRQ_QBWOT,
+	AXP2585_IRQ_BWUT,       //9
+	AXP2585_IRQ_QBWUT,
+	AXP2585_IRQ_VBUS_INSERT,  //23ac
+	AXP2585_IRQ_VBUS_REMOVE,  //22ac
+	AXP2585_IRQ_BAT_INSERT,  //21
+	AXP2585_IRQ_BAT_REMOVE,  //20
+	AXP2585_IRQ_BAT_DB2GD,
+	AXP2585_IRQ_TJ_OTP,
+	AXP2585_IRQ_BAT_SMODE,
+	AXP2585_IRQ_VBUS_OVP,
+	AXP2585_IRQ_SIRQ,
+	AXP2585_IRQ_LIRQ,
+	AXP2585_IRQ_NIRQ,       //29
+	AXP2585_IRQ_PIRQ,       //28
+	AXP2585_IRQ_GPADC_BWOT,
+	AXP2585_IRQ_GPADC_QBWOT,
+	AXP2585_IRQ_GPADC_BWUT,
+	AXP2585_IRQ_GPADC_QBWUT,
+	AXP2585_IRQ_CHGBG,     //39
+	AXP2585_IRQ_CHGDONE,   //38
+	AXP2585_IRQ_BC_OK,
+	AXP2585_IRQ_BC_CHANGE,
+	AXP2585_IRQ_RID_CHANGE,
+	AXP2585_IRQ_BAT_OVP,
+	AXP2585_IRQ_REMOVE,  //47tc
+	AXP2585_IRQ_INSERT,  //46tc
+	AXP2585_IRQ_TOGGLE_DONE,
+	AXP2585_IRQ_VBUS_SAFE5V,
+	AXP2585_IRQ_ERROR_GEN,
+	AXP2585_IRQ_POW_CHNG,
+};
+#define AXP288_TS_ADC_H		0x58
+#define AXP288_TS_ADC_L		0x59
+#define AXP288_GP_ADC_H		0x5a
+#define AXP288_GP_ADC_L		0x5b
+
+struct axp20x_dev {
+	struct device			*dev;
+	int				irq;
+	struct regmap			*regmap;
+	struct regmap_irq_chip_data	*regmap_irqc;
+	long				variant;
+	int                             nr_cells;
+	struct mfd_cell                 *cells;
+	const struct regmap_config	*regmap_cfg;
+	const struct regmap_irq_chip	*regmap_irq_chip;
+	void (*dts_parse)(struct axp20x_dev *);
+};
+
+#define BATTID_LEN				64
+#define OCV_CURVE_SIZE			32
+#define MAX_THERM_CURVE_SIZE	25
+#define PD_DEF_MIN_TEMP			0
+#define PD_DEF_MAX_TEMP			55
+
+struct axp20x_fg_pdata {
+	char battid[BATTID_LEN + 1];
+	int design_cap;
+	int min_volt;
+	int max_volt;
+	int max_temp;
+	int min_temp;
+	int cap1;
+	int cap0;
+	int rdc1;
+	int rdc0;
+	int ocv_curve[OCV_CURVE_SIZE];
+	int tcsz;
+	int thermistor_curve[MAX_THERM_CURVE_SIZE][2];
+};
+
+struct axp20x_chrg_pdata {
+	int max_cc;
+	int max_cv;
+	int def_cc;
+	int def_cv;
+};
+
+struct axp288_extcon_pdata {
+	/* GPIO pin control to switch D+/D- lines b/w PMIC and SOC */
+	struct gpio_desc *gpio_mux_cntl;
+};
+
+/* generic helper function for reading 9-16 bit wide regs */
+static inline int axp20x_read_variable_width(struct regmap *regmap,
+	unsigned int reg, unsigned int width)
+{
+	unsigned int reg_val, result;
+	int err;
+
+	err = regmap_read(regmap, reg, &reg_val);
+	if (err)
+		return err;
+
+	result = reg_val << (width - 8);
+
+	err = regmap_read(regmap, reg + 1, &reg_val);
+	if (err)
+		return err;
+
+	result |= reg_val;
+
+	return result;
+}
+
+/**
+ * axp20x_match_device(): Setup axp20x variant related fields
+ *
+ * @axp20x: axp20x device to setup (.dev field must be set)
+ * @dev: device associated with this axp20x device
+ *
+ * This lets the axp20x core configure the mfd cells and register maps
+ * for later use.
+ */
+int axp20x_match_device(struct axp20x_dev *axp20x);
+
+/**
+ * axp20x_device_probe(): Probe a configured axp20x device
+ *
+ * @axp20x: axp20x device to probe (must be configured)
+ *
+ * This function lets the axp20x core register the axp20x mfd devices
+ * and irqchip. The axp20x device passed in must be fully configured
+ * with axp20x_match_device, its irq set, and regmap created.
+ */
+int axp20x_device_probe(struct axp20x_dev *axp20x);
+
+/**
+ * axp20x_device_probe(): Remove a axp20x device
+ *
+ * @axp20x: axp20x device to remove
+ *
+ * This tells the axp20x core to remove the associated mfd devices
+ */
+int axp20x_device_remove(struct axp20x_dev *axp20x);
+
+#endif /* __LINUX_MFD_AXP20X_H */
+
diff --git a/include/sound/soc-dai.h b/include/sound/soc-dai.h
index bbd821d2d..57e5f99b0 100644
--- a/include/sound/soc-dai.h
+++ b/include/sound/soc-dai.h
@@ -93,6 +93,7 @@ struct snd_compr_stream;
  *
  * "Negative" FSYNC polarity is the one opposite of "normal" polarity.
  */
+#define SND_SOC_DAIFMT_NB_NF_H616	(1 << 8) /* normal bit clock + frame */
 #define SND_SOC_DAIFMT_NB_NF		(0 << 8) /* normal bit clock + frame */
 #define SND_SOC_DAIFMT_NB_IF		(2 << 8) /* normal BCLK + inv FRM */
 #define SND_SOC_DAIFMT_IB_NF		(3 << 8) /* invert BCLK + nor FRM */
diff --git a/sound/soc/codecs/hdmi-codec.c b/sound/soc/codecs/hdmi-codec.c
index b77346661..ea9b4463e 100644
--- a/sound/soc/codecs/hdmi-codec.c
+++ b/sound/soc/codecs/hdmi-codec.c
@@ -290,6 +290,19 @@ enum {
 	DAI_ID_SPDIF,
 };
 
+static int check_h616_quirk(void)
+{
+	struct device_node *dt_node;
+
+	dt_node = of_find_node_by_path("/soc/hdmi@6000000");
+	if (dt_node)
+		if (of_get_property(dt_node, "aw-hdmi-codec-quirk", NULL))
+			return 1;
+
+	return 0;
+}
+
+
 static int hdmi_eld_ctl_info(struct snd_kcontrol *kcontrol,
 			     struct snd_ctl_elem_info *uinfo)
 {
@@ -432,19 +445,25 @@ static int hdmi_codec_startup(struct snd_pcm_substream *substream,
 {
 	struct hdmi_codec_priv *hcp = snd_soc_dai_get_drvdata(dai);
 	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
-	int ret = 0;
-
-	mutex_lock(&hcp->lock);
-	if (hcp->busy) {
-		dev_err(dai->dev, "Only one simultaneous stream supported!\n");
-		mutex_unlock(&hcp->lock);
-		return -EINVAL;
-	}
+	int ret = 0, aw_quirk = 0;
+
+        aw_quirk = check_h616_quirk();
+
+	if (aw_quirk)
+		;//printk("hdmi_codec_startup: using aw-hdmi-codec-quirk for H616\n");
+	else {
+		mutex_lock(&hcp->lock);
+		if (hcp->busy) {
+			dev_err(dai->dev, "Only one simultaneous stream supported!\n");
+			mutex_unlock(&hcp->lock);
+			return -EINVAL;
+		}
 
-	if (hcp->hcd.ops->audio_startup) {
-		ret = hcp->hcd.ops->audio_startup(dai->dev->parent, hcp->hcd.data);
-		if (ret)
-			goto err;
+		if (hcp->hcd.ops->audio_startup) {
+			ret = hcp->hcd.ops->audio_startup(dai->dev->parent, hcp->hcd.data);
+			if (ret)
+				goto err;
+		}
 	}
 
 	if (tx && hcp->hcd.ops->get_eld) {
@@ -472,13 +491,20 @@ static void hdmi_codec_shutdown(struct snd_pcm_substream *substream,
 				struct snd_soc_dai *dai)
 {
 	struct hdmi_codec_priv *hcp = snd_soc_dai_get_drvdata(dai);
+	int aw_quirk = 0;
 
-	hcp->chmap_idx = HDMI_CODEC_CHMAP_IDX_UNKNOWN;
-	hcp->hcd.ops->audio_shutdown(dai->dev->parent, hcp->hcd.data);
+       aw_quirk = check_h616_quirk();
 
-	mutex_lock(&hcp->lock);
-	hcp->busy = false;
-	mutex_unlock(&hcp->lock);
+	if (aw_quirk)
+		;//printk("hdmi_codec_shutdown: using aw-hdmi-codec-quirk for H616\n");
+	else {
+		hcp->chmap_idx = HDMI_CODEC_CHMAP_IDX_UNKNOWN;
+		hcp->hcd.ops->audio_shutdown(dai->dev->parent, hcp->hcd.data);
+
+		mutex_lock(&hcp->lock);
+		hcp->busy = false;
+		mutex_unlock(&hcp->lock);
+	}
 }
 
 static int hdmi_codec_fill_codec_params(struct snd_soc_dai *dai,
@@ -987,7 +1013,7 @@ static int hdmi_codec_probe(struct platform_device *pdev)
 	struct snd_soc_dai_driver *daidrv;
 	struct device *dev = &pdev->dev;
 	struct hdmi_codec_priv *hcp;
-	int dai_count, i = 0;
+	int dai_count, i = 0, aw_quirk = 0;
 	int ret;
 
 	if (!hcd) {
@@ -1037,6 +1063,18 @@ static int hdmi_codec_probe(struct platform_device *pdev)
 			__func__, ret);
 		return ret;
 	}
+
+	aw_quirk = check_h616_quirk();
+
+	if (aw_quirk) {
+		;//printk("hdmi_codec_probe: using aw-hdmi-codec-quirk for H616\n");
+		if (hcp->hcd.ops->audio_startup) {
+			ret = hcp->hcd.ops->audio_startup(dev, hcp->hcd.data);
+			if (ret)
+				return 0;
+		}
+	}
+
 	return 0;
 }
 
diff --git a/sound/soc/soc-utils.c b/sound/soc/soc-utils.c
index 594cb311f..eaa64cf8f 100644
--- a/sound/soc/soc-utils.c
+++ b/sound/soc/soc-utils.c
@@ -115,17 +115,26 @@ static int dummy_dma_open(struct snd_soc_component *component,
 			  struct snd_pcm_substream *substream)
 {
 	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
-	int i;
-
+	int i, aw_quirks = 0;
+	struct device_node *dt_node;
 	/*
 	 * If there are other components associated with rtd, we shouldn't
 	 * override their hwparams
 	 */
-	for_each_rtd_components(rtd, i, component) {
-		if (component->driver == &dummy_platform)
-			return 0;
-	}
 
+	dt_node = of_find_node_by_path("/soc/hdmi@6000000");
+	if (dt_node)
+		if (of_get_property(dt_node, "aw-hdmi-codec-quirk", NULL))
+			aw_quirks = 1;
+
+	if (aw_quirks)
+		;//printk("dummy_dma_open: using aw-hdmi-codec-quirk for H616\n");
+	else
+		for_each_rtd_components(rtd, i, component) {
+			if (component->driver == &dummy_platform)
+				return 0;
+		}
+		
 	/* BE's dont need dummy params */
 	if (!rtd->dai_link->no_pcm)
 		snd_soc_set_runtime_hwparams(substream, &dummy_dma_hardware);
diff --git a/sound/soc/sunxi/Kconfig b/sound/soc/sunxi/Kconfig
index 65cba1955..0a648d197 100644
--- a/sound/soc/sunxi/Kconfig
+++ b/sound/soc/sunxi/Kconfig
@@ -10,6 +10,15 @@ config SND_SUN4I_CODEC
 	  Select Y or M to add support for the Codec embedded in the Allwinner
 	  A10 and affiliated SoCs.
 
+config SND_SUN50IW9_CODEC
+	tristate "Allwinner H616 Codec Support"
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select REGMAP_MMIO
+	help
+	  Select Y or M to add support for the Codec embedded in the Allwinner
+	  H616 and affiliated SoCs.
+
+
 config SND_SUN8I_CODEC
 	tristate "Allwinner SUN8I audio codec"
 	depends on OF
@@ -80,5 +89,23 @@ config SND_SUN9I_HDMI_AUDIO
 config SND_SUN8I_ADDA_PR_REGMAP
 	tristate
 	select REGMAP
+	
+config SND_SOC_SUN50I_AHUB
+	bool "Allwinner H616 Audio Hub Support for ASoc"
+	select REGMAP_MMIO
+	default n
+	help
+	  Say Y or M if you want to using ahub module.
+
+config SND_SOC_SUN50I_HDMI
+	bool "ASoc support for Allwinner H616 HDMI"
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select DRM_DW_HDMI_I2S_AUDIO
+	select SND_SOC_HDMI_CODEC
+	select REGMAP_MMIO
+	default n
+	help
+	   Say Y or M here if you want to add support for SoC hdmi audio on Allwinner
+	   H616 boards, such as Orange Pi Zero 2.
 
 endmenu
diff --git a/sound/soc/sunxi/Makefile b/sound/soc/sunxi/Makefile
index 8d5d3db1f..4a237915b 100644
--- a/sound/soc/sunxi/Makefile
+++ b/sound/soc/sunxi/Makefile
@@ -1,6 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0
 obj-$(CONFIG_SND_SUN8I_CODEC_ANALOG) += sun8i-codec-analog.o
 obj-$(CONFIG_SND_SUN4I_CODEC) += sun4i-codec.o
+obj-$(CONFIG_SND_SUN50IW9_CODEC) += sun50iw9-codec.o
 obj-$(CONFIG_SND_SUN4I_I2S) += sun4i-i2s.o
 obj-$(CONFIG_SND_SUN4I_SPDIF) += sun4i-spdif.o
 obj-$(CONFIG_SND_SUN50I_CODEC_ANALOG) += sun50i-codec-analog.o
@@ -8,3 +9,12 @@ obj-$(CONFIG_SND_SUN8I_CODEC) += sun8i-codec.o
 obj-$(CONFIG_SND_SUN8I_ADDA_PR_REGMAP) += sun8i-adda-pr-regmap.o
 obj-$(CONFIG_SND_SUN9I_HDMI_AUDIO) += sun9i-hdmi-audio.o
 obj-$(CONFIG_SND_AC100_CODEC) += ac100-codec.o
+obj-$(CONFIG_SND_SUN9I_HDMI_AUDIO) += sun9i-hdmi-audio.o
+
+# audio hub
+obj-$(CONFIG_SND_SOC_SUN50I_AHUB) += sun50i-ahub.o
+obj-$(CONFIG_SND_SOC_SUN50I_AHUB) += sun50i-ahub-cpudai.o
+obj-$(CONFIG_SND_SOC_SUN50I_AHUB) += sun50i-ahub-daudio.o
+# ahub machine
+obj-$(CONFIG_SND_SOC_SUN50I_AHUB) += sun50i-sndahub.o
+obj-$(CONFIG_SND_SOC_SUN50I_HDMI) += sun50i-sndhdmi.o
diff --git a/sound/soc/sunxi/sun50i-ahub-cpudai.c b/sound/soc/sunxi/sun50i-ahub-cpudai.c
new file mode 100644
index 000000000..a1aba67f5
--- /dev/null
+++ b/sound/soc/sunxi/sun50i-ahub-cpudai.c
@@ -0,0 +1,523 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * (C) Copyright 2014-2018
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Wolfgang huang <huangjinhui@allwinnertech.com>
+ *
+ * (C) Copyright 2021
+ * Shenzhen Xunlong Software Co., Ltd. <www.orangepi.org>
+ * Leeboby <leeboby@aliyun.com>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include "sun50i_ahub.h"
+
+#define DRV_NAME "sunxi-ahub-cpudai"
+
+struct sunxi_ahub_cpudai_priv {
+	unsigned int id;
+	int karaoke_mode;
+	struct regmap *regmap;
+	struct snd_dmaengine_dai_dma_data playback_dma_param;
+	struct snd_dmaengine_dai_dma_data capture_dma_param;
+};
+
+static int startup_playback_cnt;
+static int startup_capture_cnt;
+static int karaoke_cnt;
+
+int sunxi_ahub_cpudai_init(void)
+{
+	startup_playback_cnt = 0;
+	startup_capture_cnt = 0;
+	karaoke_cnt = 0;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sunxi_ahub_cpudai_init);
+
+
+static int sunxi_ahub_i2s_playback_route_enable(
+		struct sunxi_ahub_cpudai_priv *sunxi_ahub_cpudai)
+{
+	int i, reg_bit;
+	unsigned int reg_val;
+
+	/* first check it's on karaoke mode? */
+	reg_val = sunxi_ahub_read(SUNXI_AHUB_DAM_RX0_SRC(0));
+	if (!reg_val) {
+		reg_val = sunxi_ahub_read(
+				SUNXI_AHUB_DAM_RX1_SRC(0));
+		if (!reg_val)
+			goto no_karaook_handle;
+	}
+	for (i = 0; i < 4; i++) {
+		reg_val = sunxi_ahub_read(
+				SUNXI_AHUB_I2S_RXCONT(i));
+		if (reg_val & (1<<19)) {
+			/* I2S0...HDMI...I2S2...CVBS... */
+			reg_bit = 23 - i;
+			/* setting the rst & gating register for I2S module */
+			sunxi_ahub_update_bits(
+					SUNXI_AHUB_RST,
+					(1<<reg_bit), (1<<reg_bit));
+			sunxi_ahub_update_bits(
+				SUNXI_AHUB_GAT,
+				(1<<reg_bit), (1<<reg_bit));
+			sunxi_ahub_update_bits(
+				SUNXI_AHUB_I2S_CTL(i),
+				(1<<I2S_CTL_TXEN), (1<<I2S_CTL_TXEN));
+		}
+	}
+	sunxi_ahub_cpudai->karaoke_mode = 1;
+	karaoke_cnt++;
+	return 0;
+
+no_karaook_handle:
+	switch (sunxi_ahub_cpudai->id) {
+	case 0:
+		/* operation HDMI I2S module */
+		sunxi_ahub_update_bits(SUNXI_AHUB_RST,
+				(1<<I2S1_RST), (1<<I2S1_RST));
+		sunxi_ahub_update_bits(SUNXI_AHUB_GAT,
+				(1<<I2S1_GAT), (1<<I2S1_GAT));
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(1),
+				(1<<I2S_CTL_TXEN), (1<<I2S_CTL_TXEN));
+
+		sunxi_ahub_update_bits(SUNXI_AHUB_RST,
+				(1<<I2S0_RST), (1<<I2S0_RST));
+		sunxi_ahub_update_bits(SUNXI_AHUB_GAT,
+				(1<<I2S0_GAT), (1<<I2S0_GAT));
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(0),
+				(1<<I2S_CTL_TXEN), (1<<I2S_CTL_TXEN));
+		break;
+	case 1:
+		/* operation CVBS module */
+		sunxi_ahub_update_bits(SUNXI_AHUB_RST,
+				(1<<I2S3_RST), (1<<I2S3_RST));
+		sunxi_ahub_update_bits(SUNXI_AHUB_GAT,
+				(1<<I2S3_GAT), (1<<I2S3_GAT));
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(3),
+				(1<<I2S_CTL_TXEN), (1<<I2S_CTL_TXEN));
+		break;
+	case 2:
+		/* operation I2S2 for bluetooth */
+		sunxi_ahub_update_bits(SUNXI_AHUB_RST,
+				(1<<I2S2_RST), (1<<I2S2_RST));
+		sunxi_ahub_update_bits(SUNXI_AHUB_GAT,
+				(1<<I2S2_GAT), (1<<I2S2_GAT));
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(2),
+				(1<<I2S_CTL_TXEN), (1<<I2S_CTL_TXEN));
+		break;
+	default:
+		break;
+	}
+	sunxi_ahub_cpudai->karaoke_mode = 0;
+	
+	return 0;
+}
+
+static int sunxi_ahub_i2s_playback_route_disable(
+		struct sunxi_ahub_cpudai_priv *sunxi_ahub_cpudai)
+{
+	unsigned int reg_val;
+	int i;
+
+ 	if (sunxi_ahub_cpudai->karaoke_mode) {
+		if (--karaoke_cnt == 0) {
+			for (i = 0; i < 4; i++) {
+				reg_val = sunxi_ahub_read(
+					SUNXI_AHUB_I2S_CTL(i));
+				if (reg_val & (1 << I2S_CTL_TXEN))
+					/* I2S0...HDMI...I2S2...CVBS... */
+					sunxi_ahub_update_bits(
+						SUNXI_AHUB_I2S_CTL(i),
+						(1<<I2S_CTL_TXEN),
+						(0<<I2S_CTL_TXEN));
+			}
+		}
+	} else {
+		switch (sunxi_ahub_cpudai->id) {
+		case 0:
+			/* operation HDMI I2S module */
+			sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(1),
+					(1<<I2S_CTL_TXEN), (0<<I2S_CTL_TXEN));
+			sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(0),
+					(1<<I2S_CTL_TXEN), (0<<I2S_CTL_TXEN));
+			break;
+		case 1:
+			/* operation CVBS module */
+			sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(3),
+					(1<<I2S_CTL_TXEN), (0<<I2S_CTL_TXEN));
+			break;
+		case 2:
+			/* operation I2S2 for bluetooth */
+			sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(2),
+					(1<<I2S_CTL_TXEN), (0<<I2S_CTL_TXEN));
+			break;
+		default:
+			break;
+		}
+	}
+	return 0;
+}
+
+
+static int sunxi_ahub_i2s_capture_route_enable(
+		struct sunxi_ahub_cpudai_priv *sunxi_ahub_cpudai)
+{
+	int i2s0_cap_bit = 27;
+	/* HDMI just for support debug */
+	int i2s1_cap_bit = 26;
+	int i2s2_cap_bit = 25;
+	int i2s3_cap_bit = 23;
+	unsigned int reg_val;
+
+	reg_val = sunxi_ahub_read(
+		SUNXI_AHUB_APBIF_RXFIFO_CONT(sunxi_ahub_cpudai->id));
+	if (reg_val == (1<<i2s0_cap_bit)) {
+		sunxi_ahub_update_bits(SUNXI_AHUB_RST,
+			(1<<I2S0_RST), (1<<I2S0_RST));
+		sunxi_ahub_update_bits(SUNXI_AHUB_GAT,
+			(1<<I2S0_GAT), (1<<I2S0_GAT));
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(0),
+			(1<<I2S_CTL_RXEN), (1<<I2S_CTL_RXEN));		
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(0),
+				(1 << I2S_CTL_SDI0_EN), ( 1<< I2S_CTL_SDI0_EN));
+		/* add the delay to anti pop noise when it start capture */
+		mdelay(100);		
+	}
+
+	if (reg_val == (1 << i2s1_cap_bit)) {
+		sunxi_ahub_update_bits(SUNXI_AHUB_RST,
+			(1 << I2S1_RST), (1 << I2S1_RST));
+		sunxi_ahub_update_bits(SUNXI_AHUB_GAT,
+			(1 << I2S1_GAT), (1 << I2S1_GAT));
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(1),
+			(1 << I2S_CTL_RXEN), (1 << I2S_CTL_RXEN));
+	}
+
+	if (reg_val == (1<<i2s2_cap_bit)) {
+		sunxi_ahub_update_bits(SUNXI_AHUB_RST,
+			(1<<I2S2_RST), (1<<I2S2_RST));
+		sunxi_ahub_update_bits(SUNXI_AHUB_GAT,
+			(1<<I2S2_GAT), (1<<I2S2_GAT));
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(2),
+			(1<<I2S_CTL_RXEN), (1<<I2S_CTL_RXEN));
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(2),
+			(1<<I2S_CTL_SDI0_EN), (1<<I2S_CTL_SDI0_EN));
+		/* add the delay to anti pop noise when it start capture */
+		mdelay(100);
+	}
+
+	if (reg_val == (1<<i2s3_cap_bit)) {
+		sunxi_ahub_update_bits(SUNXI_AHUB_RST,
+			(1<<I2S3_RST), (1<<I2S3_RST));
+		sunxi_ahub_update_bits(SUNXI_AHUB_GAT,
+			(1<<I2S3_GAT), (1<<I2S3_GAT));
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(3),
+			(1<<I2S_CTL_RXEN), (1<<I2S_CTL_RXEN));
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(3),
+			(1<<I2S_CTL_SDI0_EN), (1<<I2S_CTL_SDI0_EN));
+		/* add the delay to anti pop noise when it start capture */
+		mdelay(100);
+	}
+
+	return 0;
+}
+
+static int sunxi_ahub_i2s_capture_route_disable(
+		struct sunxi_ahub_cpudai_priv *sunxi_ahub_cpudai)
+{
+	int i2s0_cap_bit = 27;
+	/* HDMI just for support debug */
+	int i2s1_cap_bit = 26;
+	int i2s2_cap_bit = 25;
+	int i2s3_cap_bit = 23;
+	unsigned int reg_val;
+
+	reg_val = sunxi_ahub_read(
+		SUNXI_AHUB_APBIF_RXFIFO_CONT(sunxi_ahub_cpudai->id));
+	if (reg_val == (1<<i2s0_cap_bit)) {
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(0),
+			(1<<I2S_CTL_RXEN), (0<<I2S_CTL_RXEN));		
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(0),
+				(1<<I2S_CTL_SDI0_EN), (0<<I2S_CTL_SDI0_EN));
+	}
+
+	if (reg_val == (1 << i2s1_cap_bit)) {
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(1),
+			(1 << I2S_CTL_RXEN), (0 << I2S_CTL_RXEN));
+	}
+
+	if (reg_val == (1<<i2s2_cap_bit)) {
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(2),
+			(1<<I2S_CTL_RXEN), (0<<I2S_CTL_RXEN));
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(2),
+				(1<<I2S_CTL_SDI0_EN), (0<<I2S_CTL_SDI0_EN));
+	}
+
+	if (reg_val == (1<<i2s3_cap_bit)) {
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(3),
+			(1<<I2S_CTL_RXEN), (0<<I2S_CTL_RXEN));
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(3),
+				(1<<I2S_CTL_SDI0_EN), (0<<I2S_CTL_SDI0_EN));
+	}
+	
+	return 0;
+}
+
+static int sunxi_ahub_cpudai_startup(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_cpudai_priv *sunxi_ahub_cpudai =
+					snd_soc_dai_get_drvdata(dai);
+
+ 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		snd_soc_dai_set_dma_data(dai, substream,
+					&sunxi_ahub_cpudai->playback_dma_param);
+	else
+		snd_soc_dai_set_dma_data(dai, substream,
+					&sunxi_ahub_cpudai->capture_dma_param);
+
+	return 0;
+}
+
+static int sunxi_ahub_cpudai_trigger(struct snd_pcm_substream *substream,
+				int cmd, struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_cpudai_priv *sunxi_ahub_cpudai =
+					snd_soc_dai_get_drvdata(dai);
+
+ 	switch (cmd) {
+	case	SNDRV_PCM_TRIGGER_START:
+	case	SNDRV_PCM_TRIGGER_RESUME:
+	case	SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			if (startup_playback_cnt++ == 0)
+				sunxi_ahub_i2s_playback_route_enable(
+						sunxi_ahub_cpudai);
+			mdelay(1);
+			sunxi_ahub_update_bits(
+				SUNXI_AHUB_APBIF_TX_CTL(sunxi_ahub_cpudai->id),
+				(1<<APBIF_TX_START), (1<<APBIF_TX_START));
+			sunxi_ahub_update_bits(
+				SUNXI_AHUB_APBIF_TX_IRQ_CTL(
+					sunxi_ahub_cpudai->id),
+				(1<<APBIF_TX_DRQ), (1<<APBIF_TX_DRQ));
+			if (startup_playback_cnt++ > 1)
+				sunxi_ahub_i2s_playback_route_enable(
+						sunxi_ahub_cpudai);
+		} else {
+			if (startup_capture_cnt++ == 0) {
+				sunxi_ahub_update_bits(
+					SUNXI_AHUB_APBIF_RX_CTL(
+					sunxi_ahub_cpudai->id),
+					(1<<APBIF_RX_START),
+					(1<<APBIF_RX_START));
+				sunxi_ahub_update_bits(
+					SUNXI_AHUB_APBIF_RX_IRQ_CTL(
+					sunxi_ahub_cpudai->id),
+					(1<<APBIF_RX_DRQ),
+					(1<<APBIF_RX_DRQ));
+			}
+			if (startup_capture_cnt++ > 0)
+				sunxi_ahub_i2s_capture_route_enable(
+						sunxi_ahub_cpudai);
+		}
+		break;
+	case	SNDRV_PCM_TRIGGER_STOP:
+	case	SNDRV_PCM_TRIGGER_SUSPEND:
+	case	SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			sunxi_ahub_i2s_playback_route_disable(
+				sunxi_ahub_cpudai);
+			sunxi_ahub_update_bits(
+				SUNXI_AHUB_APBIF_TX_IRQ_CTL(
+				sunxi_ahub_cpudai->id),
+				(1<<APBIF_TX_DRQ), (0<<APBIF_TX_DRQ));
+			mdelay(2);
+			sunxi_ahub_update_bits(
+				SUNXI_AHUB_APBIF_TX_CTL(sunxi_ahub_cpudai->id),
+				(1<<APBIF_TX_START), (0<<APBIF_TX_START));
+		} else {
+			sunxi_ahub_i2s_capture_route_disable(
+					sunxi_ahub_cpudai);
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static struct snd_soc_dai_ops sunxi_ahub_cpudai_dai_ops = {
+	.startup = sunxi_ahub_cpudai_startup,
+	.trigger = sunxi_ahub_cpudai_trigger,
+};
+
+static int sunxi_ahub_dai_probe(struct snd_soc_dai *dai)
+{
+        struct sunxi_ahub_cpudai_priv *sunxi_ahub_cpudai =
+                                        snd_soc_dai_get_drvdata(dai);
+
+        snd_soc_dai_init_dma_data(dai,
+                                  &sunxi_ahub_cpudai->playback_dma_param,
+                                  &sunxi_ahub_cpudai->capture_dma_param);
+
+        return 0;
+}
+
+static struct snd_soc_dai_driver sunxi_ahub_cpudai_dai = {
+	.probe = sunxi_ahub_dai_probe,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 16,
+		.rates = SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT,
+		.rate_min       = 8000,
+		.rate_max       = 192000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE
+			| SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 16,
+		.rates = SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT,
+		.rate_min       = 8000,
+		.rate_max       = 192000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE
+			| SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.ops	= &sunxi_ahub_cpudai_dai_ops,
+
+};
+
+static const struct snd_soc_component_driver sunxi_ahub_cpudai_component = {
+	.name		= DRV_NAME,
+};
+	
+static const struct of_device_id sunxi_ahub_cpudai_of_match[] = {
+	{ .compatible = "allwinner,sunxi-ahub-cpudai", },
+	{},
+};
+
+static int  sunxi_ahub_cpudai_dev_probe(struct platform_device *pdev)
+{
+	struct resource res;	
+
+	struct sunxi_ahub_cpudai_priv *sunxi_ahub_cpudai;
+	struct device_node *np = pdev->dev.of_node;
+	unsigned int temp_val;
+	int ret;
+
+ 	sunxi_ahub_cpudai = devm_kzalloc(&pdev->dev,
+			sizeof(struct sunxi_ahub_cpudai_priv), GFP_KERNEL);
+	if (!sunxi_ahub_cpudai) {
+		dev_err(&pdev->dev, "Can't allocate sunxi_cpudai\n");
+		ret = -ENOMEM;
+		goto err_node_put;
+	}
+	
+	dev_set_drvdata(&pdev->dev, sunxi_ahub_cpudai);
+
+	ret = of_property_read_u32(np, "id", &temp_val);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "id configuration missing or invalid\n");
+		goto err_devm_kfree;
+	} else {
+		sunxi_ahub_cpudai->id = temp_val;
+	}
+
+	ret = of_address_to_resource(np, 0, &res);
+	if (ret) {
+		dev_err(&pdev->dev, "Can't parse device node resource\n");
+		ret = -ENODEV;
+		goto err_devm_kfree;
+	}
+
+	sunxi_ahub_cpudai->playback_dma_param.addr =
+		res.start + SUNXI_AHUB_APBIF_TXFIFO(sunxi_ahub_cpudai->id);
+	sunxi_ahub_cpudai->playback_dma_param.maxburst = 8;
+	sunxi_ahub_cpudai->playback_dma_param.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+
+	sunxi_ahub_cpudai->capture_dma_param.addr =
+		res.start + SUNXI_AHUB_APBIF_RXFIFO(sunxi_ahub_cpudai->id);
+	sunxi_ahub_cpudai->capture_dma_param.maxburst = 8;
+	sunxi_ahub_cpudai->capture_dma_param.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+
+	sunxi_ahub_cpudai->regmap = sunxi_ahub_regmap_init(pdev);
+	if (!sunxi_ahub_cpudai->regmap) {
+		dev_err(&pdev->dev, "regmap not init ok\n");
+		ret = -ENOMEM;
+		goto err_devm_kfree;
+	}
+	sunxi_ahub_cpudai_init();
+
+	ret = snd_soc_register_component(&pdev->dev,
+			&sunxi_ahub_cpudai_component,
+			&sunxi_ahub_cpudai_dai, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
+		ret = -EBUSY;
+		goto err_devm_kfree;
+	}
+
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to register against DMAEngine\n");
+		goto err_unregister_component;
+	}
+
+	return 0;
+
+err_unregister_component:
+	snd_soc_unregister_component(&pdev->dev);
+err_devm_kfree:
+	devm_kfree(&pdev->dev, sunxi_ahub_cpudai);
+err_node_put:
+	of_node_put(np);
+
+	return ret;
+}
+
+static int __exit sunxi_ahub_cpudai_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_ahub_cpudai_priv *sunxi_ahub_cpudai =
+					dev_get_drvdata(&pdev->dev);
+
+	snd_soc_unregister_component(&pdev->dev);
+	devm_kfree(&pdev->dev, sunxi_ahub_cpudai);
+
+	return 0;
+}
+
+static struct platform_driver sunxi_ahub_cpudai_driver = {
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_ahub_cpudai_of_match,
+	},
+	.probe = sunxi_ahub_cpudai_dev_probe,
+	.remove = __exit_p(sunxi_ahub_cpudai_dev_remove),
+};
+
+module_platform_driver(sunxi_ahub_cpudai_driver);
+
+MODULE_DESCRIPTION("SUNXI Audio Hub cpudai ASoC Interface");
+MODULE_AUTHOR("wolfgang huang <huangjinhui@allwinnertech.com>");
+MODULE_AUTHOR("Leeboby <leeboby@aliyun.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
diff --git a/sound/soc/sunxi/sun50i-ahub-daudio.c b/sound/soc/sunxi/sun50i-ahub-daudio.c
new file mode 100644
index 000000000..aa6005f38
--- /dev/null
+++ b/sound/soc/sunxi/sun50i-ahub-daudio.c
@@ -0,0 +1,943 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * (C) Copyright 2015-2017
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Wolfgang huang <huangjinhui@allwinnertechtech.com>
+ *
+ * (C) Copyright 2021
+ * Shenzhen Xunlong Software Co., Ltd. <www.orangepi.org>
+ * Leeboby <leeboby@aliyun.com>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/regulator/consumer.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/pm.h>
+#include <linux/of_gpio.h>
+#include <linux/workqueue.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+
+#include "sun50i_ahub.h"
+
+#define DRV_NAME	"sunxi-ahub-daudio"
+
+struct sunxi_ahub_daudio_priv {
+	struct device *dev;
+	struct regmap *regmap;
+	struct clk *clk_apb;
+	struct clk *clk_module;
+	struct clk *clk_audio_hub;
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pinstate;
+	struct pinctrl_state *pinstate_sleep;
+	struct snd_soc_dai_driver *cpudai;
+	char cpudai_name[20];
+	struct mutex mutex;
+	int used_cnt;
+	unsigned int pinconfig;
+	unsigned int frame_type;
+	unsigned int daudio_master;
+	unsigned int pcm_lrck_period;
+	unsigned int slot_width_select;
+	unsigned int audio_format;
+	unsigned int signal_inversion;
+	unsigned int tdm_config;
+	unsigned int tdm_num;
+	unsigned int mclk_div;
+};
+
+static int sunxi_ahub_daudio_global_enable(struct sunxi_ahub_daudio_priv
+		*sunxi_ahub_daudio, int enable, unsigned int id)
+{
+ 	if (enable) {
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(id),
+				(1<<I2S_CTL_SDO0_EN), (1<<I2S_CTL_SDO0_EN));
+		/* Special processing for HDMI hub playback module */
+		if (sunxi_ahub_daudio->tdm_num  == SUNXI_AHUB_HDMI_ID) {
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(sunxi_ahub_daudio->tdm_num),
+				(1<<I2S_CTL_SDO1_EN), (1<<I2S_CTL_SDO1_EN));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(sunxi_ahub_daudio->tdm_num),
+				(1<<I2S_CTL_SDO2_EN), (1<<I2S_CTL_SDO2_EN));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(sunxi_ahub_daudio->tdm_num),
+				(1<<I2S_CTL_SDO3_EN), (1<<I2S_CTL_SDO3_EN));
+		}
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(id),
+				(1<<I2S_CTL_GEN), (1<<I2S_CTL_GEN));
+	} else {
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(id),
+				(1<<I2S_CTL_GEN), (0<<I2S_CTL_GEN));
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(id),
+				(1<<I2S_CTL_SDO0_EN), (0<<I2S_CTL_SDO0_EN));
+		/* Special processing for HDMI hub playback module */
+		if (sunxi_ahub_daudio->tdm_num  == SUNXI_AHUB_HDMI_ID) {
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(sunxi_ahub_daudio->tdm_num),
+				(1<<I2S_CTL_SDO1_EN), (0<<I2S_CTL_SDO1_EN));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(sunxi_ahub_daudio->tdm_num),
+				(1<<I2S_CTL_SDO2_EN), (0<<I2S_CTL_SDO2_EN));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(sunxi_ahub_daudio->tdm_num),
+				(1<<I2S_CTL_SDO3_EN), (0<<I2S_CTL_SDO3_EN));
+		}
+	}
+	return 0;
+}
+
+static int sunxi_ahub_daudio_mclk_setting(struct sunxi_ahub_daudio_priv
+				*sunxi_ahub_daudio, unsigned int id)
+{
+	unsigned int mclk_div;
+
+ 	if (sunxi_ahub_daudio->mclk_div) {
+		switch (sunxi_ahub_daudio->mclk_div) {
+		case	1:
+			mclk_div = 1;
+			break;
+		case	2:
+			mclk_div = 2;
+			break;
+		case	4:
+			mclk_div = 3;
+			break;
+		case	6:
+			mclk_div = 4;
+			break;
+		case	8:
+			mclk_div = 5;
+			break;
+		case	12:
+			mclk_div = 6;
+			break;
+		case	16:
+			mclk_div = 7;
+			break;
+		case	24:
+			mclk_div = 8;
+			break;
+		case	32:
+			mclk_div = 9;
+			break;
+		case	48:
+			mclk_div = 10;
+			break;
+		case	64:
+			mclk_div = 11;
+			break;
+		case	96:
+			mclk_div = 12;
+			break;
+		case	128:
+			mclk_div = 13;
+			break;
+		case	176:
+			mclk_div = 14;
+			break;
+		case	192:
+			mclk_div = 15;
+			break;
+		default:
+			dev_err(sunxi_ahub_daudio->dev,
+					"unsupport  mclk_div\n");
+			return -EINVAL;
+		}
+		/* setting Mclk as external codec input clk */
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CLKD(id),
+				(0xf<<I2S_CLKD_MCLKDIV),
+				(mclk_div<<I2S_CLKD_MCLKDIV));
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CLKD(id),
+				(0x1<<I2S_CLKD_MCLK), (1<<I2S_CLKD_MCLK));
+	} else {
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CLKD(id),
+				(0x1<<I2S_CLKD_MCLK), (0<<I2S_CLKD_MCLK));
+	}
+	return 0;
+}
+
+static int sunxi_ahub_daudio_init_fmt(struct sunxi_ahub_daudio_priv
+		*sunxi_ahub_daudio, unsigned int fmt, unsigned int id)
+{
+	unsigned int offset, mode;
+	unsigned int lrck_polarity = 0;
+	unsigned int brck_polarity;
+
+ 	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case	SND_SOC_DAIFMT_CBM_CFM:
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(id),
+				(1<<I2S_CTL_CLK_OUT), (0<<I2S_CTL_CLK_OUT));
+		break;
+	case	SND_SOC_DAIFMT_CBS_CFS:
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(id),
+				(1<<I2S_CTL_CLK_OUT), (1<<I2S_CTL_CLK_OUT));
+		break;
+	default:
+		dev_err(sunxi_ahub_daudio->dev, "unknown maser/slave format\n");
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case	SND_SOC_DAIFMT_I2S:
+		offset = 1;
+		mode = 1;
+		break;
+	case	SND_SOC_DAIFMT_RIGHT_J:
+		offset = 0;
+		mode = 2;
+		break;
+	case	SND_SOC_DAIFMT_LEFT_J:
+		offset = 0;
+		mode = 1;
+		break;
+	case	SND_SOC_DAIFMT_DSP_A:
+		offset = 1;
+		mode = 0;
+		break;
+	case	SND_SOC_DAIFMT_DSP_B:
+		offset = 0;
+		mode = 0;
+		break;
+	default:
+		dev_err(sunxi_ahub_daudio->dev, "format setting failed\n");
+		return -EINVAL;
+	}
+	regmap_update_bits(sunxi_ahub_daudio->regmap, SUNXI_AHUB_I2S_CTL(id),
+			(0x3<<I2S_CTL_MODE), (mode<<I2S_CTL_MODE));
+	regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_SLOT0(id),
+			(0x1<<I2S_OUT_OFFSET), (offset<<I2S_OUT_OFFSET));
+	regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_SLOT1(id),
+			(0x1<<I2S_OUT_OFFSET), (offset<<I2S_OUT_OFFSET));
+	regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_SLOT2(id),
+			(0x1<<I2S_OUT_OFFSET), (offset<<I2S_OUT_OFFSET));
+	regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_SLOT3(id),
+			(0x1<<I2S_OUT_OFFSET), (offset<<I2S_OUT_OFFSET));
+	regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_IN_SLOT(id),
+			(0x1<<I2S_IN_OFFSET), (offset<<I2S_IN_OFFSET));
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case	SND_SOC_DAIFMT_I2S:
+	case	SND_SOC_DAIFMT_RIGHT_J:
+	case	SND_SOC_DAIFMT_LEFT_J:
+		switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+		case	SND_SOC_DAIFMT_NB_NF_H616:
+			lrck_polarity = 0;
+			brck_polarity = 0;
+			break;
+		case	SND_SOC_DAIFMT_NB_IF:
+			lrck_polarity = 1;
+			brck_polarity = 0;
+			break;
+		case	SND_SOC_DAIFMT_IB_NF:
+			lrck_polarity = 0;
+			brck_polarity = 1;
+			break;
+		case	SND_SOC_DAIFMT_IB_IF:
+			lrck_polarity = 1;
+			brck_polarity = 1;
+			break;
+		default:
+			dev_err(sunxi_ahub_daudio->dev,
+					"invert clk setting failed\n");
+			return -EINVAL;
+		}
+		break;
+	case	SND_SOC_DAIFMT_DSP_A:
+	case	SND_SOC_DAIFMT_DSP_B:
+		/* frame inversion not valid for DSP modes */
+		switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+		case SND_SOC_DAIFMT_NB_NF_H616:
+			lrck_polarity = 0;
+			brck_polarity = 0;
+			break;
+		case SND_SOC_DAIFMT_IB_NF:
+			lrck_polarity = 0;
+			brck_polarity = 1;
+			break;
+		default:
+			dev_err(sunxi_ahub_daudio->dev, "dai fmt invalid\n");
+			return -EINVAL;
+		}
+		break;
+	default:
+		dev_err(sunxi_ahub_daudio->dev, "format setting failed\n");
+		return -EINVAL;
+	}
+
+	regmap_update_bits(sunxi_ahub_daudio->regmap, SUNXI_AHUB_I2S_FMT0(id),
+			(1<<I2S_FMT0_LRCK_POLARITY),
+			(lrck_polarity<<I2S_FMT0_LRCK_POLARITY));
+	regmap_update_bits(sunxi_ahub_daudio->regmap, SUNXI_AHUB_I2S_FMT0(id),
+			(1<<I2S_FMT0_BCLK_POLARITY),
+			(brck_polarity<<I2S_FMT0_BCLK_POLARITY));
+	return 0;
+}
+
+static int sunxi_ahub_daudio_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio =
+				snd_soc_dai_get_drvdata(dai);
+
+ 	sunxi_ahub_daudio_init_fmt(sunxi_ahub_daudio, fmt,
+					(sunxi_ahub_daudio->tdm_num));
+	return 0;
+}
+
+
+static int sunxi_ahub_daudio_init(
+		struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio, int id)
+{
+	int ret;
+
+ 	sunxi_ahub_daudio_global_enable(sunxi_ahub_daudio, 1, id);
+
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_CH0MAP0(id), 0x76543210);
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_CH0MAP1(id), 0xFEDCBA98);
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_CH1MAP0(id), 0x76543210);
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_CH1MAP1(id), 0xFEDCBA98);
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_CH2MAP0(id), 0x76543210);
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_CH2MAP1(id), 0xFEDCBA98);
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_CH3MAP0(id), 0x76543210);
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_CH3MAP1(id), 0xFEDCBA98);		
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_IN_CHMAP0(id), 0x03020100);
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_IN_CHMAP1(id), 0x00000000);	
+	
+	regmap_update_bits(sunxi_ahub_daudio->regmap, SUNXI_AHUB_I2S_FMT0(id),
+			(1<<I2S_FMT0_LRCK_WIDTH),
+			(sunxi_ahub_daudio->frame_type<<I2S_FMT0_LRCK_WIDTH));
+	regmap_update_bits(sunxi_ahub_daudio->regmap, SUNXI_AHUB_I2S_FMT0(id),
+		(0x1ff<<I2S_FMT0_LRCK_PERIOD),
+		((sunxi_ahub_daudio->pcm_lrck_period-1)<<I2S_FMT0_LRCK_PERIOD));
+
+	regmap_update_bits(sunxi_ahub_daudio->regmap, SUNXI_AHUB_I2S_FMT0(id),
+		(0x7<<I2S_FMT0_SW),
+		(((sunxi_ahub_daudio->slot_width_select>>2) - 1)<<I2S_FMT0_SW));
+
+	/*
+	 * MSB on the transmit format, always be first.
+	 * default using Linear-PCM, without no companding.
+	 * A-law<Eourpean standard> or U-law<US-Japan> not working ok.
+	 */
+	regmap_write(sunxi_ahub_daudio->regmap, SUNXI_AHUB_I2S_FMT1(id), 0x30);	
+
+	/* default setting the daudio fmt */
+	sunxi_ahub_daudio_init_fmt(sunxi_ahub_daudio,
+		(sunxi_ahub_daudio->audio_format
+		| (sunxi_ahub_daudio->signal_inversion<<8)
+		| (sunxi_ahub_daudio->daudio_master<<12)), id);
+
+	sunxi_ahub_daudio_mclk_setting(sunxi_ahub_daudio, id);
+
+	return 0;
+}
+
+static int sunxi_ahub_daudio_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio =
+					snd_soc_dai_get_drvdata(dai);
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_card *card = rtd->card;		
+
+	/* default setting the daudio fmt */
+	sunxi_ahub_daudio_init_fmt(sunxi_ahub_daudio,
+		(sunxi_ahub_daudio->audio_format
+			| (sunxi_ahub_daudio->signal_inversion<<8)
+			| (sunxi_ahub_daudio->daudio_master<<12)),
+		sunxi_ahub_daudio->tdm_num);
+
+	switch (params_format(params)) {
+	case	SNDRV_PCM_FORMAT_S16_LE:
+		/*
+		 * Special procesing for hdmi, HDMI card name is
+		 * "sndhdmi" or sndhdmiraw. if card not HDMI,
+		 * strstr func just return NULL, jump to right section.
+		 * Not HDMI card, sunxi_hdmi maybe a NULL pointer.
+		 */
+		if (sunxi_ahub_daudio->tdm_num == SUNXI_AHUB_HDMI_ID) {
+			if (0)
+				regmap_update_bits(sunxi_ahub_daudio->regmap,
+					SUNXI_AHUB_I2S_FMT0(
+					sunxi_ahub_daudio->tdm_num),
+					(7<<I2S_FMT0_SR), (5<<I2S_FMT0_SR));
+			else
+				regmap_update_bits(sunxi_ahub_daudio->regmap,
+					SUNXI_AHUB_I2S_FMT0(
+					sunxi_ahub_daudio->tdm_num),
+					(7<<I2S_FMT0_SR), (3<<I2S_FMT0_SR));
+		} else {
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_FMT0(sunxi_ahub_daudio->tdm_num),
+					(7<<I2S_FMT0_SR), (3<<I2S_FMT0_SR));
+		}
+		break;
+	case	SNDRV_PCM_FORMAT_S24_LE:
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_FMT0(sunxi_ahub_daudio->tdm_num),
+				(7<<I2S_FMT0_SR), (5<<I2S_FMT0_SR));
+		break;
+	case	SNDRV_PCM_FORMAT_S32_LE:
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_FMT0(sunxi_ahub_daudio->tdm_num),
+				(7<<I2S_FMT0_SR), (7<<I2S_FMT0_SR));
+		break;
+	default:
+		dev_err(sunxi_ahub_daudio->dev, "unrecognized format\n");
+		return -EINVAL;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_CHCFG(sunxi_ahub_daudio->tdm_num),
+			(0xf<<I2S_CHCFG_TX_CHANNUM),
+			((params_channels(params)-1)<<I2S_CHCFG_TX_CHANNUM));
+
+		if (sunxi_ahub_daudio->tdm_num == SUNXI_AHUB_HDMI_ID) {
+			regmap_write(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_CH0MAP0(
+				sunxi_ahub_daudio->tdm_num),
+				0x10);
+			if (0) {
+				regmap_write(sunxi_ahub_daudio->regmap,
+					SUNXI_AHUB_I2S_OUT_CH1MAP0(
+					sunxi_ahub_daudio->tdm_num),
+					0x32);
+				regmap_write(sunxi_ahub_daudio->regmap,
+					SUNXI_AHUB_I2S_OUT_CH2MAP0(
+					sunxi_ahub_daudio->tdm_num),
+					0x54);
+				regmap_write(sunxi_ahub_daudio->regmap,
+					SUNXI_AHUB_I2S_OUT_CH3MAP0(
+					sunxi_ahub_daudio->tdm_num),
+					0x76);
+			} else {
+				if (params_channels(params) > 2) {
+					regmap_write(sunxi_ahub_daudio->regmap,
+						SUNXI_AHUB_I2S_OUT_CH1MAP0(
+						sunxi_ahub_daudio->tdm_num),
+						0x23);
+				/* only 5.1 & 7.1 */
+				if (params_channels(params) > 4) {
+					if (params_channels(params) == 6)
+						/* 5.1 hit this */
+						regmap_write(
+						sunxi_ahub_daudio->regmap,
+						SUNXI_AHUB_I2S_OUT_CH2MAP0(
+						sunxi_ahub_daudio->tdm_num),
+						0x54);
+					else
+						/* 7.1 hit this */
+						regmap_write(
+						sunxi_ahub_daudio->regmap,
+						SUNXI_AHUB_I2S_OUT_CH2MAP0(
+						sunxi_ahub_daudio->tdm_num),
+						0x76);
+				}
+				if (params_channels(params)  > 6)
+					regmap_write(sunxi_ahub_daudio->regmap,
+						SUNXI_AHUB_I2S_OUT_CH3MAP0(
+						sunxi_ahub_daudio->tdm_num),
+						0x54);
+				}
+			}
+
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT0(
+				sunxi_ahub_daudio->tdm_num),
+				(0x0f<<I2S_OUT_SLOT_NUM),
+				(0x01<<I2S_OUT_SLOT_NUM));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT0(
+				sunxi_ahub_daudio->tdm_num),
+				(0xffff<<I2S_OUT_SLOT_EN),
+				(0x03<<I2S_OUT_SLOT_EN));
+
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT1(
+				sunxi_ahub_daudio->tdm_num),
+				(0x0f<<I2S_OUT_SLOT_NUM),
+				(0x01<<I2S_OUT_SLOT_NUM));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT1(
+				sunxi_ahub_daudio->tdm_num),
+				(0xffff<<I2S_OUT_SLOT_EN),
+				(0x03<<I2S_OUT_SLOT_EN));
+
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT2(
+				sunxi_ahub_daudio->tdm_num),
+				(0x0f<<I2S_OUT_SLOT_NUM),
+				(0x01<<I2S_OUT_SLOT_NUM));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT2(
+				sunxi_ahub_daudio->tdm_num),
+				(0xffff<<I2S_OUT_SLOT_EN),
+				(0x03<<I2S_OUT_SLOT_EN));
+
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT3(
+				sunxi_ahub_daudio->tdm_num),
+				(0x0f<<I2S_OUT_SLOT_NUM),
+				(0x01<<I2S_OUT_SLOT_NUM));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT3(
+				sunxi_ahub_daudio->tdm_num),
+				(0xffff<<I2S_OUT_SLOT_EN),
+				(0x03<<I2S_OUT_SLOT_EN));
+		} else {
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT0(
+				sunxi_ahub_daudio->tdm_num),
+				(0x0f<<I2S_OUT_SLOT_NUM),
+			((params_channels(params)-1)<<I2S_OUT_SLOT_NUM));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT0(
+				sunxi_ahub_daudio->tdm_num),
+				(0xffff<<I2S_OUT_SLOT_EN),
+			(((1<<params_channels(params))-1)<<I2S_OUT_SLOT_EN));
+		}
+	} else {
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_CHCFG(sunxi_ahub_daudio->tdm_num),
+			(0xf<<I2S_CHCFG_RX_CHANNUM),
+			((params_channels(params)-1)<<I2S_CHCFG_RX_CHANNUM));
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_IN_SLOT(sunxi_ahub_daudio->tdm_num),
+			(0xf<<I2S_IN_SLOT_NUM),
+			((params_channels(params)-1)<<I2S_IN_SLOT_NUM));
+	}
+
+	return 0;
+}
+
+static int sunxi_ahub_daudio_set_sysclk(struct snd_soc_dai *dai,
+			int clk_id, unsigned int freq, int dir)
+{
+	struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio =
+					snd_soc_dai_get_drvdata(dai);
+
+	if (clk_set_rate(sunxi_ahub_daudio->clk_module, freq / 2)) {
+	        dev_err(sunxi_ahub_daudio->dev, "set clk_module rate failed\n");
+	        return -EINVAL;
+	}
+
+	if (clk_set_rate(sunxi_ahub_daudio->clk_audio_hub, freq / 2)) {
+	        dev_err(sunxi_ahub_daudio->dev, "set clk_audio_hub rate failed\n");
+	        return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sunxi_ahub_daudio_set_clkdiv(struct snd_soc_dai *dai,
+				int clk_id, int clk_div)
+{
+	struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio =
+					snd_soc_dai_get_drvdata(dai);
+	unsigned int bclk_div, div_ratio;	
+
+	if (sunxi_ahub_daudio->tdm_config)
+		/* I2S/TDM two channel mode */
+		div_ratio = clk_div / (sunxi_ahub_daudio->pcm_lrck_period * 2);
+	else
+		/* PCM mode */
+		div_ratio = clk_div / sunxi_ahub_daudio->pcm_lrck_period;
+
+	switch (div_ratio) {
+	case	1:
+		bclk_div = 1;
+		break;
+	case	2:
+		bclk_div = 2;
+		break;
+	case	4:
+		bclk_div = 3;
+		break;
+	case	6:
+		bclk_div = 4;
+		break;
+	case	8:
+		bclk_div = 5;
+		break;
+	case	12:
+		bclk_div = 6;
+		break;
+	case	16:
+		bclk_div = 7;
+		break;
+	case	24:
+		bclk_div = 8;
+		break;
+	case	32:
+		bclk_div = 9;
+		break;
+	case	48:
+		bclk_div = 10;
+		break;
+	case	64:
+		bclk_div = 11;
+		break;
+	case	96:
+		bclk_div = 12;
+		break;
+	case	128:
+		bclk_div = 13;
+		break;
+	case	176:
+		bclk_div = 14;
+		break;
+	case	192:
+		bclk_div = 15;
+		break;
+	default:
+		dev_err(sunxi_ahub_daudio->dev, "unsupport clk_div\n");
+		return -EINVAL;
+	}
+
+	/* setting bclk to driver external codec bit clk */
+	regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_CLKD(sunxi_ahub_daudio->tdm_num),
+			(0xf<<I2S_CLKD_BCLKDIV), (bclk_div<<I2S_CLKD_BCLKDIV));
+
+	return 0;
+}
+
+static int sunxi_ahub_daudio_trigger(struct snd_pcm_substream *substream,
+				int cmd, struct snd_soc_dai *dai)
+{
+ 	switch (cmd) {
+	case	SNDRV_PCM_TRIGGER_START:
+	case	SNDRV_PCM_TRIGGER_RESUME:
+	case	SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		break;
+	case	SNDRV_PCM_TRIGGER_STOP:
+	case	SNDRV_PCM_TRIGGER_SUSPEND:
+	case	SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			/* HMID module, we just keep this clk */
+		break;
+	default:
+		return -EINVAL;
+	}
+	
+	return 0;
+}
+
+static int sunxi_ahub_daudio_startup(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+ 	return 0;
+}
+
+static void sunxi_ahub_daudio_shutdown(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+}
+
+static struct snd_soc_dai_ops sunxi_ahub_cpu_dai_ops = {
+	.hw_params = sunxi_ahub_daudio_hw_params,
+	.set_sysclk = sunxi_ahub_daudio_set_sysclk,
+	.set_clkdiv = sunxi_ahub_daudio_set_clkdiv,
+	.set_fmt = sunxi_ahub_daudio_set_fmt,
+	.startup = sunxi_ahub_daudio_startup,
+	.trigger = sunxi_ahub_daudio_trigger,
+	.shutdown = sunxi_ahub_daudio_shutdown,
+};
+
+static int sunxi_ahub_daudio_probe(struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio =
+					snd_soc_dai_get_drvdata(dai);
+
+	mutex_init(&sunxi_ahub_daudio->mutex);
+	sunxi_ahub_daudio_init(sunxi_ahub_daudio, (sunxi_ahub_daudio->tdm_num));
+
+	return 0;
+}
+
+static int sunxi_ahub_daudio_remove(struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static struct snd_soc_dai_driver sunxi_ahub_daudio_mod = {
+	.probe = sunxi_ahub_daudio_probe,
+	.remove = sunxi_ahub_daudio_remove,		
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 16,
+		.rates = SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT,
+		.rate_min       = 8000,
+		.rate_max       = 192000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE
+			| SNDRV_PCM_FMTBIT_S24_LE
+			| SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 16,
+		.rates = SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT,
+		.rate_min       = 8000,
+		.rate_max       = 192000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE
+			| SNDRV_PCM_FMTBIT_S24_LE
+			| SNDRV_PCM_FMTBIT_S32_LE,
+	 },
+	.ops = &sunxi_ahub_cpu_dai_ops,
+};
+
+static const struct snd_soc_component_driver sunxi_ahub_daudio_component = {
+	.name		= DRV_NAME,
+};
+
+static int sunxi_ahub_daudio_dev_probe(struct platform_device *pdev)
+{
+	struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio;
+	struct device_node *np = pdev->dev.of_node;
+	unsigned int temp_val;
+	int ret;
+
+ 	sunxi_ahub_daudio = devm_kzalloc(&pdev->dev,
+			sizeof(struct sunxi_ahub_daudio_priv), GFP_KERNEL);
+	if (!sunxi_ahub_daudio) {
+		ret = -ENOMEM;
+		goto err_node_put;
+	}
+	
+	dev_set_drvdata(&pdev->dev, sunxi_ahub_daudio);
+	sunxi_ahub_daudio->dev = &pdev->dev;
+
+	sunxi_ahub_daudio->cpudai = devm_kzalloc(&pdev->dev,
+			sizeof(struct snd_soc_dai_driver), GFP_KERNEL);
+	if (!sunxi_ahub_daudio->cpudai) {
+		ret = -ENOMEM;
+		goto err_devm_kfree;
+	} else {
+		memcpy(sunxi_ahub_daudio->cpudai, &sunxi_ahub_daudio_mod,
+			sizeof(struct snd_soc_dai_driver));
+	}
+
+	/* Get the clocks from the DT */
+	sunxi_ahub_daudio->clk_apb = devm_clk_get(&pdev->dev, "apb");
+	if (IS_ERR(sunxi_ahub_daudio->clk_apb)) {
+	        dev_err(&pdev->dev, "Failed to get the APB clock\n");
+	        return PTR_ERR(sunxi_ahub_daudio->clk_apb);
+	}
+
+	sunxi_ahub_daudio->clk_module = devm_clk_get(&pdev->dev, "audio-codec-1x");
+	if (IS_ERR(sunxi_ahub_daudio->clk_module)) {
+	        dev_err(&pdev->dev, "Failed to get the codec module clock\n");
+	        return PTR_ERR(sunxi_ahub_daudio->clk_module);
+	}
+
+	sunxi_ahub_daudio->clk_audio_hub = devm_clk_get(&pdev->dev, "audio-hub");
+	if (IS_ERR(sunxi_ahub_daudio->clk_module)) {
+	        dev_err(&pdev->dev, "Failed to get the audio hub clock\n");
+	        return PTR_ERR(sunxi_ahub_daudio->clk_module);
+	}
+
+	/* Enable the bus clock */
+	if (clk_prepare_enable(sunxi_ahub_daudio->clk_apb)) {
+	        dev_err(&pdev->dev, "Failed to enable the APB clock\n");
+	        return -EINVAL;
+	}
+
+	if (clk_prepare_enable(sunxi_ahub_daudio->clk_module)) {
+	        dev_err(&pdev->dev, "Failed to enable the ahub module clock\n");
+	        return -EINVAL;
+	}
+
+	if (clk_prepare_enable(sunxi_ahub_daudio->clk_audio_hub)) {
+	        dev_err(&pdev->dev, "Failed to enable the ahdio hub clock\n");
+	        return -EINVAL;
+	}
+
+	ret = of_property_read_u32(np, "tdm_num", &temp_val);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "tdm_num configuration invalid\n");
+		goto err_clk_disable;
+	} else {
+		sunxi_ahub_daudio->tdm_num = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "pinconfig", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "pinconfig configuration invalid\n");
+		sunxi_ahub_daudio->pinconfig = 0;
+	} else {
+		sunxi_ahub_daudio->pinconfig = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "frametype", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "frametype configuration invalid\n");
+		sunxi_ahub_daudio->frame_type = 0;
+	} else {
+		sunxi_ahub_daudio->frame_type = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "daudio_master", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "daudio_master configuration invalid\n");
+		sunxi_ahub_daudio->daudio_master = 4;
+	} else {
+		sunxi_ahub_daudio->daudio_master = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "pcm_lrck_period", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "pcm_lrck_period configuration invalid\n");
+		sunxi_ahub_daudio->pcm_lrck_period = 0;
+	} else {
+		sunxi_ahub_daudio->pcm_lrck_period = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "slot_width_select", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "slot_width_select configuration inval\n");
+		sunxi_ahub_daudio->slot_width_select = 0;
+	} else {
+		sunxi_ahub_daudio->slot_width_select = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "audio_format", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "audio_format configuration invalid\n");
+		sunxi_ahub_daudio->audio_format = 1;
+	} else {
+		sunxi_ahub_daudio->audio_format = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "signal_inversion", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "signal_inversion configuration inval\n");
+		sunxi_ahub_daudio->signal_inversion = 1;
+	} else {
+		sunxi_ahub_daudio->signal_inversion = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "tdm_config", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "tdm_config configuration invalid\n");
+		sunxi_ahub_daudio->tdm_config = 1;
+	} else {
+		sunxi_ahub_daudio->tdm_config = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "mclk_div", &temp_val);
+	if (ret < 0)
+		sunxi_ahub_daudio->mclk_div = 0;
+	else
+		sunxi_ahub_daudio->mclk_div = temp_val;
+
+	sunxi_ahub_daudio->regmap = sunxi_ahub_regmap_init(pdev);
+	if (!sunxi_ahub_daudio->regmap) {
+		dev_err(&pdev->dev, "regmap not init ok\n");
+		ret = -ENOMEM;
+		goto err_clk_disable;
+	}
+
+	/* diff handle for dais  even we use tdm_num as dai id  ----->roy */
+	sunxi_ahub_daudio->cpudai->id = sunxi_ahub_daudio->tdm_num;
+	sprintf(sunxi_ahub_daudio->cpudai_name, "sunxi-ahub-cpu-aif%d",
+					sunxi_ahub_daudio->tdm_num);
+	sunxi_ahub_daudio->cpudai->name = sunxi_ahub_daudio->cpudai_name;
+
+	ret = snd_soc_register_component(&pdev->dev,
+			&sunxi_ahub_daudio_component,
+			sunxi_ahub_daudio->cpudai, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
+		ret = -EBUSY;
+		goto err_clk_disable;
+	}
+	return 0;
+
+err_devm_kfree:
+	devm_kfree(&pdev->dev, sunxi_ahub_daudio);
+
+err_node_put:
+	of_node_put(np);
+
+err_clk_disable:
+	clk_disable_unprepare(sunxi_ahub_daudio->clk_apb);
+	clk_disable_unprepare(sunxi_ahub_daudio->clk_module);
+	clk_disable_unprepare(sunxi_ahub_daudio->clk_audio_hub);
+
+	return ret;
+}
+
+static int __exit sunxi_ahub_daudio_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio =
+				dev_get_drvdata(&pdev->dev);
+
+	snd_soc_unregister_component(&pdev->dev);	
+
+	clk_put(sunxi_ahub_daudio->clk_apb);
+	clk_put(sunxi_ahub_daudio->clk_module);
+	clk_put(sunxi_ahub_daudio->clk_audio_hub);
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_ahub_daudio_of_match[] = {
+	{ .compatible = "allwinner,sunxi-ahub-daudio", },
+	{},
+};
+
+static struct platform_driver sunxi_ahub_daudio_driver = {
+	.probe = sunxi_ahub_daudio_dev_probe,
+	.remove = __exit_p(sunxi_ahub_daudio_dev_remove),
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_ahub_daudio_of_match,
+	},
+};
+
+module_platform_driver(sunxi_ahub_daudio_driver);
+
+MODULE_DESCRIPTION("SUNXI Audio Hub ASoC Interface");
+MODULE_AUTHOR("wolfgang huang <huangjinhui@allwinnertech.com>");
+MODULE_AUTHOR("Leeboby <leeboby@aliyun.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-ahub");
diff --git a/sound/soc/sunxi/sun50i-ahub.c b/sound/soc/sunxi/sun50i-ahub.c
new file mode 100644
index 000000000..02c81ab51
--- /dev/null
+++ b/sound/soc/sunxi/sun50i-ahub.c
@@ -0,0 +1,1048 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * (C) Copyright 2015-2017
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Wolfgang huang <huangjinhui@allwinnertechtech.com>
+ *
+ * (C) Copyright 2021
+ * Shenzhen Xunlong Software Co., Ltd. <www.orangepi.org>
+ * Leeboby <leeboby@aliyun.com>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/regulator/consumer.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/pm.h>
+#include <linux/of_gpio.h>
+#include <linux/workqueue.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+#include <linux/reset.h>
+
+#include "sun50i_ahub.h"
+
+#define DRV_NAME "sunxi-ahub"
+
+struct sunxi_ahub_priv {
+	struct device *dev;
+	void __iomem *membase;
+	struct regmap *regmap;
+	struct clk *clk_apb;
+	struct clk *clk_module;
+	struct clk *clk_audio_hub;
+	struct reset_control *rst;
+} sunxi_ahub_dev;
+
+static struct sunxi_ahub_priv *sunxi_ahub = &sunxi_ahub_dev;
+
+static const struct regmap_config sunxi_ahub_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_AHUB_DAM_GAIN_CTL7(1),
+	.cache_type = REGCACHE_NONE,
+};
+
+unsigned int sunxi_ahub_read(unsigned int reg)
+{
+	return readl(sunxi_ahub->membase + reg);
+}
+EXPORT_SYMBOL_GPL(sunxi_ahub_read);
+
+/* reslove conflict with regmap_update_bits using spin_lock */
+int sunxi_ahub_update_bits(
+					unsigned int reg,
+			       unsigned int mask, unsigned int val)
+{
+	unsigned int tmp, orig;
+
+	orig = readl(sunxi_ahub->membase + reg);
+
+	tmp = orig & ~mask;
+	tmp |= val & mask;
+
+	if (tmp != orig)
+		writel(tmp, sunxi_ahub->membase + reg);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sunxi_ahub_update_bits);
+
+struct regmap *sunxi_ahub_regmap_init(struct platform_device *pdev)
+{
+	struct resource res, *memregion;
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+
+	if (!sunxi_ahub->regmap) {
+		ret = of_address_to_resource(np, 0, &res);
+		if (ret)
+			return NULL;
+
+		memregion = devm_request_mem_region(&pdev->dev, res.start,
+						resource_size(&res), DRV_NAME);
+		if (!memregion)
+			return NULL;
+
+		sunxi_ahub->membase = ioremap(res.start, resource_size(&res));
+		if (!sunxi_ahub->membase)
+			return NULL;
+
+		sunxi_ahub->regmap = devm_regmap_init_mmio(&pdev->dev,
+						sunxi_ahub->membase,
+						&sunxi_ahub_regmap_config);
+		if (IS_ERR_OR_NULL(sunxi_ahub->regmap)) {
+			ret = PTR_ERR(sunxi_ahub->regmap);
+			return NULL;
+		}
+	}
+	return sunxi_ahub->regmap;
+}
+EXPORT_SYMBOL_GPL(sunxi_ahub_regmap_init);
+
+static const char * const apbif_mux_text[] = {
+	"NONE",
+	"APBIF_TXDIF0",
+	"APBIF_TXDIF1",
+	"APBIF_TXDIF2",
+	"I2S0_TXDIF",
+	"I2S1_TXDIF",
+	"I2S2_TXDIF",
+	"I2S3_TXDIF",
+	"DAM0_TXDIF",
+	"DAM1_TXDIF",
+};
+
+static const unsigned int apbif_mux_values[] = {
+	0,
+	1<<I2S_RX_APBIF_TXDIF0,
+	1<<I2S_RX_APBIF_TXDIF1,
+	1<<I2S_RX_APBIF_TXDIF2,
+	1<<I2S_RX_I2S0_TXDIF,
+	1<<I2S_RX_I2S1_TXDIF,
+	1<<I2S_RX_I2S2_TXDIF,
+	1<<I2S_RX_I2S3_TXDIF,
+	1<<I2S_RX_DAM0_TXDIF,
+	1<<I2S_RX_DAM1_TXDIF,
+};
+
+#define AHUB_MUX_ENUM_DECL(name, reg)	\
+	SOC_VALUE_ENUM_SINGLE_DECL(name, reg, 0, 0xffffffff,	\
+			apbif_mux_text, apbif_mux_values)
+
+static AHUB_MUX_ENUM_DECL(apbif0, SUNXI_AHUB_APBIF_RXFIFO_CONT(0));
+static AHUB_MUX_ENUM_DECL(apbif1, SUNXI_AHUB_APBIF_RXFIFO_CONT(1));
+static AHUB_MUX_ENUM_DECL(apbif2, SUNXI_AHUB_APBIF_RXFIFO_CONT(2));
+static AHUB_MUX_ENUM_DECL(i2s0, SUNXI_AHUB_I2S_RXCONT(0));
+static AHUB_MUX_ENUM_DECL(i2s1, SUNXI_AHUB_I2S_RXCONT(1));
+static AHUB_MUX_ENUM_DECL(i2s2, SUNXI_AHUB_I2S_RXCONT(2));
+static AHUB_MUX_ENUM_DECL(i2s3, SUNXI_AHUB_I2S_RXCONT(3));
+static AHUB_MUX_ENUM_DECL(dam0chan0, SUNXI_AHUB_DAM_RX0_SRC(0));
+static AHUB_MUX_ENUM_DECL(dam0chan1, SUNXI_AHUB_DAM_RX1_SRC(0));
+static AHUB_MUX_ENUM_DECL(dam0chan2, SUNXI_AHUB_DAM_RX2_SRC(0));
+static AHUB_MUX_ENUM_DECL(dam1chan0, SUNXI_AHUB_DAM_RX0_SRC(1));
+static AHUB_MUX_ENUM_DECL(dam1chan1, SUNXI_AHUB_DAM_RX1_SRC(1));
+static AHUB_MUX_ENUM_DECL(dam1chan2, SUNXI_AHUB_DAM_RX2_SRC(1));
+
+#define APBIF_RX_MUX_CONTROLS(num)					\
+static const struct snd_kcontrol_new apbif##num##_rx_mux =		\
+	SOC_DAPM_ENUM("APBIF##num Rx Mux", apbif##num);
+
+#define I2S_RX_MUX_CONTROLS(num)					\
+static const struct snd_kcontrol_new i2s##num##_rx_mux =		\
+	SOC_DAPM_ENUM("I2S##num RX Mux", i2s##num);
+
+#define DAM0_RX_MUX_CONTROLS(chan)					\
+static const struct snd_kcontrol_new  dam0chan##chan##_rx_mux =		\
+	SOC_DAPM_ENUM("DAM0 Chan##chan Rx Mux", dam0chan##chan);
+#define DAM1_RX_MUX_CONTROLS(chan)                                       \
+static const struct snd_kcontrol_new dam1chan##chan##_rx_mux =           \
+	SOC_DAPM_ENUM("DAM1 Chan##chan Rx Mux", dam1chan##chan);
+
+#define AHUB_MUX(name, ctrl) \
+	SND_SOC_DAPM_MUX(name, SND_SOC_NOPM, 0, 0, &ctrl)
+
+#define AHUB_MUX_DAM0(name, ctrl, ch) \
+	SND_SOC_DAPM_MUX(name, \
+	SUNXI_AHUB_DAM_CTL(0), DAM_CTL_RX0EN+ch, 0, &ctrl)
+
+#define AHUB_MUX_DAM1(name, ctrl, ch) \
+	SND_SOC_DAPM_MUX(name, \
+	SUNXI_AHUB_DAM_CTL(1), DAM_CTL_RX0EN+ch, 0, &ctrl)
+
+/*three apbif dev group */
+APBIF_RX_MUX_CONTROLS(0)
+APBIF_RX_MUX_CONTROLS(1)
+APBIF_RX_MUX_CONTROLS(2)
+/* four i2s dev group */
+I2S_RX_MUX_CONTROLS(0)
+I2S_RX_MUX_CONTROLS(1)
+I2S_RX_MUX_CONTROLS(2)
+I2S_RX_MUX_CONTROLS(3)
+/* two digital audio mux & three chan dev group */
+DAM0_RX_MUX_CONTROLS(0)
+DAM0_RX_MUX_CONTROLS(1)
+DAM0_RX_MUX_CONTROLS(2)
+DAM1_RX_MUX_CONTROLS(0)
+DAM1_RX_MUX_CONTROLS(1)
+DAM1_RX_MUX_CONTROLS(2)
+
+struct str_conv {
+	char *str;
+	int regbit;
+};
+
+/* I2S module usage control by cpu_dai */
+static struct str_conv mod_str_conv[] = {
+	{"APBIF0 DAC", 31},
+	{"APBIF1 DAC", 30},
+	{"APBIF2 DAC", 29},
+	{"APBIF0 ADC", 27},
+	{"APBIF1 ADC", 26},
+	{"APBIF2 ADC", 25},
+	{"DAM0 Mixer", 15},
+	{"DAM1 Mixer", 14},
+};
+
+static int sunxi_ahub_mod_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_ahub_priv *sunxi_ahub = snd_soc_component_get_drvdata(component);
+	int reg_bit = 0;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mod_str_conv); i++)
+		if (!strncmp(mod_str_conv[i].str, w->name,
+					strlen(mod_str_conv[i].str))) {
+			reg_bit = mod_str_conv[i].regbit;
+			break;
+		}
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_RST,
+				(0x1<<reg_bit), (0x1<<reg_bit));
+		regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_GAT,
+				(0x1<<reg_bit), (0x1<<reg_bit));
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_GAT,
+				(0x1<<reg_bit), (0x0<<reg_bit));
+		regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_RST,
+				(0x1<<reg_bit), (0x0<<reg_bit));
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static const struct snd_kcontrol_new ahub_controls[] = {
+#ifdef LOOPBACK_FOR_DAUDIO
+	//Loopback test:SDO0 --> SDI0 1 2 3 --> Enable
+	SOC_SINGLE("I2S0 SD0 to SDI0 Loopback Debug", SUNXI_AHUB_I2S_CTL(0), I2S_CTL_LOOP0, 1, 0),
+	SOC_SINGLE("I2S0 SD0 to SDI1 Loopback Debug", SUNXI_AHUB_I2S_CTL(0), I2S_CTL_LOOP1, 1, 0),
+	SOC_SINGLE("I2S0 SD0 to SDI2 Loopback Debug", SUNXI_AHUB_I2S_CTL(0), I2S_CTL_LOOP2, 1, 0),
+	SOC_SINGLE("I2S0 SD0 to SDI3 Loopback Debug", SUNXI_AHUB_I2S_CTL(0), I2S_CTL_LOOP3, 1, 0),
+	SOC_SINGLE("I2S0 SDI0 Enable", SUNXI_AHUB_I2S_CTL(0), I2S_CTL_SDI0_EN, 1, 0),
+	SOC_SINGLE("I2S0 SDI1 Enable", SUNXI_AHUB_I2S_CTL(0), I2S_CTL_SDI1_EN, 1, 0),
+	SOC_SINGLE("I2S0 SDI2 Enable", SUNXI_AHUB_I2S_CTL(0), I2S_CTL_SDI2_EN, 1, 0),
+	SOC_SINGLE("I2S0 SDI3 Enable", SUNXI_AHUB_I2S_CTL(0), I2S_CTL_SDI3_EN, 1, 0),
+	//Loopback test:SDO0 --> SDI0 1 2 3 --> Enable
+	SOC_SINGLE("I2S1 SD0 to SDI0 Loopback Debug", SUNXI_AHUB_I2S_CTL(1), I2S_CTL_LOOP0, 1, 0),
+	SOC_SINGLE("I2S1 SD0 to SDI1 Loopback Debug", SUNXI_AHUB_I2S_CTL(1), I2S_CTL_LOOP1, 1, 0),
+	SOC_SINGLE("I2S1 SD0 to SDI2 Loopback Debug", SUNXI_AHUB_I2S_CTL(1), I2S_CTL_LOOP2, 1, 0),
+	SOC_SINGLE("I2S1 SD0 to SDI3 Loopback Debug", SUNXI_AHUB_I2S_CTL(1), I2S_CTL_LOOP3, 1, 0),
+	SOC_SINGLE("I2S1 SDI0 Enable", SUNXI_AHUB_I2S_CTL(1), I2S_CTL_SDI0_EN, 1, 0),
+	SOC_SINGLE("I2S1 SDI1 Enable", SUNXI_AHUB_I2S_CTL(1), I2S_CTL_SDI1_EN, 1, 0),
+	SOC_SINGLE("I2S1 SDI2 Enable", SUNXI_AHUB_I2S_CTL(1), I2S_CTL_SDI2_EN, 1, 0),
+	SOC_SINGLE("I2S1 SDI3 Enable", SUNXI_AHUB_I2S_CTL(1), I2S_CTL_SDI3_EN, 1, 0),
+	//Loopback test:SDO0 --> SDI0 1 2 3 --> Enable
+	SOC_SINGLE("I2S2 SD0 to SDI0 Loopback Debug", SUNXI_AHUB_I2S_CTL(2), I2S_CTL_LOOP0, 1, 0),
+	SOC_SINGLE("I2S2 SD0 to SDI1 Loopback Debug", SUNXI_AHUB_I2S_CTL(2), I2S_CTL_LOOP1, 1, 0),
+	SOC_SINGLE("I2S2 SD0 to SDI2 Loopback Debug", SUNXI_AHUB_I2S_CTL(2), I2S_CTL_LOOP2, 1, 0),
+	SOC_SINGLE("I2S2 SD0 to SDI3 Loopback Debug", SUNXI_AHUB_I2S_CTL(2), I2S_CTL_LOOP3, 1, 0),
+	SOC_SINGLE("I2S2 SDI0 Enable", SUNXI_AHUB_I2S_CTL(2), I2S_CTL_SDI0_EN, 1, 0),
+	SOC_SINGLE("I2S2 SDI1 Enable", SUNXI_AHUB_I2S_CTL(2), I2S_CTL_SDI1_EN, 1, 0),
+	SOC_SINGLE("I2S2 SDI2 Enable", SUNXI_AHUB_I2S_CTL(2), I2S_CTL_SDI2_EN, 1, 0),
+	SOC_SINGLE("I2S2 SDI3 Enable", SUNXI_AHUB_I2S_CTL(2), I2S_CTL_SDI3_EN, 1, 0),
+	//Loopback test:SDO0 --> SDI0 1 2 3 --> Enable
+	SOC_SINGLE("I2S3 SD0 to SDI0 Loopback Debug", SUNXI_AHUB_I2S_CTL(3), I2S_CTL_LOOP0, 1, 0),
+	SOC_SINGLE("I2S3 SD0 to SDI1 Loopback Debug", SUNXI_AHUB_I2S_CTL(3), I2S_CTL_LOOP1, 1, 0),
+	SOC_SINGLE("I2S3 SD0 to SDI2 Loopback Debug", SUNXI_AHUB_I2S_CTL(3), I2S_CTL_LOOP2, 1, 0),
+	SOC_SINGLE("I2S3 SD0 to SDI3 Loopback Debug", SUNXI_AHUB_I2S_CTL(3), I2S_CTL_LOOP3, 1, 0),
+	SOC_SINGLE("I2S3 SDI0 Enable", SUNXI_AHUB_I2S_CTL(3), I2S_CTL_SDI0_EN, 1, 0),
+	SOC_SINGLE("I2S3 SDI1 Enable", SUNXI_AHUB_I2S_CTL(3), I2S_CTL_SDI1_EN, 1, 0),
+	SOC_SINGLE("I2S3 SDI2 Enable", SUNXI_AHUB_I2S_CTL(3), I2S_CTL_SDI2_EN, 1, 0),
+	SOC_SINGLE("I2S3 SDI3 Enable", SUNXI_AHUB_I2S_CTL(3), I2S_CTL_SDI3_EN, 1, 0),
+
+	SOC_SINGLE("I2S3 SDO0 Enable", SUNXI_AHUB_I2S_CTL(3), I2S_CTL_SDO0_EN, 1, 0),
+	SOC_SINGLE("I2S3 SDO1 Enable", SUNXI_AHUB_I2S_CTL(3), I2S_CTL_SDO1_EN, 1, 0),
+	SOC_SINGLE("I2S3 SDO2 Enable", SUNXI_AHUB_I2S_CTL(3), I2S_CTL_SDO2_EN, 1, 0),
+	SOC_SINGLE("I2S3 SDO3 Enable", SUNXI_AHUB_I2S_CTL(3), I2S_CTL_SDO3_EN, 1, 0),
+
+#elif defined(CONFIG_ARCH_SUN50IW6)
+	SOC_SINGLE("I2S0 Loopback Debug", SUNXI_AHUB_I2S_CTL(0), I2S_CTL_LOOP, 1, 0),
+	SOC_SINGLE("I2S1 Loopback Debug", SUNXI_AHUB_I2S_CTL(1), I2S_CTL_LOOP, 1, 0),
+	SOC_SINGLE("I2S2 Loopback Debug", SUNXI_AHUB_I2S_CTL(2), I2S_CTL_LOOP, 1, 0),
+	SOC_SINGLE("I2S3 Loopback Debug", SUNXI_AHUB_I2S_CTL(3), I2S_CTL_LOOP, 1, 0),
+#endif
+};
+
+static const struct snd_soc_dapm_widget sunxi_ahub_codec_dapm_widgets[] = {
+	/* APBIF module output & input widgets */
+	SND_SOC_DAPM_AIF_IN_E("APBIF0 DAC", "AIF1 Playback", 0,
+			SND_SOC_NOPM, 0, 0,
+			sunxi_ahub_mod_event,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_AIF_OUT_E("APBIF0 ADC", "AIF1 Capture", 0,
+			SND_SOC_NOPM, 0, 0,
+			sunxi_ahub_mod_event,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_AIF_IN_E("APBIF1 DAC", "AIF2 Playback", 0,
+			SND_SOC_NOPM, 0, 0,
+			sunxi_ahub_mod_event,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_AIF_OUT_E("APBIF1 ADC", "AIF2 Capture", 0,
+			SND_SOC_NOPM, 0, 0,
+			sunxi_ahub_mod_event,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_AIF_IN_E("APBIF2 DAC", "AIF3 Playback", 0,
+			SND_SOC_NOPM, 0, 0,
+			sunxi_ahub_mod_event,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_AIF_OUT_E("APBIF2 ADC", "AIF3 Capture", 0,
+			SND_SOC_NOPM, 0, 0,
+			sunxi_ahub_mod_event,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+
+	AHUB_MUX("APBIF0 Src Select", apbif0_rx_mux),
+	AHUB_MUX("APBIF1 Src Select", apbif1_rx_mux),
+	AHUB_MUX("APBIF2 Src Select", apbif2_rx_mux),
+	AHUB_MUX("I2S0 Src Select", i2s0_rx_mux),
+	AHUB_MUX("I2S1 Src Select", i2s1_rx_mux),
+	AHUB_MUX("I2S2 Src Select", i2s2_rx_mux),
+	AHUB_MUX("I2S3 Src Select", i2s3_rx_mux),
+	AHUB_MUX_DAM0("DAM0Chan0 Src Select", dam0chan0_rx_mux, 0),
+	AHUB_MUX_DAM0("DAM0Chan1 Src Select", dam0chan1_rx_mux, 1),
+	AHUB_MUX_DAM0("DAM0Chan2 Src Select", dam0chan2_rx_mux, 2),
+	AHUB_MUX_DAM1("DAM1Chan0 Src Select", dam1chan0_rx_mux, 0),
+	AHUB_MUX_DAM1("DAM1Chan1 Src Select", dam1chan1_rx_mux, 1),
+	AHUB_MUX_DAM1("DAM1Chan2 Src Select", dam1chan2_rx_mux, 2),
+
+
+	SND_SOC_DAPM_OUT_DRV_E("DAM0 Mixer", SUNXI_AHUB_DAM_CTL(0),
+			DAM_CTL_TXEN, 0, NULL, 0, sunxi_ahub_mod_event,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_OUT_DRV_E("DAM1 Mixer", SUNXI_AHUB_DAM_CTL(1),
+			DAM_CTL_TXEN, 0, NULL, 0, sunxi_ahub_mod_event,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_INPUT("I2S0 DAC"),
+	SND_SOC_DAPM_INPUT("I2S1 DAC"),
+	SND_SOC_DAPM_INPUT("I2S2 DAC"),
+	SND_SOC_DAPM_INPUT("I2S3 DAC"),
+	SND_SOC_DAPM_OUTPUT("I2S0 ADC"),
+	SND_SOC_DAPM_OUTPUT("I2S1 ADC"),
+	SND_SOC_DAPM_OUTPUT("I2S2 ADC"),
+	SND_SOC_DAPM_OUTPUT("I2S3 ADC"),
+	/*build some virt widget for dam*/
+	SND_SOC_DAPM_OUTPUT("DAM0 OUTPUT"),
+	SND_SOC_DAPM_OUTPUT("DAM1 OUTPUT"),
+	SND_SOC_DAPM_INPUT("DAM0 INPUT"),
+	SND_SOC_DAPM_INPUT("DAM1 INPUT"),
+};
+
+static const struct snd_soc_dapm_route sunxi_ahub_codec_dapm_routes[] = {
+	/* APBIF0 from DMA to RX Mux routes */
+	{"APBIF0 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"APBIF1 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"APBIF2 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+
+	{"I2S0 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"I2S1 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"I2S2 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"I2S3 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+
+	{"DAM0Chan0 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"DAM0Chan1 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"DAM0Chan2 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"DAM1Chan0 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"DAM1Chan1 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"DAM1Chan2 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+
+	/* APBIF1 from DMA to RX Mux routes */
+	{"APBIF0 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"APBIF1 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"APBIF2 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+
+	{"I2S0 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"I2S1 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"I2S2 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"I2S3 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+
+	{"DAM0Chan0 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"DAM0Chan1 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"DAM0Chan2 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"DAM1Chan0 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"DAM1Chan1 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"DAM1Chan2 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+
+	/* APBIF2 from DMA to RX Mux routes */
+	{"APBIF0 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"APBIF1 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"APBIF2 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+
+	{"I2S0 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"I2S1 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"I2S2 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"I2S3 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+
+	{"DAM0Chan0 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"DAM0Chan1 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"DAM0Chan2 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"DAM1Chan0 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"DAM1Chan1 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"DAM1Chan2 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+
+	/* I2S0 to RX Mux routes */
+	{"APBIF0 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"APBIF1 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"APBIF2 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+
+	{"I2S0 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"I2S1 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"I2S2 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"I2S3 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+
+	{"DAM0Chan0 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"DAM0Chan1 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"DAM0Chan2 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"DAM1Chan0 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"DAM1Chan1 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"DAM1Chan2 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+
+	/* I2S1 to RX Mux routes */
+	{"APBIF0 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"APBIF1 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"APBIF2 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+
+	{"I2S0 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"I2S1 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"I2S2 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"I2S3 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+
+	{"DAM0Chan0 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"DAM0Chan1 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"DAM0Chan2 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"DAM1Chan0 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"DAM1Chan1 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"DAM1Chan2 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+
+	/* I2S2 to RX Mux routes */
+	{"APBIF0 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"APBIF1 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"APBIF2 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+
+	{"I2S0 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"I2S1 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"I2S2 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"I2S3 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+
+	{"DAM0Chan0 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"DAM0Chan1 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"DAM0Chan2 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"DAM1Chan0 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"DAM1Chan1 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"DAM1Chan2 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+
+	/* I2S3 to RX Mux routes */
+	{"APBIF0 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"APBIF1 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"APBIF2 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+
+	{"I2S0 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"I2S1 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"I2S2 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"I2S3 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+
+	{"DAM0Chan0 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"DAM0Chan1 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"DAM0Chan2 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"DAM1Chan0 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"DAM1Chan1 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"DAM1Chan2 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	
+	/* DAM0 Audio Mixer output route */
+	{"APBIF0 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"APBIF1 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"APBIF2 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+
+	{"I2S0 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"I2S1 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"I2S2 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"I2S3 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+
+	{"DAM0Chan0 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"DAM0Chan1 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"DAM0Chan2 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"DAM1Chan0 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"DAM1Chan1 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"DAM1Chan2 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+
+	/* DAM1 Audio Mixer output route */
+	{"APBIF0 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"APBIF1 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"APBIF2 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+
+	{"I2S0 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"I2S1 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"I2S2 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"I2S3 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+
+	{"DAM0Chan0 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"DAM0Chan1 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"DAM0Chan2 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"DAM1Chan0 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"DAM1Chan1 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"DAM1Chan2 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+
+	/* Mixer to APBIF Capture */
+	{"APBIF0 ADC", NULL, "APBIF0 Src Select"},
+	{"APBIF1 ADC", NULL, "APBIF1 Src Select"},
+	{"APBIF2 ADC", NULL, "APBIF2 Src Select"},
+
+	/* Mixer to I2S OUT(as ahub side says) */
+	{"I2S0 ADC", NULL, "I2S0 Src Select"},
+	{"I2S1 ADC", NULL, "I2S1 Src Select"},
+	{"I2S2 ADC", NULL, "I2S2 Src Select"},
+	{"I2S3 ADC", NULL, "I2S3 Src Select"},
+
+	{"DAM0 Mixer", NULL, "DAM0 INPUT"},
+	{"DAM1 Mixer", NULL, "DAM1 INPUT"},
+
+	{"DAM0 OUTPUT", NULL, "DAM0Chan0 Src Select"},
+	{"DAM0 OUTPUT", NULL, "DAM0Chan1 Src Select"},
+	{"DAM0 OUTPUT", NULL, "DAM0Chan2 Src Select"},
+
+	{"DAM1 OUTPUT", NULL, "DAM1Chan0 Src Select"},
+	{"DAM1 OUTPUT", NULL, "DAM1Chan1 Src Select"},
+	{"DAM1 OUTPUT", NULL, "DAM1Chan2 Src Select"},
+};
+
+static void sunxi_ahub_codec_init(struct snd_soc_component *component)
+{
+	struct sunxi_ahub_priv *sunxi_ahub = snd_soc_component_get_drvdata(component);
+	int i;
+
+	/* if we used the audio hub, so we default setting HDMI clk from ahub */
+	regmap_write(sunxi_ahub->regmap, SUNXI_AHUB_CTL, 1<<HDMI_SRC_SEL);
+
+	for (i = 0; i < 2; i++) {
+		/* setting audio hub default channel line configure */
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_MIX_CTL0(i), 0x01110000);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_MIX_CTL1(i), 0x03330222);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_MIX_CTL2(i), 0x05550444);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_MIX_CTL3(i), 0x07770666);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_MIX_CTL4(i), 0x09990888);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_MIX_CTL5(i), 0x0bbb0aaa);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_MIX_CTL6(i), 0x0ddd0ccc);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_MIX_CTL7(i), 0x0fff0eee);
+		/* setting default audio hub volume */
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_GAIN_CTL0(i), 0x01110111);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_GAIN_CTL1(i), 0x01110111);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_GAIN_CTL2(i), 0x01110111);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_GAIN_CTL3(i), 0x01110111);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_GAIN_CTL4(i), 0x01110111);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_GAIN_CTL5(i), 0x01110111);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_GAIN_CTL6(i), 0x01110111);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_GAIN_CTL7(i), 0x01110111);
+	}
+}
+
+static int sunxi_ahub_codec_dai_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_priv *sunxi_ahub = snd_soc_dai_get_drvdata(dai);
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_card *card = rtd->card;
+
+	switch (params_format(params)) {
+	case	SNDRV_PCM_FORMAT_S16_LE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			/* special handle for HDMI rawdata mode */
+			//if (sunxi_hdmi->hdmi_format > 1) {
+			if (0) {
+				regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_TX_CTL(dai->id),
+					(7<<APBIF_TX_WS), (7<<APBIF_TX_WS));
+				regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_TXFIFO_CTL(dai->id),
+					(1<<APBIF_TX_TXIM), (0<<APBIF_TX_TXIM));
+			} else {
+				regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_TX_CTL(dai->id),
+					(7<<APBIF_TX_WS), (3<<APBIF_TX_WS));
+				regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_TXFIFO_CTL(dai->id),
+					(1<<APBIF_TX_TXIM), (1<<APBIF_TX_TXIM));
+			}
+		} else {
+			regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_RX_CTL(dai->id),
+					(7<<APBIF_RX_WS), (3<<APBIF_RX_WS));
+			regmap_update_bits(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_RXFIFO_CTL(dai->id),
+				(3<<APBIF_RX_RXOM), (1<<APBIF_RX_RXOM));
+		}
+		break;
+	case	SNDRV_PCM_FORMAT_S24_LE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_TX_CTL(dai->id),
+					(7<<APBIF_TX_WS), (5<<APBIF_TX_WS));
+			regmap_update_bits(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_TXFIFO_CTL(dai->id),
+				(1<<APBIF_TX_TXIM), (1<<APBIF_TX_TXIM));
+		} else {
+			regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_RX_CTL(dai->id),
+					(7<<APBIF_RX_WS), (5<<APBIF_RX_WS));
+			regmap_update_bits(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_RXFIFO_CTL(dai->id),
+				(3<<APBIF_RX_RXOM), (1<<APBIF_RX_RXOM));
+		}
+		break;
+	case	SNDRV_PCM_FORMAT_S32_LE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_TX_CTL(dai->id),
+					(7<<APBIF_TX_WS), (7<<APBIF_TX_WS));
+			regmap_update_bits(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_TXFIFO_CTL(dai->id),
+				(1<<APBIF_TX_TXIM), (1<<APBIF_TX_TXIM));
+		} else {
+			regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_RX_CTL(dai->id),
+					(7<<APBIF_RX_WS), (7<<APBIF_RX_WS));
+			regmap_update_bits(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_RXFIFO_CTL(dai->id),
+				(3<<APBIF_RX_RXOM), (1<<APBIF_RX_RXOM));
+		}
+		break;
+	default:
+		dev_info(sunxi_ahub->dev, "unsupport format");
+		return -EINVAL;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		regmap_update_bits(sunxi_ahub->regmap,
+			SUNXI_AHUB_APBIF_TX_CTL(dai->id),
+			(0xf<<APBIF_TX_CHAN_NUM),
+			((params_channels(params)-1)<<APBIF_TX_CHAN_NUM));
+	else
+		regmap_update_bits(sunxi_ahub->regmap,
+			SUNXI_AHUB_APBIF_RX_CTL(dai->id),
+			(0xf<<APBIF_RX_CHAN_NUM),
+			((params_channels(params)-1)<<APBIF_RX_CHAN_NUM));
+
+	/*
+	 * we should using this as the demand chans, but we can't distinguish
+	 * stream type(playback or capture). so we can't make it done on demand,
+	 * so we just make all dam rx channel number as the sunxi_ahub->channel.
+	 */
+	regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_DAM_CTL(0),
+			(0xf<<DAM_CTL_RX0_NUM),
+			((params_channels(params)-1)<<DAM_CTL_RX0_NUM));
+	regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_DAM_CTL(0),
+			(0xf<<DAM_CTL_RX1_NUM),
+			((params_channels(params)-1)<<DAM_CTL_RX1_NUM));
+	regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_DAM_CTL(0),
+			(0xf<<DAM_CTL_RX2_NUM),
+			((params_channels(params)-1)<<DAM_CTL_RX2_NUM));
+	regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_DAM_CTL(0),
+			(0xf<<DAM_CTL_TX_NUM),
+			((params_channels(params)-1)<<DAM_CTL_TX_NUM));
+	regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_DAM_CTL(1),
+			(0xf<<DAM_CTL_RX0_NUM),
+			((params_channels(params)-1)<<DAM_CTL_RX0_NUM));
+	regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_DAM_CTL(1),
+			(0xf<<DAM_CTL_RX1_NUM),
+			((params_channels(params)-1)<<DAM_CTL_RX1_NUM));
+	regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_DAM_CTL(1),
+			(0xf<<DAM_CTL_RX2_NUM),
+			((params_channels(params)-1)<<DAM_CTL_RX2_NUM));
+	regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_DAM_CTL(1),
+			(0xf<<DAM_CTL_TX_NUM),
+			((params_channels(params)-1)<<DAM_CTL_TX_NUM));
+
+	return 0;
+}
+
+static int sunxi_ahub_codec_dai_trigger(struct snd_pcm_substream *substream,
+				int cmd, struct snd_soc_dai *dai)
+{
+	switch (cmd) {
+	case	SNDRV_PCM_TRIGGER_START:
+	case	SNDRV_PCM_TRIGGER_RESUME:
+	case	SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			sunxi_ahub_update_bits(
+					SUNXI_AHUB_APBIF_TXFIFO_CTL(dai->id),
+					(1<<APBIF_TX_FTX), (1<<APBIF_TX_FTX));
+		}
+		break;
+	case	SNDRV_PCM_TRIGGER_STOP:
+	case	SNDRV_PCM_TRIGGER_SUSPEND:
+	case	SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int sunxi_ahub_codec_dai_set_sysclk(struct snd_soc_dai *dai,
+			int clk_id, unsigned int freq, int dir)
+{
+	struct sunxi_ahub_priv *sunxi_ahub = snd_soc_dai_get_drvdata(dai);
+
+	if (clk_set_rate(sunxi_ahub->clk_module, freq / 2)) {
+		dev_err(sunxi_ahub->dev, "set clk_module rate failed\n");
+		return -EINVAL;
+	}
+
+	if (clk_set_rate(sunxi_ahub->clk_audio_hub, freq / 2)) {
+		dev_err(sunxi_ahub->dev, "set clk_audio_hub rate failed\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sunxi_ahub_codec_dai_prepare(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_priv *sunxi_ahub = snd_soc_dai_get_drvdata(dai);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_update_bits(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_TXFIFO_CTL(dai->id),
+				(1<<APBIF_TX_FTX), (1<<APBIF_TX_FTX));
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_TX_IRQ_STA(dai->id),
+				(1<<APBIF_TX_OV_PEND|1<<APBIF_TX_EM_PEND));
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_TXFIFO_CNT(dai->id), 0);
+	} else {
+		regmap_update_bits(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_RXFIFO_CTL(dai->id),
+				(1<<APBIF_RX_FRX), (1<<APBIF_RX_FRX));
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_RX_IRQ_STA(dai->id),
+				(1<<APBIF_RX_UV_PEND|1<<APBIF_RX_AV_PEND));
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_RXFIFO_CNT(dai->id), 0);
+	}
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sunxi_ahub_codec_dai_ops = {
+	.hw_params	= sunxi_ahub_codec_dai_hw_params,
+	.set_sysclk	= sunxi_ahub_codec_dai_set_sysclk,
+	.trigger	= sunxi_ahub_codec_dai_trigger,
+	.prepare	= sunxi_ahub_codec_dai_prepare,
+};
+
+/* ahub codec dai */
+static struct snd_soc_dai_driver sunxi_ahub_codec_dais[] = {
+	{
+		.name = "sunxi-ahub-aif1",
+		.id = 0,
+		.playback = {
+			.stream_name = "AIF1 Playback",
+			.channels_min = 1,
+			.channels_max = 16,
+			.rates = SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.rate_min       = 8000,
+			.rate_max       = 192000,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.capture = {
+			.stream_name = "AIF1 Capture",
+			.channels_min = 1,
+			.channels_max = 16,
+			.rates = SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.rate_min       = 8000,
+			.rate_max       = 192000,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+		 },
+		.ops = &sunxi_ahub_codec_dai_ops,
+	},
+	{
+		.name = "sunxi-ahub-aif2",
+		.id = 1,
+		.playback = {
+			.stream_name = "AIF2 Playback",
+			.channels_min = 1,
+			.channels_max = 16,
+			.rates = SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.rate_min       = 8000,
+			.rate_max       = 192000,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.capture = {
+			.stream_name = "AIF2 Capture",
+			.channels_min = 1,
+			.channels_max = 16,
+			.rates = SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.rate_min       = 8000,
+			.rate_max       = 192000,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.ops = &sunxi_ahub_codec_dai_ops,
+	},
+	{
+		.name = "sunxi-ahub-aif3",
+		.id = 2,
+		.playback = {
+			.stream_name = "AIF3 Playback",
+			.channels_min = 1,
+			.channels_max = 16,
+			.rates = SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.rate_min       = 8000,
+			.rate_max       = 192000,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.capture = {
+			.stream_name = "AIF3 Capture",
+			.channels_min = 1,
+			.channels_max = 16,
+			.rates = SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.rate_min       = 8000,
+			.rate_max       = 192000,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+		 },
+		.ops = &sunxi_ahub_codec_dai_ops,
+	}
+};
+
+static int sunxi_ahub_codec_probe(struct snd_soc_component *component)
+{
+	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
+	
+	snd_soc_dapm_new_controls(dapm, sunxi_ahub_codec_dapm_widgets,
+					ARRAY_SIZE(sunxi_ahub_codec_dapm_widgets));
+	snd_soc_dapm_add_routes(dapm, sunxi_ahub_codec_dapm_routes,
+					ARRAY_SIZE(sunxi_ahub_codec_dapm_routes));
+	snd_soc_add_component_controls(component, ahub_controls,
+					ARRAY_SIZE(ahub_controls));
+
+	sunxi_ahub_codec_init(component);
+	return 0;
+}
+
+static int sunxi_ahub_codec_suspend(struct snd_soc_component *component)
+{
+	struct sunxi_ahub_priv *sunxi_ahub = snd_soc_component_get_drvdata(component);
+
+	clk_disable_unprepare(sunxi_ahub->clk_module);
+	clk_disable_unprepare(sunxi_ahub->clk_audio_hub);
+
+	return 0;
+}
+
+static int sunxi_ahub_codec_resume(struct snd_soc_component *component)
+{
+	struct sunxi_ahub_priv *sunxi_ahub = snd_soc_component_get_drvdata(component);
+
+	if (clk_prepare_enable(sunxi_ahub->clk_audio_hub)) {
+		dev_err(sunxi_ahub->dev, "clk_audio_hub resume failed\n");
+		return -EBUSY;
+	}
+	if (clk_prepare_enable(sunxi_ahub->clk_module)) {
+		dev_err(sunxi_ahub->dev, "clk_module resume failed\n");
+		return -EBUSY;
+	}
+
+	sunxi_ahub_codec_init(component);
+	sunxi_ahub_cpudai_init();
+
+	return 0;
+}
+
+static struct snd_soc_component_driver sunxi_ahub_soc_component = {
+	.probe = sunxi_ahub_codec_probe,
+	.suspend = sunxi_ahub_codec_suspend,
+	.resume = sunxi_ahub_codec_resume,
+};
+
+static int sunxi_ahub_dev_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+
+	dev_set_drvdata(&pdev->dev, sunxi_ahub);
+	sunxi_ahub->dev = &pdev->dev;
+
+	/* Get the clocks from the DT */
+	sunxi_ahub->clk_apb = devm_clk_get(&pdev->dev, "apb");
+	if (IS_ERR(sunxi_ahub->clk_apb)) {
+		dev_err(&pdev->dev, "Failed to get the APB clock\n");
+		return PTR_ERR(sunxi_ahub->clk_apb);
+	}
+	
+	sunxi_ahub->clk_module = devm_clk_get(&pdev->dev, "audio-codec-1x");
+	if (IS_ERR(sunxi_ahub->clk_module)) {
+		dev_err(&pdev->dev, "Failed to get the codec module clock\n");
+		return PTR_ERR(sunxi_ahub->clk_module);
+	}
+
+	sunxi_ahub->clk_audio_hub = devm_clk_get(&pdev->dev, "audio-hub");
+	if (IS_ERR(sunxi_ahub->clk_module)) {
+		dev_err(&pdev->dev, "Failed to get the audio hub clock\n");
+		return PTR_ERR(sunxi_ahub->clk_module);
+	}
+
+	/* Enable the bus clock */
+	if (clk_prepare_enable(sunxi_ahub->clk_apb)) {
+	        dev_err(&pdev->dev, "Failed to enable the APB clock\n");
+	        return -EINVAL;
+	}
+
+	if (clk_prepare_enable(sunxi_ahub->clk_module)) {
+	        dev_err(&pdev->dev, "Failed to enable the ahub module clock\n");
+	        return -EINVAL;
+	}
+
+	if (clk_prepare_enable(sunxi_ahub->clk_audio_hub)) {
+	        dev_err(&pdev->dev, "Failed to enable the ahdio hub clock\n");
+	        return -EINVAL;
+	}
+	
+	sunxi_ahub->rst = devm_reset_control_get_exclusive(&pdev->dev, NULL);
+	if (IS_ERR(sunxi_ahub->rst)) {
+	        dev_err(&pdev->dev, "Failed to get reset control\n");
+	        return PTR_ERR(sunxi_ahub->rst);
+	}
+
+	/* Deassert the reset control */
+	if (sunxi_ahub->rst) {
+		ret = reset_control_deassert(sunxi_ahub->rst);
+		if (ret) {
+			dev_err(&pdev->dev, "Failed to deassert the reset control\n");
+			goto err_clk_disable;;
+		}
+	}
+
+	sunxi_ahub->regmap = sunxi_ahub_regmap_init(pdev);
+	if (!sunxi_ahub->regmap) {
+		dev_err(&pdev->dev, "regmap not init ok\n");
+		ret = -ENOMEM;
+		goto err_assert_reset;
+	}
+
+	ret = snd_soc_register_component(&pdev->dev, &sunxi_ahub_soc_component,
+				sunxi_ahub_codec_dais,
+				ARRAY_SIZE(sunxi_ahub_codec_dais));
+	if (ret) {
+		dev_err(&pdev->dev, "component register failed\n");
+		ret = -ENOMEM;
+		goto err_assert_reset;
+	}
+
+	return 0;
+
+err_assert_reset:
+	reset_control_assert(sunxi_ahub->rst);
+
+err_clk_disable:
+	clk_disable_unprepare(sunxi_ahub->clk_apb);
+	clk_disable_unprepare(sunxi_ahub->clk_module);
+	clk_disable_unprepare(sunxi_ahub->clk_audio_hub);
+
+	return ret;
+}
+
+static int __exit sunxi_ahub_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_ahub_priv *sunxi_ahub = dev_get_drvdata(&pdev->dev);
+
+	snd_soc_unregister_component(&pdev->dev);
+	clk_put(sunxi_ahub->clk_module);
+	clk_put(sunxi_ahub->clk_audio_hub);
+	clk_put(sunxi_ahub->clk_apb);
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_ahub_of_match[] = {
+	{ .compatible = "allwinner,sunxi-ahub", },
+	{},
+};
+
+static struct platform_driver sunxi_ahub_driver = {
+	.probe = sunxi_ahub_dev_probe,
+	.remove = __exit_p(sunxi_ahub_dev_remove),
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_ahub_of_match,
+	},
+};
+
+module_platform_driver(sunxi_ahub_driver);
+
+MODULE_DESCRIPTION("SUNXI Audio Hub Codec ASoC Interface");
+MODULE_AUTHOR("wolfgang huang <huangjinhui@allwinnertech.com>");
+MODULE_AUTHOR("Leeboby <leeboby@aliyun.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-ahub");
diff --git a/sound/soc/sunxi/sun50i-sndahub.c b/sound/soc/sunxi/sun50i-sndahub.c
new file mode 100644
index 000000000..a7816dd2c
--- /dev/null
+++ b/sound/soc/sunxi/sun50i-sndahub.c
@@ -0,0 +1,365 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * (C) Copyright 2014-2018
+ * Allwinnertech Technology Co., Ltd. <www.allwinnertech.com>
+ * Wolfgang huang <huangjinhui@allwinnertech.com>
+ *
+ * (C) Copyright 2021
+ * Shenzhen Xunlong Software Co., Ltd. <www.orangepi.org>
+ * Leeboby <leeboby@aliyun.com>
+ */
+
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/soc-dapm.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/delay.h>
+
+#include "sun50i_ahub.h"
+
+/* Configuration for a stream */
+struct pcm_config {
+       unsigned int channels;
+       unsigned int rate;
+       unsigned format;
+};
+
+#define AHUB_MAX_DEVICE                3
+static struct pcm_config pcm[AHUB_MAX_DEVICE][2];
+
+static int event_bind_id;
+
+static int sunxi_ahub_netlink_event(struct snd_soc_dapm_widget *w,
+			int stream, int event)
+{
+#if 0
+	struct snd_soc_card *card = w->dapm->card;
+	struct snd_soc_pcm_runtime *rtd;
+	struct snd_soc_dai *codec_dai;
+	int opt_open;
+
+	list_for_each_entry (rtd, &card->rtd_list, list) {
+		 if (rtd->codec_dai->id == event_bind_id)
+				break;
+	}
+	codec_dai = rtd->codec_dai;
+
+	switch (event) {
+	case	SND_SOC_DAPM_POST_PMU:
+		opt_open = 1;
+		break;
+	case	SND_SOC_DAPM_PRE_PMD:
+		opt_open = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* FIXME, as for AudioHub designed has three runtime, those runtime will
+	 * done it mess for some complex usage. so we just make sure allthing
+	 * work fine, we cut down diff sample rate playback or capture
+	 * do it at one time
+	 */
+
+	sunxi_netlink_printd("sunxi ahub event :%s : %ld :config=%ld/%ld/%ld/\n",
+			   w->name, (unsigned long)opt_open,
+			   (unsigned long)pcm[codec_dai->id][stream].channels,
+			   (unsigned long)pcm[codec_dai->id][stream].rate,
+			   (unsigned long)pcm[codec_dai->id][stream].format);
+
+#endif
+
+	return 0;
+}
+
+static int sunxi_ahub_playback_event(struct snd_soc_dapm_widget *w,
+			struct snd_kcontrol *k, int event)
+{
+	return sunxi_ahub_netlink_event(w, 0, event);
+}
+
+static int sunxi_ahub_capture_event(struct snd_soc_dapm_widget *w,
+			struct snd_kcontrol *k, int event)
+{
+	return sunxi_ahub_netlink_event(w, 1, event);
+}
+
+static const struct snd_kcontrol_new sunxi_ahub_card_controls[] = {
+	SOC_DAPM_PIN_SWITCH("I2S0IN"),
+	SOC_DAPM_PIN_SWITCH("I2S0OUT"),
+	SOC_DAPM_PIN_SWITCH("I2S1IN"),
+	SOC_DAPM_PIN_SWITCH("I2S1OUT"),
+	SOC_DAPM_PIN_SWITCH("I2S2IN"),
+	SOC_DAPM_PIN_SWITCH("I2S2OUT"),
+	SOC_DAPM_PIN_SWITCH("I2S3IN"),
+	SOC_DAPM_PIN_SWITCH("I2S3OUT"),
+	SOC_DAPM_PIN_SWITCH("DAM0IN"),
+	SOC_DAPM_PIN_SWITCH("DAM1IN"),
+	SOC_DAPM_PIN_SWITCH("DAM0OUT"),
+	SOC_DAPM_PIN_SWITCH("DAM1OUT"),
+};
+
+/* the input & output dir depends on view of audio hub */
+static const struct snd_soc_dapm_widget sunxi_ahub_card_dapm_widgets[] = {
+	SND_SOC_DAPM_LINE("I2S0IN", sunxi_ahub_capture_event),
+	SND_SOC_DAPM_LINE("I2S0OUT", sunxi_ahub_playback_event),
+	SND_SOC_DAPM_LINE("I2S1IN", sunxi_ahub_capture_event),
+	SND_SOC_DAPM_LINE("I2S1OUT", sunxi_ahub_playback_event),
+	SND_SOC_DAPM_LINE("I2S2IN", sunxi_ahub_capture_event),
+	SND_SOC_DAPM_LINE("I2S2OUT", sunxi_ahub_playback_event),
+	SND_SOC_DAPM_LINE("I2S3IN", sunxi_ahub_capture_event),
+	SND_SOC_DAPM_LINE("I2S3OUT", sunxi_ahub_playback_event),
+	SND_SOC_DAPM_LINE("DAM0IN", NULL),
+	SND_SOC_DAPM_LINE("DAM1IN", NULL),
+	SND_SOC_DAPM_LINE("DAM0OUT", NULL),
+	SND_SOC_DAPM_LINE("DAM1OUT", NULL),
+};
+
+/* the input & output dir depends on view of audio hub */
+static const struct snd_soc_dapm_route sunxi_ahub_card_routes[] = {
+	{"I2S0 DAC", NULL, "I2S0IN"},
+	{"I2S1 DAC", NULL, "I2S1IN"},
+	{"I2S2 DAC", NULL, "I2S2IN"},
+	{"I2S3 DAC", NULL, "I2S3IN"},
+	{"I2S0OUT", NULL, "I2S0 ADC"},
+	{"I2S1OUT", NULL, "I2S1 ADC"},
+	{"I2S2OUT", NULL, "I2S2 ADC"},
+	{"I2S3OUT", NULL, "I2S3 ADC"},
+	{"DAM0 INPUT", NULL, "DAM0IN"},
+	{"DAM1 INPUT", NULL, "DAM1IN"},
+	{"DAM0OUT", NULL, "DAM0 OUTPUT"},
+	{"DAM1OUT", NULL, "DAM1 OUTPUT"},
+};
+
+static int sunxi_ahub_card_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_component *component = asoc_rtd_to_codec(rtd, 0)->component;
+	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
+
+	snd_soc_dapm_disable_pin(dapm, "I2S0IN");
+	snd_soc_dapm_disable_pin(dapm, "I2S0OUT");
+	snd_soc_dapm_disable_pin(dapm, "I2S1IN");
+	snd_soc_dapm_disable_pin(dapm, "I2S1OUT");
+	snd_soc_dapm_disable_pin(dapm, "I2S2IN");
+	snd_soc_dapm_disable_pin(dapm, "I2S2OUT");
+	snd_soc_dapm_disable_pin(dapm, "I2S3IN");
+	snd_soc_dapm_disable_pin(dapm, "I2S3OUT");
+	snd_soc_dapm_disable_pin(dapm, "DAM0IN");
+	snd_soc_dapm_disable_pin(dapm, "DAM1IN");
+	snd_soc_dapm_disable_pin(dapm, "DAM0OUT");
+	snd_soc_dapm_disable_pin(dapm, "DAM1OUT");
+
+	snd_soc_dapm_sync(dapm);
+	return 0;
+}
+
+static int sunxi_sndahub_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);
+	struct snd_soc_card *card = rtd->card;
+	unsigned int freq;
+	int ret;
+
+	switch (params_rate(params)) {
+	case 8000:
+	case 16000:
+	case 32000:
+	case 64000:
+	case 128000:
+	case 12000:
+	case 24000:
+	case 48000:
+	case 96000:
+	case 192000:
+		freq = 98304000;
+		break;
+	case	11025:
+	case	22050:
+	case	44100:
+	case	88200:
+	case	176400:
+		freq = 90316800;
+		break;
+	default:
+		dev_err(card->dev, "unsupport freq\n");
+		return -EINVAL;
+	}
+
+	/*set system clock source freq and set the mode as i2s0 or pcm*/
+	ret = snd_soc_dai_set_sysclk(codec_dai, 0, freq, 0);
+	if (ret < 0)
+		return ret;
+
+	/*FIXME used for event send to observer process */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		pcm[codec_dai->id][0].channels = params_channels(params);
+		pcm[codec_dai->id][0].rate = params_rate(params);
+		if (0)
+			pcm[codec_dai->id][0].format = SNDRV_PCM_FORMAT_S32_LE;
+		else
+			pcm[codec_dai->id][0].format = params_format(params);
+	} else {
+		pcm[codec_dai->id][1].channels = params_channels(params);
+		pcm[codec_dai->id][1].rate = params_rate(params);
+		if (0)
+			pcm[codec_dai->id][1].format = SNDRV_PCM_FORMAT_S32_LE;
+		else
+			pcm[codec_dai->id][1].format = params_format(params);
+	}
+
+	event_bind_id = codec_dai->id;
+
+	return 0;
+}
+
+static struct snd_soc_ops sunxi_sndahub_ops = {
+	.hw_params	= sunxi_sndahub_hw_params,
+};
+
+SND_SOC_DAILINK_DEFS(aif1,
+        DAILINK_COMP_ARRAY(COMP_EMPTY()),
+        DAILINK_COMP_ARRAY(COMP_CODEC(NULL, "sunxi-ahub-aif1")),
+        DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(aif2,
+        DAILINK_COMP_ARRAY(COMP_EMPTY()),
+        DAILINK_COMP_ARRAY(COMP_CODEC(NULL, "sunxi-ahub-aif2")),
+        DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(aif3,
+        DAILINK_COMP_ARRAY(COMP_EMPTY()),
+        DAILINK_COMP_ARRAY(COMP_CODEC(NULL, "sunxi-ahub-aif2")),
+        DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+static struct snd_soc_dai_link sunxi_sndahub_dai_link[] = {
+	{
+		.name = "Primary",
+		.stream_name = "Media Stream",
+		.init = sunxi_ahub_card_init,
+		.ops = &sunxi_sndahub_ops,
+		SND_SOC_DAILINK_REG(aif1),
+	},
+	{
+		.name = "Sec",
+		.stream_name = "System Stream",
+		.ops = &sunxi_sndahub_ops,
+		SND_SOC_DAILINK_REG(aif2),
+	},
+	{
+		.name = "Thr",
+		.stream_name = "Accompany Stream",
+		.ops = &sunxi_sndahub_ops,
+		SND_SOC_DAILINK_REG(aif3),
+	},
+};
+
+static struct snd_soc_card snd_soc_sunxi_sndahub = {
+	.name			= "sndahub",
+	.owner			= THIS_MODULE,
+	.controls		= sunxi_ahub_card_controls,
+	.num_controls		= ARRAY_SIZE(sunxi_ahub_card_controls),
+	.dapm_widgets       	= sunxi_ahub_card_dapm_widgets,
+	.num_dapm_widgets   	= ARRAY_SIZE(sunxi_ahub_card_dapm_widgets),
+	.dapm_routes        	= sunxi_ahub_card_routes,
+	.num_dapm_routes    	= ARRAY_SIZE(sunxi_ahub_card_routes),
+	.dai_link		= sunxi_sndahub_dai_link,
+	.num_links		= ARRAY_SIZE(sunxi_sndahub_dai_link),
+};
+
+static int sunxi_sndahub_dev_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = &snd_soc_sunxi_sndahub;
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+	int i;
+
+	card->dev = &pdev->dev;
+
+	sunxi_sndahub_dai_link[0].cpus->dai_name = NULL;
+	sunxi_sndahub_dai_link[0].cpus->of_node = of_parse_phandle(np,
+					"sunxi,cpudai-controller0", 0);
+	if (!sunxi_sndahub_dai_link[0].cpus->of_node) {
+		dev_err(&pdev->dev, "Property 'sunxi,cpudai-controller0' missing or invalid\n");
+		return -EINVAL;
+	} else {
+		sunxi_sndahub_dai_link[0].platforms->name = NULL;
+		sunxi_sndahub_dai_link[0].platforms->of_node =
+				sunxi_sndahub_dai_link[0].cpus->of_node;
+	}
+
+	sunxi_sndahub_dai_link[1].cpus->dai_name = NULL;
+	sunxi_sndahub_dai_link[1].cpus->of_node = of_parse_phandle(np,
+					"sunxi,cpudai-controller1", 0);
+	if (!sunxi_sndahub_dai_link[1].cpus->of_node) {
+		dev_err(&pdev->dev, "Property 'sunxi,cpudai-controller1' missing or invalid\n");
+		return -EINVAL;
+	} else {
+		sunxi_sndahub_dai_link[1].platforms->name = NULL;
+		sunxi_sndahub_dai_link[1].platforms->of_node =
+				sunxi_sndahub_dai_link[1].cpus->of_node;
+	}
+
+	sunxi_sndahub_dai_link[2].cpus->dai_name = NULL;
+	sunxi_sndahub_dai_link[2].cpus->of_node = of_parse_phandle(np,
+					"sunxi,cpudai-controller2", 0);
+	if (!sunxi_sndahub_dai_link[2].cpus->of_node) {
+		dev_err(&pdev->dev, "Property 'sunxi,cpudai-controller0' missing or invalid\n");
+		return -EINVAL;
+	} else {
+		sunxi_sndahub_dai_link[2].platforms->name = NULL;
+		sunxi_sndahub_dai_link[2].platforms->of_node =
+				sunxi_sndahub_dai_link[2].cpus->of_node;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(sunxi_sndahub_dai_link); i++) {
+		sunxi_sndahub_dai_link[i].codecs->name = NULL;
+		sunxi_sndahub_dai_link[i].codecs->of_node = of_parse_phandle(np,
+							"sunxi,audio-codec", 0);
+	}
+
+	card->dev = &pdev->dev;
+	ret = devm_snd_soc_register_card(&pdev->dev, card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n", ret);
+	}
+
+	return ret;
+}
+
+static int __exit sunxi_sndahub_dev_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+	snd_soc_unregister_card(card);
+	return 0;
+}
+
+static const struct of_device_id sunxi_ahub_of_match[] = {
+	{ .compatible = "allwinner,sunxi-ahub-machine", },
+	{},
+};
+
+static struct platform_driver sunxi_ahubaudio_driver = {
+	.driver = {
+		.name = "sndahub",
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_ahub_of_match,
+		.pm = &snd_soc_pm_ops,
+	},
+	.probe = sunxi_sndahub_dev_probe,
+	.remove = __exit_p(sunxi_sndahub_dev_remove),
+};
+
+module_platform_driver(sunxi_ahubaudio_driver);
+
+MODULE_AUTHOR("wolfgang huang <huangjinhui@allwinnertech.com>");
+MODULE_AUTHOR("Leeboby <leeboby@aliyun.com>");
+MODULE_DESCRIPTION("SUNXI Audio Hub ASoC Machine driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi/sun50i-sndhdmi.c b/sound/soc/sunxi/sun50i-sndhdmi.c
new file mode 100644
index 000000000..d4a7b3532
--- /dev/null
+++ b/sound/soc/sunxi/sun50i-sndhdmi.c
@@ -0,0 +1,184 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * (C) Copyright 2014-2016
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * huangxin <huangxin@allwinnertech.com>
+ *
+ * (C) Copyright 2021
+ * Shenzhen Xunlong Software Co., Ltd. <www.orangepi.org>
+ * Leeboby <leeboby@aliyun.com>
+ *
+ */
+
+#include <linux/module.h>
+#include <sound/soc.h>
+
+#define DRV_NAME "sunxi-hdmi"
+
+static int sunxi_hdmi_hw_params(struct snd_pcm_substream *substream,
+				     struct snd_pcm_hw_params *params)
+{
+	int ret = 0;
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
+	struct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);
+
+	unsigned int freq, clk_div;
+
+	switch (params_rate(params)) {
+
+		case 8000:
+		case 16000:
+		case 32000:
+		case 64000:
+		case 128000:
+		case 12000:
+		case 24000:
+		case 48000:
+		case 96000:
+		case 192000:
+			freq = 98304000;
+			//freq = 24576000;
+			break;
+		case    11025:
+		case    22050:
+		case    44100:
+		case    88200:
+		case    176400:
+			freq = 90316800;
+			//freq = 22579200;
+			break;
+		default:
+		        return -EINVAL;
+	}
+
+	/*set system clock source freq and set the mode as i2s0 or pcm*/
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, freq, 0);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * I2S mode normal bit clock + frame\codec clk & FRM slave
+	 */
+	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+	                SND_SOC_DAIFMT_NB_NF_H616 | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
+
+	clk_div = freq / params_rate(params);
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, 0, clk_div);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static struct snd_soc_ops sunxi_sound_hdmi_ops = {
+	.hw_params = sunxi_hdmi_hw_params,
+};
+
+SND_SOC_DAILINK_DEFS(audio,
+        DAILINK_COMP_ARRAY(COMP_EMPTY()),
+        DAILINK_COMP_ARRAY(COMP_CODEC("hdmi-audio-codec.4.auto", "i2s-hifi")),
+        DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+static struct snd_soc_dai_link sunxi_dailink = {
+	.name = "HDMIAUDIO",
+	.stream_name = "hdmi",
+	.ops = &sunxi_sound_hdmi_ops,
+	SND_SOC_DAILINK_REG(audio),
+};
+
+static struct snd_soc_card sunxi_sound_card = {
+	.name = "hdmi-audio",
+	.owner = THIS_MODULE,
+	.dai_link = &sunxi_dailink,
+	.num_links =  1,
+};
+
+static int sunxi_sound_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct snd_soc_dai_link *dai_link;
+	struct snd_soc_card *card;
+	char name[30] = "allwinner-hdmi";
+	unsigned int temp_val;
+	int ret = 0;
+
+	card = devm_kzalloc(&pdev->dev, sizeof(struct snd_soc_card),
+			GFP_KERNEL);
+	if (!card)
+	        return -ENOMEM;
+	
+	memcpy(card, &sunxi_sound_card, sizeof(struct snd_soc_card));
+	
+	card->name = name;
+	card->dev = &pdev->dev;
+	
+	dai_link = devm_kzalloc(&pdev->dev,
+	                sizeof(struct snd_soc_dai_link), GFP_KERNEL);
+	if (!dai_link) {
+	        ret = -ENOMEM;
+	        goto err_kfree_card;
+	}
+
+	memcpy(dai_link, &sunxi_dailink,
+	                sizeof(struct snd_soc_dai_link));
+	card->dai_link = dai_link;
+
+	dai_link->cpus->of_node = of_parse_phandle(np,
+	                                "sunxi,cpudai-controller", 0);
+	if (!dai_link->cpus->of_node) {
+		dev_err(&pdev->dev,
+		        "Property 'sunxi,cpudai-controller' invalid\n");
+		ret = -EINVAL;
+		goto err_kfree_link;
+	}
+
+	dai_link->platforms->name = "snd-soc-dummy";
+
+	ret = of_property_read_string(np, "sunxi,snddaudio-codec",
+	                &dai_link->codecs->name);
+	if (ret < 0)
+	{
+		dev_err(&pdev->dev, 
+			"Property 'sunxi,snddaudio-codec' invalid\n");
+		ret = -EINVAL;
+		goto err_kfree_link;
+	}
+
+	ret = snd_soc_register_card(card);
+	if (ret) {
+	        dev_err(card->dev, "snd_soc_register_card failed\n");
+	        goto err_kfree_link;
+	}
+
+	return ret;
+
+err_kfree_link:
+        devm_kfree(&pdev->dev, card->dai_link);
+err_kfree_card:
+        devm_kfree(&pdev->dev, card);
+
+        return ret;
+}
+
+static const struct of_device_id sunxi_sound_of_match[] = {
+	{ .compatible = "allwinner,sunxi-hdmi-machine", },
+	{},
+};
+
+static struct platform_driver sunxi_sound_driver = {
+	.probe = sunxi_sound_probe,
+	.driver = {
+		.name = DRV_NAME,
+		.of_match_table = sunxi_sound_of_match,
+	},
+};
+
+module_platform_driver(sunxi_sound_driver);
+
+MODULE_DESCRIPTION("Allwinner ASoC Machine Driver");
+MODULE_AUTHOR("wolfgang huang <huangjinhui@allwinnertech.com>");
+MODULE_AUTHOR("Leeboby <leeboby@aliyun.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/sunxi/sun50i_ahub.h b/sound/soc/sunxi/sun50i_ahub.h
new file mode 100644
index 000000000..eff2891e3
--- /dev/null
+++ b/sound/soc/sunxi/sun50i_ahub.h
@@ -0,0 +1,300 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * (C) Copyright 2015-2017
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Wolfgang huang <huangjinhui@allwinnertechtech.com>
+ *
+ */
+
+#ifndef _SUNXI_AHUB_H_
+#define _SUNXI_AHUB_H_
+
+#include <linux/of_device.h>
+#include <linux/regmap.h>
+#include <linux/module.h>
+
+#define CONFIG_ARCH_SUN50IW9 1
+//#define LOOPBACK_FOR_DAUDIO
+
+/* SUNXI Audio Hub registers list */
+#define SUNXI_AHUB_CTL		0x00
+#define SUNXI_AHUB_VER		0x04
+#define SUNXI_AHUB_RST		0x08
+#define SUNXI_AHUB_GAT		0x0c
+/* Left blank */
+#define SUNXI_AHUB_APBIF_TX_CTL(n)		(0x10 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_TX_IRQ_CTL(n)		(0x14 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_TX_IRQ_STA(n)		(0x18 + ((n) * 0x30))
+/* Left Blank */
+#define SUNXI_AHUB_APBIF_TXFIFO_CTL(n)		(0x20 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_TXFIFO_STA(n)		(0x24 + ((n) * 0x30))
+/* Left Blank */
+#define SUNXI_AHUB_APBIF_TXFIFO(n)		(0x30 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_TXFIFO_CNT(n)		(0x34 + ((n) * 0x30))
+/* Left Blank */
+#define SUNXI_AHUB_APBIF_RX_CTL(n)		(0x100 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_RX_IRQ_CTL(n)		(0x104 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_RX_IRQ_STA(n)		(0x108 + ((n) * 0x30))
+/* Left Blank */
+#define SUNXI_AHUB_APBIF_RXFIFO_CTL(n)		(0x110 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_RXFIFO_STA(n)		(0x114 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_RXFIFO_CONT(n)		(0x118 + ((n) * 0x30))
+/* Left Blank */
+#define SUNXI_AHUB_APBIF_RXFIFO(n)		(0x120 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_RXFIFO_CNT(n)		(0x124 + ((n) * 0x30))
+
+#define SUNXI_AHUB_I2S_CTL(n)			(0x200 + ((n) << 8))
+#define SUNXI_AHUB_I2S_FMT0(n)			(0x204 + ((n) << 8))
+#define SUNXI_AHUB_I2S_FMT1(n)			(0x208 + ((n) << 8))
+#define SUNXI_AHUB_I2S_CLKD(n)			(0x20c + ((n) << 8))
+/* Left Blank */
+#define SUNXI_AHUB_I2S_RXCONT(n)		(0x220 + ((n) << 8))
+#define SUNXI_AHUB_I2S_CHCFG(n)			(0x224 + ((n) << 8))
+#define SUNXI_AHUB_I2S_IRQ_CTL(n)		(0x228 + ((n) << 8))
+#define SUNXI_AHUB_I2S_IRQ_STA(n)		(0x22C + ((n) << 8))
+#define SUNXI_AHUB_I2S_OUT_SLOT0(n)		(0x230 + ((n) << 8) + (0 << 4))
+#define SUNXI_AHUB_I2S_OUT_SLOT1(n)		(0x230 + ((n) << 8) + (1 << 4))
+#define SUNXI_AHUB_I2S_OUT_SLOT2(n)		(0x230 + ((n) << 8) + (2 << 4))
+#define SUNXI_AHUB_I2S_OUT_SLOT3(n)		(0x230 + ((n) << 8) + (3 << 4))
+#define SUNXI_AHUB_I2S_OUT_CH0MAP0(n)		(0x234 + ((n) << 8) + (0 << 4))
+#define SUNXI_AHUB_I2S_OUT_CH1MAP0(n)		(0x234 + ((n) << 8) + (1 << 4))
+#define SUNXI_AHUB_I2S_OUT_CH2MAP0(n)		(0x234 + ((n) << 8) + (2 << 4))
+#define SUNXI_AHUB_I2S_OUT_CH3MAP0(n)		(0x234 + ((n) << 8) + (3 << 4))
+#define SUNXI_AHUB_I2S_OUT_CH0MAP1(n)		(0x238 + ((n) << 8) + (0 << 4))
+#define SUNXI_AHUB_I2S_OUT_CH1MAP1(n)		(0x238 + ((n) << 8) + (1 << 4))
+#define SUNXI_AHUB_I2S_OUT_CH2MAP1(n)		(0x238 + ((n) << 8) + (2 << 4))
+#define SUNXI_AHUB_I2S_OUT_CH3MAP1(n)		(0x238 + ((n) << 8) + (3 << 4))
+
+/* Left Blank */
+#define SUNXI_AHUB_I2S_IN_SLOT(n)		(0x270 + ((n) << 8))
+#define SUNXI_AHUB_I2S_IN_CHMAP0(n)		(0x274 + ((n) << 8))
+#define SUNXI_AHUB_I2S_IN_CHMAP1(n)		(0x278 + ((n) << 8))
+/* Left Blank */
+#define SUNXI_AHUB_DAM_CTL(n)			(0xA00 + ((n) << 7))
+/* Left Blank */
+#define SUNXI_AHUB_DAM_RX0_SRC(n)		(0xA10 + ((n) << 7))
+#define SUNXI_AHUB_DAM_RX1_SRC(n)		(0xA14 + ((n) << 7))
+#define SUNXI_AHUB_DAM_RX2_SRC(n)		(0xA18 + ((n) << 7))
+/* Left Blank */
+#define SUNXI_AHUB_DAM_MIX_CTL0(n)		(0xA30 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL1(n)		(0xA34 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL2(n)		(0xA38 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL3(n)		(0xA3C + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL4(n)		(0xA40 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL5(n)		(0xA44 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL6(n)		(0xA48 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL7(n)		(0xA4C + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL0(n)		(0xA50 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL1(n)		(0xA54 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL2(n)		(0xA58 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL3(n)		(0xA5C + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL4(n)		(0xA60 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL5(n)		(0xA64 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL6(n)		(0xA68 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL7(n)		(0xA6C + ((n) << 7))
+
+/* SUNXI_AHUB_CTL */
+#define HDMI_SRC_SEL		0x04
+
+/* SUNXI_AHUB_RST */
+#define APBIF_TXDIF0_RST	31
+#define APBIF_TXDIF1_RST	30
+#define APBIF_TXDIF2_RST	29
+#define APBIF_RXDIF0_RST	27
+#define APBIF_RXDIF1_RST	26
+#define APBIF_RXDIF2_RST	25
+#define I2S0_RST		23
+#define I2S1_RST		22
+#define I2S2_RST		21
+#define I2S3_RST		20
+#define DAM0_RST		15
+#define DAM1_RST		14
+
+/* SUNXI_AHUB_GAT */
+#define APBIF_TXDIF0_GAT	31
+#define APBIF_TXDIF1_GAT	30
+#define APBIF_TXDIF2_GAT	29
+#define APBIF_RXDIF0_GAT	27
+#define APBIF_RXDIF1_GAT	26
+#define APBIF_RXDIF2_GAT	25
+#define I2S0_GAT		23
+#define I2S1_GAT		22
+#define I2S2_GAT		21
+#define I2S3_GAT		20
+#define DAM0_GAT		15
+#define DAM1_GAT		14
+
+/* SUNXI_AHUB_APBIF_TX_CTL */
+#define APBIF_TX_WS		16
+#define APBIF_TX_CHAN_NUM	8
+#define	APBIF_TX_START		4
+
+/* SUNXI_AHUB_APBIF_TX_IRQ_CTL */
+#define APBIF_TX_DRQ		3
+#define APBIF_TX_OVEN		1
+#define APBIF_TX_EMEN		0
+
+/* SUNXI_AHUB_APBIF_TX_IRQ_STA */
+#define APBIF_TX_OV_PEND	1
+#define APBIF_TX_EM_PEND	0
+
+/* SUNXI_AHUB_APBIF_TXFIFO_CTL */
+#define APBIF_TX_FTX		12
+#define APBIF_TX_LEVEL		4
+#define APBIF_TX_TXIM		0
+
+/* SUNXI_AHUB_APBIF_TXFIFO_STA */
+#define APBIF_TX_EMPTY		8
+#define APBIF_TX_EMCNT		0
+
+/* SUNXI_AHUB_APBIF_RX_CTL */
+#define APBIF_RX_WS		16
+#define APBIF_RX_CHAN_NUM	8
+#define	APBIF_RX_START		4
+
+/* SUNXI_AHUB_APBIF_RX_IRQ_CTL */
+#define APBIF_RX_DRQ		3
+#define APBIF_RX_UVEN		2
+#define APBIF_RX_AVEN		0
+
+/* SUNXI_AHUB_APBIF_RX_IRQ_STA */
+#define APBIF_RX_UV_PEND	1
+#define APBIF_RX_AV_PEND	0
+
+/* SUNXI_AHUB_APBIF_RXFIFO_CTL */
+#define APBIF_RX_FRX		12
+#define APBIF_RX_LEVEL		4
+#define APBIF_RX_RXOM		0
+
+/* SUNXI_AHUB_APBIF_RXFIFO_STA */
+#define APBIF_RX_AVAIL		8
+#define APBIF_RX_AVCNT		0
+
+/* SUNXI_AHUB_APBIF_RXFIFO_CONT */
+#define APBIF_RX_APBIF_TXDIF0		31
+#define APBIF_RX_APBIF_TXDIF1		30
+#define APBIF_RX_APBIF_TXDIF2		29
+#define APBIF_RX_I2S0_TXDIF		27
+#define APBIF_RX_I2S1_TXDIF		26
+#define APBIF_RX_I2S2_TXDIF		25
+#define APBIF_RX_I2S3_TXDIF		23
+#define APBIF_RX_DAM0_TXDIF		19
+#define APBIF_RX_DAM1_TXDIF		15
+
+/* SUNXI_AHUB_I2S_CTL */
+//sun50iw9 change loopback bit and SDI_EN
+#ifdef CONFIG_ARCH_SUN50IW9
+#define I2S_CTL_LOOP3			23
+#define I2S_CTL_LOOP2			22
+#define I2S_CTL_LOOP1			21
+#define I2S_CTL_LOOP0			20
+#define I2S_CTL_SDI3_EN			15
+#define I2S_CTL_SDI2_EN			14
+#define I2S_CTL_SDI1_EN			13
+#define I2S_CTL_SDI0_EN			12
+#else
+#define I2S_CTL_LOOP			3
+#endif
+
+#define I2S_CTL_CLK_OUT			18
+#define I2S_CTL_SDO3_EN			11
+#define I2S_CTL_SDO2_EN			10
+#define I2S_CTL_SDO1_EN			9
+#define I2S_CTL_SDO0_EN			8
+#define I2S_CTL_OUT_MUTE		6
+#define I2S_CTL_MODE			4
+#define I2S_CTL_TXEN			2
+#define I2S_CTL_RXEN			1
+#define I2S_CTL_GEN			0
+
+/* SUNXI_AHUB_I2S_FMT0 */
+#define I2S_FMT0_LRCK_WIDTH		30
+#define I2S_FMT0_LRCK_POLARITY		19
+#define I2S_FMT0_LRCK_PERIOD		8
+#define I2S_FMT0_BCLK_POLARITY		7
+#define I2S_FMT0_SR			4
+#define I2S_FMT0_EDGE			3
+#define I2S_FMT0_SW			0
+
+/* SUNXI_AHUB_I2S_FMT1 */
+#define I2S_FMT1_RX_LSB			7
+#define I2S_FMT1_TX_LSB			6
+#define I2S_FMT1_EXT			4
+#define I2S_FMT1_RX_PDM			2
+#define I2S_FMT1_TX_PDM			0
+
+/* SUNXI_AHUB_I2S_CLKD */
+#define I2S_CLKD_MCLK			8
+#define	I2S_CLKD_BCLKDIV		4
+#define I2S_CLKD_MCLKDIV		0
+
+/* SUNXI_AHUB_I2S_RXCONT */
+#define I2S_RX_APBIF_TXDIF0		31
+#define I2S_RX_APBIF_TXDIF1		30
+#define I2S_RX_APBIF_TXDIF2		29
+#define I2S_RX_I2S0_TXDIF		27
+#define I2S_RX_I2S1_TXDIF		26
+#define I2S_RX_I2S2_TXDIF		25
+#define I2S_RX_I2S3_TXDIF		23
+#define I2S_RX_DAM0_TXDIF		19
+#define I2S_RX_DAM1_TXDIF		15
+
+/* SUNXI_AHUB_I2S_CHCFG */
+#define I2S_CHCFG_HIZ			9
+#define	I2S_CHCFG_TX_STATE		8
+#define I2S_CHCFG_RX_CHANNUM		4
+#define I2S_CHCFG_TX_CHANNUM		0
+
+/* SUNXI_AHUB_I2S_IRQ_CTL */
+#define I2S_IRQ_RXOV_EN			1
+#define I2S_IRQ_TXUV_EN			0
+
+/* SUNXI_AHUB_I2S_IRQ_STA */
+#define I2S_IRQ_RXOV_PEND		1
+#define I2S_IRQ_TXUV_PEND		0
+
+/* SUNXI_AHUB_I2S_OUT_SLOT */
+#define I2S_OUT_OFFSET			20
+#define I2S_OUT_SLOT_NUM		16
+#define I2S_OUT_SLOT_EN			0
+
+/* SUNXI_AHUB_I2S_IN_SLOT */
+#define I2S_IN_OFFSET			20
+#define I2S_IN_SLOT_NUM			16
+
+/* SUNXI_AHUB_DAM_CTL */
+#define DAM_CTL_RX2_NUM			24
+#define DAM_CTL_RX1_NUM			20
+#define DAM_CTL_RX0_NUM			16
+#define DAM_CTL_TX_NUM			8
+#define DAM_CTL_RX2EN			6
+#define DAM_CTL_RX1EN			5
+#define DAM_CTL_RX0EN			4
+#define DAM_CTL_TXEN			0
+
+/* SUNXI_AHUB_DAM_RX##chan##_SRC */
+#define DAM_RX_APBIF_TXDIF0		31
+#define DAM_RX_APBIF_TXDIF1		30
+#define DAM_RX_APBIF_TXDIF2		29
+#define DAM_RX_I2S0_TXDIF		27
+#define DAM_RX_I2S1_TXDIF		26
+#define DAM_RX_I2S2_TXDIF		25
+#define DAM_RX_I2S3_TXDIF		23
+#define DAM_RX_DAM0_TXDIF		19
+#define DAM_RX_DAM1_TXDIF		15
+
+/* For sun50iw6, if others should redefine */
+#define SUNXI_AHUB_I2S0_ID			0
+#define SUNXI_AHUB_HDMI_ID			1
+#define SUNXI_AHUB_I2S2_ID			2
+#define SUNXI_AHUB_I2S3_ID			3
+
+extern struct regmap *sunxi_ahub_regmap_init(struct platform_device *pdev);
+extern unsigned int sunxi_ahub_read(unsigned int reg);
+extern int sunxi_ahub_update_bits(unsigned int reg, unsigned int mask,
+				unsigned int val);
+extern int sunxi_ahub_cpudai_init(void);
+
+/* used for sunxi netlink to auto open others card */
+//extern void sunxi_netlink_printd(const char *fmt, ...);
+#endif
diff --git a/sound/soc/sunxi/sun50iw9-codec.c b/sound/soc/sunxi/sun50iw9-codec.c
new file mode 100644
index 000000000..676971816
--- /dev/null
+++ b/sound/soc/sunxi/sun50iw9-codec.c
@@ -0,0 +1,1047 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright 2014 Emilio López <emilio@elopez.com.ar>
+ * Copyright 2014 Jon Smirl <jonsmirl@gmail.com>
+ * Copyright 2015 Maxime Ripard <maxime.ripard@free-electrons.com>
+ * Copyright 2015 Adam Sampson <ats@offog.org>
+ * Copyright 2016 Chen-Yu Tsai <wens@csie.org>
+ * Copyright 2021 gryzun <gryzun_an@rambler.ru>
+ *
+ * (C) Copyright 2021
+ * Shenzhen Xunlong Software Co., Ltd. <www.orangepi.org>
+ * Leeboby <leeboby@aliyun.com>
+ *
+ * Based on the Allwinner SDK driver, released under the GPL.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/clk.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/gpio/consumer.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+#include <sound/initval.h>
+#include <sound/dmaengine_pcm.h>
+
+#define SUNXI_DAC_DPC			(0x00)
+#define SUNXI_DAC_DPC_EN_DA		(31)
+#define SUNXI_DAC_DPC_DVOL		(12)
+#define SUNXI_DAC_DPC_HPF_EN		(18)
+
+#define SUNXI_DAC_FIFOC			(0x10)
+#define SUNXI_DAC_FIFOC_DAC_FS		(29)
+#define SUNXI_DAC_FIFOC_TX_FIFO_MODE	(24)
+#define SUNXI_DAC_FIFOC_DRQ_CLR_CNT	(21)
+#define SUNXI_DAC_FIFOC_MONO_EN		(6)
+#define SUNXI_DAC_FIFOC_TX_SAMPLE_BITS	(5)
+#define SUNXI_DAC_FIFOC_DAC_DRQ_EN	(4)
+#define SUNXI_DAC_FIFOC_FIFO_FLUSH	(0)
+
+#define SUNXI_DAC_FIFO_STA		(0x14)
+#define	SUNXI_DAC_TXE_INT		(3)
+#define	SUNXI_DAC_TXU_INT		(2)
+#define	SUNXI_DAC_TXO_INT		(1)
+#define SUNXI_DAC_TXDATA		(0x20)
+#define SUNXI_DAC_CNT			(0x24)
+#define SUNXI_DAC_DG_REG		(0x28)
+#define SUNXI_DAC_DAP_CTL		(0xf0)
+
+#define SUNXI_DAC_AC_DAC_REG		(0x310)
+#define SUNXI_DAC_LEN			(15)
+#define SUNXI_DAC_REN			(14)
+#define SUNXI_LINEOUTL_EN		(13)
+#define SUNXI_LMUTE			(12)
+#define SUNXI_LINEOUTR_EN		(11)
+#define SUNXI_RMUTE			(10)
+#define SUNXI_RSWITCH			(9)
+#define SUNXI_RAMPEN			(8)
+#define SUNXI_LINEOUTL_SEL		(6)
+#define SUNXI_LINEOUTR_SEL		(5)
+#define SUNXI_LINEOUT_VOL		(0)
+
+#define SUNXI_DAC_AC_MIXER_REG		(0x314)
+#define SUNXI_LMIX_LDAC			(21)
+#define SUNXI_LMIX_RDAC			(20)
+#define SUNXI_RMIX_RDAC			(17)
+#define SUNXI_RMIX_LDAC			(16)
+#define SUNXI_LMIXEN			(11)
+#define SUNXI_RMIXEN			(10)
+
+#define SUNXI_DAC_AC_RAMP_REG		(0x31c)
+#define SUNXI_RAMP_STEP			(4)
+#define SUNXI_RDEN			(0)
+
+#define LABEL(constant)			{#constant, constant, 0}
+#define LABEL_END               	{NULL, 0, -1}
+
+struct audiocodec_reg_label {
+	const char *name;
+	const unsigned int address;
+	int value;
+};
+
+static struct audiocodec_reg_label reg_labels[] = {
+	LABEL(SUNXI_DAC_DPC),
+	LABEL(SUNXI_DAC_FIFOC),
+	LABEL(SUNXI_DAC_FIFO_STA),
+	LABEL(SUNXI_DAC_CNT),
+	LABEL(SUNXI_DAC_DG_REG),
+	LABEL(SUNXI_DAC_DAP_CTL),
+	LABEL(SUNXI_DAC_AC_DAC_REG),
+	LABEL(SUNXI_DAC_AC_MIXER_REG),
+	LABEL(SUNXI_DAC_AC_RAMP_REG),
+	LABEL_END,
+};
+
+struct regmap *codec_regmap_debug = NULL;
+
+struct sun50i_h616_codec {
+	unsigned char *name;
+	struct device	*dev;
+	struct regmap	*regmap;
+	struct clk	*clk_apb;
+	struct clk	*clk_module;
+	struct reset_control *rst;
+	struct gpio_desc *gpio_pa;
+
+	/* ADC_FIFOC register is at different offset on different SoCs */
+	struct regmap_field *reg_adc_fifoc;
+
+	struct snd_dmaengine_dai_dma_data	playback_dma_data;
+};
+
+static void sun50i_h616_codec_start_playback(struct sun50i_h616_codec *scodec)
+{
+	/* Flush TX FIFO */
+	regmap_update_bits(scodec->regmap, SUNXI_DAC_FIFOC,
+			   BIT(SUNXI_DAC_FIFOC_FIFO_FLUSH),
+			   BIT(SUNXI_DAC_FIFOC_FIFO_FLUSH));
+
+	/* Enable DAC DRQ */
+	regmap_update_bits(scodec->regmap, SUNXI_DAC_FIFOC,
+			   BIT(SUNXI_DAC_FIFOC_DAC_DRQ_EN),
+			   BIT(SUNXI_DAC_FIFOC_DAC_DRQ_EN));
+}
+
+static void sun50i_h616_codec_stop_playback(struct sun50i_h616_codec *scodec)
+{
+	/* Disable DAC DRQ */
+	regmap_update_bits(scodec->regmap, SUNXI_DAC_FIFOC,
+			   BIT(SUNXI_DAC_FIFOC_DAC_DRQ_EN),
+			   0);
+}
+
+static int sun50i_h616_codec_trigger(struct snd_pcm_substream *substream, int cmd,
+			       struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct sun50i_h616_codec *scodec = snd_soc_card_get_drvdata(rtd->card);
+
+	switch (cmd) {
+	case	SNDRV_PCM_TRIGGER_START:
+	case	SNDRV_PCM_TRIGGER_RESUME:
+	case	SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			regmap_update_bits(scodec->regmap,
+					SUNXI_DAC_FIFOC,
+					(0x1 << SUNXI_DAC_FIFOC_DAC_DRQ_EN),
+					(0x1 << SUNXI_DAC_FIFOC_DAC_DRQ_EN));
+		break;
+	case	SNDRV_PCM_TRIGGER_STOP:
+	case	SNDRV_PCM_TRIGGER_SUSPEND:
+	case	SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			regmap_update_bits(scodec->regmap,
+					SUNXI_DAC_FIFOC,
+					(0x1 << SUNXI_DAC_FIFOC_DAC_DRQ_EN),
+					(0x0 << SUNXI_DAC_FIFOC_DAC_DRQ_EN));
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int sun50i_h616_codec_prepare(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct sun50i_h616_codec *scodec = snd_soc_card_get_drvdata(rtd->card);
+
+	regmap_update_bits(scodec->regmap, SUNXI_DAC_FIFOC,
+		   (0x1 << SUNXI_DAC_FIFOC_FIFO_FLUSH),
+		   (0x1 << SUNXI_DAC_FIFOC_FIFO_FLUSH));
+	regmap_write(scodec->regmap, SUNXI_DAC_FIFO_STA,
+	   (0x1 << SUNXI_DAC_TXE_INT | 1 << SUNXI_DAC_TXU_INT | 0x1 << SUNXI_DAC_TXO_INT));
+	regmap_write(scodec->regmap, SUNXI_DAC_CNT, 0);
+	
+	return 0;
+}
+
+static unsigned long sun50i_h616_codec_get_mod_freq(struct snd_pcm_hw_params *params)
+{
+	unsigned int rate = params_rate(params);
+
+	switch (rate) {
+	case 176400:
+	case 88200:
+	case 44100:
+	case 33075:
+	case 22050:
+	case 14700:
+	case 11025:
+	case 7350:
+		return 22579200;
+
+	case 192000:
+	case 96000:
+	case 48000:
+	case 32000:
+	case 24000:
+	case 16000:
+	case 12000:
+	case 8000:
+		return 24576000;
+
+	default:
+		return 0;
+	}
+}
+
+static int sun50i_h616_codec_get_hw_rate(struct snd_pcm_hw_params *params)
+{
+	unsigned int rate = params_rate(params);
+
+	switch (rate) {
+	case 192000:
+	case 176400:
+		return 6;
+
+	case 96000:
+	case 88200:
+		return 7;
+
+	case 48000:
+	case 44100:
+		return 0;
+
+	case 32000:
+	case 33075:
+		return 1;
+
+	case 24000:
+	case 22050:
+		return 2;
+
+	case 16000:
+	case 14700:
+		return 3;
+
+	case 12000:
+	case 11025:
+		return 4;
+
+	case 8000:
+	case 7350:
+		return 5;
+
+	default:
+		return -EINVAL;
+	}
+}
+
+static int sun50i_h616_codec_hw_params_playback(struct sun50i_h616_codec *scodec,
+					  struct snd_pcm_hw_params *params,
+					  unsigned int hwrate)
+{
+	u32 val;
+
+	/* Set DAC sample rate */
+	regmap_update_bits(scodec->regmap, SUNXI_DAC_FIFOC,
+			   7 << SUNXI_DAC_FIFOC_DAC_FS,
+			   hwrate << SUNXI_DAC_FIFOC_DAC_FS);
+
+	/* Set the number of channels we want to use */
+	if (params_channels(params) == 1)
+		val = BIT(SUNXI_DAC_FIFOC_MONO_EN);
+	else
+		val = 0;
+
+	regmap_update_bits(scodec->regmap, SUNXI_DAC_FIFOC,
+			   BIT(SUNXI_DAC_FIFOC_MONO_EN),
+			   val);
+
+	/* Set the number of sample bits to either 16 or 24 bits */
+	if (hw_param_interval(params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS)->min == 32) {
+		regmap_update_bits(scodec->regmap, SUNXI_DAC_FIFOC,
+				   BIT(SUNXI_DAC_FIFOC_TX_SAMPLE_BITS),
+				   BIT(SUNXI_DAC_FIFOC_TX_SAMPLE_BITS));
+
+		/* Set TX FIFO mode to padding the LSBs with 0 */
+		regmap_update_bits(scodec->regmap, SUNXI_DAC_FIFOC,
+				   BIT(SUNXI_DAC_FIFOC_TX_FIFO_MODE),
+				   0);
+
+		scodec->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	} else {
+		regmap_update_bits(scodec->regmap, SUNXI_DAC_FIFOC,
+				   BIT(SUNXI_DAC_FIFOC_TX_SAMPLE_BITS),
+				   0);
+
+		/* Set TX FIFO mode to repeat the MSB */
+		regmap_update_bits(scodec->regmap, SUNXI_DAC_FIFOC,
+				   BIT(SUNXI_DAC_FIFOC_TX_FIFO_MODE),
+				   BIT(SUNXI_DAC_FIFOC_TX_FIFO_MODE));
+
+		scodec->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	}
+
+	return 0;
+}
+
+struct sample_rate {
+	unsigned int samplerate;
+	unsigned int rate_bit;
+};
+
+static const struct sample_rate sample_rate_conv[] = {
+	{44100, 0},
+	{48000, 0},
+	{8000, 5},
+	{32000, 1},
+	{22050, 2},
+	{24000, 2},
+	{16000, 3},
+	{11025, 4},
+	{12000, 4},
+	{192000, 6},
+	{96000, 7},
+};
+
+static int sun50i_h616_codec_hw_params(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *params,
+				 struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct sun50i_h616_codec *scodec = snd_soc_card_get_drvdata(rtd->card);
+	unsigned long clk_freq;
+	int ret, hwrate;
+	int i;
+
+	clk_freq = sun50i_h616_codec_get_mod_freq(params);
+	if (!clk_freq)
+		return -EINVAL;
+
+	ret = clk_set_rate(scodec->clk_module, clk_freq * 2);
+	if (ret)
+		return ret;
+
+	hwrate = sun50i_h616_codec_get_hw_rate(params);
+	if (hwrate < 0)
+		return hwrate;
+
+	switch (params_format(params)) {
+	case	SNDRV_PCM_FORMAT_S16_LE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			regmap_update_bits(scodec->regmap,
+					SUNXI_DAC_FIFOC,
+					(0x3 << SUNXI_DAC_FIFOC_TX_FIFO_MODE),
+					(0x3 << SUNXI_DAC_FIFOC_TX_FIFO_MODE));
+			regmap_update_bits(scodec->regmap,
+					SUNXI_DAC_FIFOC,
+					(0x1 << SUNXI_DAC_FIFOC_TX_SAMPLE_BITS),
+					(0x0 << SUNXI_DAC_FIFOC_TX_SAMPLE_BITS));
+		} 
+		break;
+	case	SNDRV_PCM_FORMAT_S24_LE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			regmap_update_bits(scodec->regmap,
+					SUNXI_DAC_FIFOC,
+					(0x3 << SUNXI_DAC_FIFOC_TX_FIFO_MODE),
+					(0x0 << SUNXI_DAC_FIFOC_TX_FIFO_MODE));
+			regmap_update_bits(scodec->regmap,
+					SUNXI_DAC_FIFOC,
+					(0x1 << SUNXI_DAC_FIFOC_TX_SAMPLE_BITS),
+					(0x1 << SUNXI_DAC_FIFOC_TX_SAMPLE_BITS));
+		}
+		break;
+	default:
+		break;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(sample_rate_conv); i++) {
+		if (sample_rate_conv[i].samplerate == params_rate(params)) {
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+				regmap_update_bits(scodec->regmap,
+					SUNXI_DAC_FIFOC,
+					(0x7 << SUNXI_DAC_FIFOC_DAC_FS),
+					(sample_rate_conv[i].rate_bit << SUNXI_DAC_FIFOC_DAC_FS));
+			}
+		}
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		switch (params_channels(params)) {
+		case 1:
+			regmap_update_bits(scodec->regmap,
+					SUNXI_DAC_FIFOC,
+					(0x1 << SUNXI_DAC_FIFOC_MONO_EN),
+					(0x1 << SUNXI_DAC_FIFOC_MONO_EN));
+			break;
+		case 2:
+			regmap_update_bits(scodec->regmap,
+					SUNXI_DAC_FIFOC,
+					(0x1 << SUNXI_DAC_FIFOC_MONO_EN),
+					(0x0 << SUNXI_DAC_FIFOC_MONO_EN));
+			break;
+		default:
+			pr_err("[%s] Playback cannot support %d channels.\n",
+				__func__, params_channels(params));
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static unsigned int sun50i_h616_codec_src_rates[] = {
+	8000, 11025, 12000, 16000, 22050, 24000, 32000,
+	44100, 48000, 96000, 192000
+};
+
+static struct snd_pcm_hw_constraint_list sun50i_h616_codec_constraints = {
+	.count  = ARRAY_SIZE(sun50i_h616_codec_src_rates),
+	.list   = sun50i_h616_codec_src_rates,
+};
+
+static int sun50i_h616_codec_startup(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct sun50i_h616_codec *scodec = snd_soc_card_get_drvdata(rtd->card);
+
+	snd_pcm_hw_constraint_list(substream->runtime, 0,
+				SNDRV_PCM_HW_PARAM_RATE, &sun50i_h616_codec_constraints);
+
+	/*
+	 * Stop issuing DRQ when we have room for less than 16 samples
+	 * in our TX FIFO
+	 */
+	regmap_update_bits(scodec->regmap, SUNXI_DAC_FIFOC,
+	                   3 << SUNXI_DAC_FIFOC_DRQ_CLR_CNT,
+	                   3 << SUNXI_DAC_FIFOC_DRQ_CLR_CNT);
+
+	return clk_prepare_enable(scodec->clk_module);
+}
+
+static void sun50i_h616_codec_shutdown(struct snd_pcm_substream *substream,
+				 struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct sun50i_h616_codec *scodec = snd_soc_card_get_drvdata(rtd->card);
+
+	clk_disable_unprepare(scodec->clk_module);
+}
+
+static const struct snd_soc_dai_ops sun50i_h616_codec_dai_ops = {
+	.startup	= sun50i_h616_codec_startup,
+	.shutdown	= sun50i_h616_codec_shutdown,
+	.trigger	= sun50i_h616_codec_trigger,
+	.hw_params	= sun50i_h616_codec_hw_params,
+	.prepare	= sun50i_h616_codec_prepare,
+};
+
+static struct snd_soc_dai_driver sun50i_h616_codec_dai = {
+	.name	= "Codec",
+	.ops	= &sun50i_h616_codec_dai_ops,
+	.playback = {
+		.stream_name	= "Codec Playback",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rate_min	= 8000,
+		.rate_max	= 192000,
+		.rates		= SNDRV_PCM_RATE_8000_192000
+					  | SNDRV_PCM_RATE_KNOT,
+		.formats	= SNDRV_PCM_FMTBIT_S16_LE |
+				  SNDRV_PCM_FMTBIT_S24_LE,
+		.sig_bits	= 24,
+	},
+};
+
+static int sunxi_lineout_event(struct snd_soc_dapm_widget *w,
+				  struct snd_kcontrol *k, int event)
+{
+	struct sun50i_h616_codec *scodec = snd_soc_card_get_drvdata(w->dapm->card);
+
+	switch (event) {
+	case	SND_SOC_DAPM_POST_PMU:
+
+		regmap_update_bits(scodec->regmap, SUNXI_DAC_AC_RAMP_REG,
+			(0x1 << SUNXI_RDEN), (0x1 << SUNXI_RDEN));
+		msleep(25);
+	
+		regmap_update_bits(scodec->regmap, SUNXI_DAC_AC_DAC_REG,
+				(0x1 << SUNXI_LINEOUTL_EN) | (0x1 << SUNXI_LINEOUTR_EN),
+				(0x1 << SUNXI_LINEOUTL_EN) | (0x1 << SUNXI_LINEOUTR_EN));
+		break;
+	case	SND_SOC_DAPM_PRE_PMD:
+
+		regmap_update_bits(scodec->regmap, SUNXI_DAC_AC_RAMP_REG,
+					(0x1 << SUNXI_RDEN), (0x0 << SUNXI_RDEN));
+		msleep(25);
+		
+		regmap_update_bits(scodec->regmap, SUNXI_DAC_AC_DAC_REG,
+			(0x1 << SUNXI_LINEOUTL_EN) | (0x1 << SUNXI_LINEOUTR_EN),
+			(0x0 << SUNXI_LINEOUTL_EN) | (0x0 << SUNXI_LINEOUTR_EN));
+
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static const DECLARE_TLV_DB_SCALE(digital_tlv, 0, -116, -7424);
+static const DECLARE_TLV_DB_SCALE(linein_to_l_r_mix_vol_tlv, -450, 150, 0);
+static const DECLARE_TLV_DB_SCALE(fmin_to_l_r_mix_vol_tlv, -450, 150, 0);
+
+static const unsigned int lineout_tlv[] = {
+	TLV_DB_RANGE_HEAD(2),
+	0, 0, TLV_DB_SCALE_ITEM(0, 0, 1),
+	1, 31, TLV_DB_SCALE_ITEM(-4350, 150, 1),
+};
+
+/*lineoutL mux select */
+const char * const left_lineoutl_text[] = {
+	"LOMixer", "LROMixer",
+};
+
+static const struct soc_enum left_lineout_enum =
+SOC_ENUM_SINGLE(SUNXI_DAC_AC_DAC_REG, SUNXI_LINEOUTL_SEL,
+ARRAY_SIZE(left_lineoutl_text), left_lineoutl_text);
+
+static const struct snd_kcontrol_new left_lineout_mux =
+SOC_DAPM_ENUM("Left LINEOUT Mux", left_lineout_enum);
+
+/*lineoutR mux select */
+const char * const right_lineoutr_text[] = {
+	"ROMixer", "LROMixer",
+};
+
+static const struct soc_enum right_lineout_enum =
+SOC_ENUM_SINGLE(SUNXI_DAC_AC_DAC_REG, SUNXI_LINEOUTR_SEL,
+ARRAY_SIZE(right_lineoutr_text), right_lineoutr_text);
+
+static const struct snd_kcontrol_new right_lineout_mux =
+SOC_DAPM_ENUM("Right LINEOUT Mux", right_lineout_enum);
+
+
+static const struct snd_kcontrol_new sun50i_h616_codec_codec_controls[] = {
+
+	SOC_SINGLE_TLV("digital volume", SUNXI_DAC_DPC,
+				SUNXI_DAC_DPC_DVOL, 0x3F, 0, digital_tlv),
+
+	SOC_SINGLE_TLV("LINEOUT volume", SUNXI_DAC_AC_DAC_REG,
+					SUNXI_LINEOUT_VOL, 0x1F, 0, lineout_tlv),
+};
+
+static const struct snd_kcontrol_new left_output_mixer[] = {
+	SOC_DAPM_SINGLE("DACL Switch", SUNXI_DAC_AC_MIXER_REG, SUNXI_LMIX_LDAC, 1, 0),
+	SOC_DAPM_SINGLE("DACR Switch", SUNXI_DAC_AC_MIXER_REG, SUNXI_LMIX_RDAC, 1, 0),
+};
+
+static const struct snd_kcontrol_new right_output_mixer[] = {
+	SOC_DAPM_SINGLE("DACL Switch", SUNXI_DAC_AC_MIXER_REG, SUNXI_RMIX_LDAC, 1, 0),
+	SOC_DAPM_SINGLE("DACR Switch", SUNXI_DAC_AC_MIXER_REG, SUNXI_RMIX_RDAC, 1, 0),
+};
+
+static const struct snd_soc_dapm_widget sun50i_h616_codec_codec_widgets[] = {
+
+	/* Digital parts of the DACs */
+	SND_SOC_DAPM_SUPPLY("DAC Enable", SUNXI_DAC_DPC,
+						SUNXI_DAC_DPC_EN_DA, 0, NULL, 0),
+
+	SND_SOC_DAPM_AIF_IN_E("DACL", "Codec Playback", 0, SUNXI_DAC_AC_DAC_REG, SUNXI_DAC_LEN, 0,
+				NULL, 0),
+	SND_SOC_DAPM_AIF_IN_E("DACR", "Codec Playback", 0, SUNXI_DAC_AC_DAC_REG, SUNXI_DAC_REN, 0,
+				NULL, 0),
+
+	SND_SOC_DAPM_MIXER("Left Output Mixer", SUNXI_DAC_AC_MIXER_REG, SUNXI_LMIXEN, 0,
+			left_output_mixer, ARRAY_SIZE(left_output_mixer)),
+	SND_SOC_DAPM_MIXER("Right Output Mixer", SUNXI_DAC_AC_MIXER_REG, SUNXI_RMIXEN, 0,
+			right_output_mixer, ARRAY_SIZE(right_output_mixer)),
+
+	SND_SOC_DAPM_MUX("Left LINEOUT Mux", SND_SOC_NOPM,
+			0, 0, &left_lineout_mux),
+	SND_SOC_DAPM_MUX("Right LINEOUT Mux", SND_SOC_NOPM,
+			0, 0, &right_lineout_mux),
+
+	SND_SOC_DAPM_OUTPUT("LINEOUTL"),
+	SND_SOC_DAPM_OUTPUT("LINEOUTR"),
+
+	SND_SOC_DAPM_LINE("LINEOUT", sunxi_lineout_event),
+};
+
+static const struct snd_soc_component_driver sun50i_h616_codec_codec = {
+	.controls		= sun50i_h616_codec_codec_controls,
+	.num_controls		= ARRAY_SIZE(sun50i_h616_codec_codec_controls),
+	.dapm_widgets		= sun50i_h616_codec_codec_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(sun50i_h616_codec_codec_widgets),
+	.idle_bias_on		= 1,
+	.use_pmdown_time	= 1,
+	.endianness		= 1,
+	.non_legacy_dai_naming	= 1,
+};
+
+static const struct snd_soc_component_driver sun50i_h616_codec_component = {
+	.name = "sun50i_h616-codec",
+};
+
+#define SUN50IW9_CODEC_RATES	(SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT)
+#define SUN50IW9_CODEC_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE)
+
+static int sun50i_h616_codec_dai_probe(struct snd_soc_dai *dai)
+{
+	struct snd_soc_card *card = snd_soc_dai_get_drvdata(dai);
+	struct sun50i_h616_codec *scodec = snd_soc_card_get_drvdata(card);
+
+	snd_soc_dai_init_dma_data(dai, &scodec->playback_dma_data,
+				  NULL);
+
+	return 0;
+}
+
+static struct snd_soc_dai_driver dummy_cpu_dai = {
+	.name	= "sun50i_h616-codec-cpu-dai",
+	.probe	= sun50i_h616_codec_dai_probe,
+	.playback = {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates		= SUN50IW9_CODEC_RATES,
+		.formats	= SUN50IW9_CODEC_FORMATS,
+		.sig_bits	= 24,
+	},
+};
+
+static struct snd_soc_dai_link *sun50i_h616_codec_create_link(struct device *dev,
+							int *num_links)
+{
+	struct snd_soc_dai_link *link = devm_kzalloc(dev, sizeof(*link),
+						     GFP_KERNEL);
+	struct snd_soc_dai_link_component *dlc = devm_kzalloc(dev,
+						3 * sizeof(*dlc), GFP_KERNEL);
+	if (!link || !dlc)
+		return NULL;
+
+	link->cpus	= &dlc[0];
+	link->codecs	= &dlc[1];
+	link->platforms	= &dlc[2];
+
+	link->num_cpus		= 1;
+	link->num_codecs	= 1;
+	link->num_platforms	= 1;
+
+	link->name		= "cdc";
+	link->stream_name	= "CDC PCM";
+	link->codecs->dai_name	= "Codec";
+	link->cpus->dai_name	= dev_name(dev);
+	link->codecs->name	= dev_name(dev);
+	link->platforms->name	= dev_name(dev);
+	link->dai_fmt		= SND_SOC_DAIFMT_I2S;
+	link->playback_only = true;
+	link->capture_only = false;
+
+	*num_links = 1;
+
+	return link;
+};
+
+static int sun50i_h616_codec_spk_event(struct snd_soc_dapm_widget *w,
+				 struct snd_kcontrol *k, int event)
+{
+	struct sun50i_h616_codec *scodec = snd_soc_card_get_drvdata(w->dapm->card);
+
+	gpiod_set_value_cansleep(scodec->gpio_pa,
+				 !!SND_SOC_DAPM_EVENT_ON(event));
+
+	if (SND_SOC_DAPM_EVENT_ON(event)) {
+		/*
+		 * Need a delay to wait for DAC to push the data. 700ms seems
+		 * to be the best compromise not to feel this delay while
+		 * playing a sound.
+		 */
+		msleep(700);
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_dapm_widget sun6i_codec_card_dapm_widgets[] = {
+	SND_SOC_DAPM_LINE("Line Out", NULL),
+	SND_SOC_DAPM_SPK("Speaker", sun50i_h616_codec_spk_event),
+};
+
+/* Connect digital side enables to analog side widgets */
+static const struct snd_soc_dapm_route sun8i_codec_card_routes[] = {
+	/* DAC Routes */
+	{ "DACR", NULL, "DAC Enable" },
+	{ "DACL", NULL, "DAC Enable" },
+
+	{"Left Output Mixer", "DACR Switch", "DACR"},
+	{"Left Output Mixer", "DACL Switch", "DACL"},
+
+	{"Right Output Mixer", "DACL Switch", "DACL"},
+	{"Right Output Mixer", "DACR Switch", "DACR"},
+
+	{"Left LINEOUT Mux", "LOMixer", "Left Output Mixer"},
+	{"Left LINEOUT Mux", "LROMixer", "Right Output Mixer"},
+	{"Right LINEOUT Mux", "ROMixer", "Right Output Mixer"},
+	{"Right LINEOUT Mux", "LROMixer", "Left Output Mixer"},
+
+	{"LINEOUTL", NULL, "Left LINEOUT Mux"},
+	{"LINEOUTR", NULL, "Right LINEOUT Mux"},
+
+	{"LINEOUT", NULL, "LINEOUTL"},
+	{"LINEOUT", NULL, "LINEOUTR"},
+
+	{"Speaker", NULL, "LINEOUTL"},
+	{"Speaker", NULL, "LINEOUTR"},
+};
+
+static const struct snd_kcontrol_new sunxi_card_controls[] = {
+	SOC_DAPM_PIN_SWITCH("LINEOUT"),
+};
+
+static struct snd_soc_card *sun50i_h616_codec_create_card(struct device *dev)
+{
+	struct snd_soc_card *card;
+	int ret;
+
+	card = devm_kzalloc(dev, sizeof(*card), GFP_KERNEL);
+	if (!card)
+		return ERR_PTR(-ENOMEM);
+
+	card->dai_link = sun50i_h616_codec_create_link(dev, &card->num_links);
+	if (!card->dai_link)
+		return ERR_PTR(-ENOMEM);
+
+	card->dev		= dev;
+	card->owner		= THIS_MODULE;
+	card->name		= "H616 Audio Codec";
+	card->controls  = sunxi_card_controls;
+	card->num_controls	= ARRAY_SIZE(sunxi_card_controls),
+	card->dapm_widgets	= sun6i_codec_card_dapm_widgets;
+	card->num_dapm_widgets	= ARRAY_SIZE(sun6i_codec_card_dapm_widgets);
+	card->dapm_routes	= sun8i_codec_card_routes;
+	card->num_dapm_routes	= ARRAY_SIZE(sun8i_codec_card_routes);
+	card->fully_routed	= true;
+
+	ret = snd_soc_of_parse_audio_routing(card, "allwinner,audio-routing");
+	if (ret)
+		dev_warn(dev, "failed to parse audio-routing: %d\n", ret);
+
+	return card;
+};
+
+static const struct regmap_config sun50i_h616_codec_regmap_config = {
+	.reg_bits	= 32,
+	.reg_stride	= 4,
+	.val_bits	= 32,
+	.max_register	= SUNXI_DAC_AC_RAMP_REG,
+	.cache_type = REGCACHE_NONE,
+};
+
+struct sun50i_h616_codec_quirks {
+	const struct regmap_config *regmap_config;
+	const struct snd_soc_component_driver *codec;
+	struct snd_soc_card * (*create_card)(struct device *dev);
+	struct reg_field reg_adc_fifoc;	/* used for regmap_field */
+	unsigned int reg_dac_txdata;	/* TX FIFO offset for DMA config */
+	unsigned int reg_adc_rxdata;	/* RX FIFO offset for DMA config */
+	bool has_reset;
+};
+
+static const struct sun50i_h616_codec_quirks sun50i_h616_codec_quirks = {
+	.regmap_config	= &sun50i_h616_codec_regmap_config,
+	.codec		= &sun50i_h616_codec_codec,
+	.create_card	= sun50i_h616_codec_create_card,
+	.reg_dac_txdata	= SUNXI_DAC_TXDATA,
+	.has_reset	= true,
+};
+
+static const struct of_device_id sun50i_h616_codec_of_match[] = {
+	{
+		.compatible = "allwinner,sun50i-h616-codec",
+		.data = &sun50i_h616_codec_quirks,
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(of, sun50i_h616_codec_of_match);
+
+static ssize_t show_audio_reg(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int count = 0, i = 0;
+	unsigned int reg_val;
+	unsigned int size = ARRAY_SIZE(reg_labels);
+	
+	count += sprintf(buf, "dump audiocodec reg:\n");
+	
+	while ((i < size) && (reg_labels[i].name != NULL)) {
+			regmap_read(codec_regmap_debug,
+							reg_labels[i].address, &reg_val);
+			count += sprintf(buf + count, "%-20s [0x%03x]: 0x%-10x save_val:0x%x\n",
+					reg_labels[i].name, (reg_labels[i].address),
+					reg_val, reg_labels[i].value);
+			i++;
+	}
+	
+	return count;
+}
+
+static DEVICE_ATTR(audio_reg, 0644, show_audio_reg, NULL);
+
+static struct attribute *audio_debug_attrs[] = {
+	&dev_attr_audio_reg.attr,
+	NULL,
+};
+
+static struct attribute_group audio_debug_attr_group = {
+	.name	= "audio_reg_debug",
+	.attrs	= audio_debug_attrs,
+};
+
+static void sunxi_codec_init(struct sun50i_h616_codec *scodec)
+{
+	/* Disable DRC function for playback */
+	regmap_write(scodec->regmap, SUNXI_DAC_DAP_CTL, 0);
+
+	/* Enable HPF(high passed filter) */
+	regmap_update_bits(scodec->regmap, SUNXI_DAC_DPC,
+			(0x1 << SUNXI_DAC_DPC_HPF_EN), (0x1 << SUNXI_DAC_DPC_HPF_EN));
+
+	regmap_update_bits(scodec->regmap, SUNXI_DAC_AC_DAC_REG,
+			(0x1f << SUNXI_LINEOUT_VOL),
+			(0x1a << SUNXI_LINEOUT_VOL));
+
+	regmap_update_bits(scodec->regmap, SUNXI_DAC_DPC,
+			(0x3f << SUNXI_DAC_DPC_DVOL), (0 << SUNXI_DAC_DPC_DVOL));
+
+	/* Mixer to channel LINEOUT MUTE control init */
+	regmap_update_bits(scodec->regmap, SUNXI_DAC_AC_DAC_REG,
+			(0x1 << SUNXI_LMUTE), (0x1 << SUNXI_LMUTE));
+	regmap_update_bits(scodec->regmap, SUNXI_DAC_AC_DAC_REG,
+			(0x1 << SUNXI_RMUTE), (0x1 << SUNXI_RMUTE));
+
+	/* ramp func about */
+	if (0) {
+	/* Not used the ramp func cause there is the MUTE to avoid pop noise */
+		regmap_update_bits(scodec->regmap, SUNXI_DAC_AC_DAC_REG,
+				(0x1 << SUNXI_RSWITCH), (0x1 << SUNXI_RSWITCH));
+
+		regmap_update_bits(scodec->regmap, SUNXI_DAC_AC_DAC_REG,
+				(0x1 << SUNXI_RAMPEN), (0x0 << SUNXI_RAMPEN));
+
+		regmap_update_bits(scodec->regmap, SUNXI_DAC_AC_RAMP_REG,
+				(0x7 << SUNXI_RAMP_STEP), (0x0 << SUNXI_RAMP_STEP));
+
+		regmap_update_bits(scodec->regmap, SUNXI_DAC_AC_RAMP_REG,
+				(0x1 << SUNXI_RDEN), (0x0 << SUNXI_RDEN));
+	} else {
+	/* If no MUTE to avoid pop, just use the ramp func to avoid it */
+		regmap_update_bits(scodec->regmap, SUNXI_DAC_AC_DAC_REG,
+				(0x1 << SUNXI_RSWITCH), (0x0 << SUNXI_RSWITCH));
+
+		regmap_update_bits(scodec->regmap, SUNXI_DAC_AC_DAC_REG,
+				(0x1 << SUNXI_RAMPEN), (0x1 << SUNXI_RAMPEN));
+
+		regmap_update_bits(scodec->regmap, SUNXI_DAC_AC_RAMP_REG,
+				(0x7 << SUNXI_RAMP_STEP), (0x1 << SUNXI_RAMP_STEP));
+	}
+}
+
+static int sun50i_h616_codec_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card;
+	struct sun50i_h616_codec *scodec;
+	const struct sun50i_h616_codec_quirks *quirks;
+	struct resource *res;
+	void __iomem *base;
+	int ret;
+
+	scodec = devm_kzalloc(&pdev->dev, sizeof(struct sun50i_h616_codec), GFP_KERNEL);
+	if (!scodec)
+		return -ENOMEM;
+
+	scodec->dev = &pdev->dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	quirks = of_device_get_match_data(&pdev->dev);
+	if (quirks == NULL) {
+		dev_err(&pdev->dev, "Failed to determine the quirks to use\n");
+		return -ENODEV;
+	}
+
+	scodec->regmap = devm_regmap_init_mmio(&pdev->dev, base,
+					       quirks->regmap_config);
+	if (IS_ERR(scodec->regmap)) {
+		dev_err(&pdev->dev, "Failed to create our regmap\n");
+		return PTR_ERR(scodec->regmap);
+	}
+
+	/* Get the clocks from the DT */
+	scodec->clk_apb = devm_clk_get(&pdev->dev, "apb");
+	if (IS_ERR(scodec->clk_apb)) {
+		dev_err(&pdev->dev, "Failed to get the APB clock\n");
+		return PTR_ERR(scodec->clk_apb);
+	}
+
+	scodec->clk_module = devm_clk_get(&pdev->dev, "audio-codec-1x");
+	if (IS_ERR(scodec->clk_module)) {
+		dev_err(&pdev->dev, "Failed to get the codec module clock\n");
+		return PTR_ERR(scodec->clk_module);
+	}
+
+	if (quirks->has_reset) {
+		scodec->rst = devm_reset_control_get_exclusive(&pdev->dev,
+							       NULL);
+		if (IS_ERR(scodec->rst)) {
+			dev_err(&pdev->dev, "Failed to get reset control\n");
+			return PTR_ERR(scodec->rst);
+		}
+	}
+
+	scodec->gpio_pa = devm_gpiod_get_optional(&pdev->dev, "allwinner,pa",
+						  GPIOD_OUT_LOW);
+	if (IS_ERR(scodec->gpio_pa)) {
+		ret = PTR_ERR(scodec->gpio_pa);
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Failed to get pa gpio: %d\n", ret);
+		return ret;
+	}
+
+	/* Enable the bus clock */
+	if (clk_prepare_enable(scodec->clk_apb)) {
+		dev_err(&pdev->dev, "Failed to enable the APB clock\n");
+		return -EINVAL;
+	}
+
+	/* Deassert the reset control */
+	if (scodec->rst) {
+		ret = reset_control_deassert(scodec->rst);
+		if (ret) {
+			dev_err(&pdev->dev,
+				"Failed to deassert the reset control\n");
+			goto err_clk_disable;
+		}
+	}
+
+	/* DMA configuration for TX FIFO */
+	scodec->playback_dma_data.addr = res->start + quirks->reg_dac_txdata;
+	scodec->playback_dma_data.maxburst = 8;
+	scodec->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+
+	ret = devm_snd_soc_register_component(&pdev->dev, quirks->codec,
+				     &sun50i_h616_codec_dai, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to register our codec\n");
+		goto err_assert_reset;
+	}
+
+	ret = devm_snd_soc_register_component(&pdev->dev,
+					      &sun50i_h616_codec_component,
+					      &dummy_cpu_dai, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to register our DAI\n");
+		goto err_assert_reset;
+	}
+
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to register against DMAEngine\n");
+		goto err_assert_reset;
+	}
+
+	card = quirks->create_card(&pdev->dev);
+	if (IS_ERR(card)) {
+		ret = PTR_ERR(card);
+		dev_err(&pdev->dev, "Failed to create our card\n");
+		goto err_assert_reset;
+	}
+
+	snd_soc_card_set_drvdata(card, scodec);
+
+	codec_regmap_debug = scodec->regmap;
+
+	ret = snd_soc_register_card(card);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to register our card\n");
+		goto err_assert_reset;
+	}
+
+	ret  = sysfs_create_group(&pdev->dev.kobj, &audio_debug_attr_group);
+	if (ret)
+		dev_warn(&pdev->dev, "failed to create attr group\n");
+
+	sunxi_codec_init(scodec);
+
+	return 0;
+
+err_assert_reset:
+	if (scodec->rst)
+		reset_control_assert(scodec->rst);
+err_clk_disable:
+	clk_disable_unprepare(scodec->clk_apb);
+	return ret;
+}
+
+static int sun50i_h616_codec_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	struct sun50i_h616_codec *scodec = snd_soc_card_get_drvdata(card);
+
+	snd_soc_unregister_card(card);
+	if (scodec->rst)
+		reset_control_assert(scodec->rst);
+	clk_disable_unprepare(scodec->clk_apb);
+
+	return 0;
+}
+
+static struct platform_driver sun50i_h616_codec_driver = {
+	.driver = {
+		.name = "sun50i-h616-codec",
+		.of_match_table = sun50i_h616_codec_of_match,
+	},
+	.probe = sun50i_h616_codec_probe,
+	.remove = sun50i_h616_codec_remove,
+};
+module_platform_driver(sun50i_h616_codec_driver);
+
+MODULE_DESCRIPTION("Allwinner H616 codec driver");
+MODULE_AUTHOR("Emilio López <emilio@elopez.com.ar>");
+MODULE_AUTHOR("Jon Smirl <jonsmirl@gmail.com>");
+MODULE_AUTHOR("Maxime Ripard <maxime.ripard@free-electrons.com>");
+MODULE_AUTHOR("Chen-Yu Tsai <wens@csie.org>");
+MODULE_AUTHOR("Leeboby <leeboby@aliyun.com>");
+MODULE_LICENSE("GPL");
